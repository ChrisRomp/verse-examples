# Verse Code Database - Generated on 2025-11-15 17:21:34

*This file is automatically generated. Do not edit manually.*


# File: C:\Users\chrisromp\dev\verse-examples\Ability Scripts\double_life.verse
using { /Fortnite.com/Characters }
using { /Fortnite.com/UI }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Colors }
using { /Verse.org/Random }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/UI }
using { /Fortnite.com/Game }

#    _______ .______    __  .__   __.  _______ .______   .__   __.     ______ .______    _______     ___   .___________. _______     _____.
#   /  _____||   _  \  |  | |  \ |  | |   ____||   _  \  |  \ |  |    /      ||   _  \  |   ____|   /   \  |           ||   ____|   /     |
#  |  |  __  |  |_)  | |  | |   \|  | |  |__   |  |_)  | |   \|  |   |  ,----'|  |_)  | |  |__     /  ^  \ `---|  |----`|  |__     |   (--`
#  |  | |_ | |      /  |  | |  . `  | |   __|  |      /  |  . `  |   |  |     |      /  |   __|   /  /_\  \    |  |     |   __|     \   \  
#  |  |__| | |  |\  \-.|  | |  |\   | |  |____ |  |\  \-.|  |\   |   |  `----.|  |\  \-.|  |____ /  _____  \   |  |     |  |____  .--)   | 
#   \______| | _| `.__||__| |__| \__| |_______|| _| `.__||__| \__|    \______|| _| `.__||_______/__/     \__\  |__|     |_______| |_____/  
                                                                                                                                         
#Discord: @Grinern
#Twitter: @GrinernCreates
#Youtube: @GrinernCreates

double_life := class(creative_device):

    @editable
    DoubleLife: down_but_not_out_device = down_but_not_out_device{}

    amountOfLives: int = 1

    OnBegin<override>()<suspends >:void=
        Print("@GrinernCreates Script Started")
        DoubleLife.AgentDownedEvent.Subscribe(DoubleLifeEvent)

    DoubleLifeEvent(Agent:agent):void=
        spawn:
            CheckForDoubleLife(Agent)
    
    CheckForDoubleLife(Agent:agent)<suspends>:void=
        if(amountOfLives >= 1):
            Sleep(1.0)
            DoubleLife.Revive(Agent)
            Print("Revived")
            Sleep(0.1)
            if (Player : fort_character = Agent.GetFortCharacter[]):
                Player.SetHealth(100.0)
                Player.SetShield(100.0)
            Print("Given health")
            if(amountOfLives = 0):
                DoubleLife.Disable
            amountOfLives - 1

# End of file: double_life.verse


# File: C:\Users\chrisromp\dev\verse-examples\Ability Scripts\freeze_player.verse
using { /Fortnite.com/Characters }
using { /Fortnite.com/UI }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Colors }
using { /Verse.org/Random }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/UI }
using { /Fortnite.com/Game }

#    _______ .______    __  .__   __.  _______ .______   .__   __.     ______ .______    _______     ___   .___________. _______     _____.
#   /  _____||   _  \  |  | |  \ |  | |   ____||   _  \  |  \ |  |    /      ||   _  \  |   ____|   /   \  |           ||   ____|   /     |
#  |  |  __  |  |_)  | |  | |   \|  | |  |__   |  |_)  | |   \|  |   |  ,----'|  |_)  | |  |__     /  ^  \ `---|  |----`|  |__     |   (--`
#  |  | |_ | |      /  |  | |  . `  | |   __|  |      /  |  . `  |   |  |     |      /  |   __|   /  /_\  \    |  |     |   __|     \   \  
#  |  |__| | |  |\  \-.|  | |  |\   | |  |____ |  |\  \-.|  |\   |   |  `----.|  |\  \-.|  |____ /  _____  \   |  |     |  |____  .--)   | 
#   \______| | _| `.__||__| |__| \__| |_______|| _| `.__||__| \__|    \______|| _| `.__||_______/__/     \__\  |__|     |_______| |_____/  
                                                                                                                                         
#Discord: @Grinern
#Twitter: @GrinernCreates
#Youtube: @GrinernCreates

Template := class(creative_device):

    @editable
    FreezeButtons: []conditional_button_device = array{conditional_button_device{} , conditional_button_device{} ,conditional_button_device{} ,conditional_button_device{}}

    @editable
    FreezeClass: class_and_team_selector_device = class_and_team_selector_device{}

    @editable
    FreezeTimer: timer_device = timer_device{}

    @editable
    FreezeHud: hud_message_device = hud_message_device{}

    @editable
    FreezeDetector: conditional_button_device = conditional_button_device{}

    @editable 
    FreezeTime : float = 3.0

    @editable
    DefaultClass: class_and_team_selector_device = class_and_team_selector_device{}

    OnBegin<override>()<suspends>:void=
        Print("@GrinernCreates Script Started")
        GetPlayspace().PlayerAddedEvent().Subscribe(OnPlayerAdded)
        for (Player : GetPlayspace().GetPlayers(), FortCharacter := Player.GetFortCharacter[]):
            FortCharacter.DamagedEvent().Subscribe(OnPlayerDamaged)
            FortCharacter.DamagedShieldEvent().Subscribe(OnPlayerDamaged)

        FreezeTimer.SuccessEvent.Subscribe(Default)

        # Subscribe FreezeButtons to FreezeActivated
        for (Button : FreezeButtons):
            Button.ActivatedEvent.Subscribe(FreezeActivated)

    Default(Agent:?agent):void=
        if (ActualAgent := Agent?):
            DefaultClass.ChangeClass(ActualAgent)

    FreezeActivated(Agent:agent):void=
        FreezeClass.ChangeClass(Agent)
        FreezeHud.Show(Agent)
        FreezeTimer.Start(Agent)

    OnPlayerDamaged(DamageResult : damage_result): void =
        if:
            Instigator := DamageResult.Instigator?
            Agent := Instigator.GetInstigatorAgent[]
            FreezeDetector.IsHoldingItem[Agent]
            Target := fort_character[DamageResult.Target]

        then:
            spawn:
                FreezePlayer(Target)

    FreezePlayer(Target : fort_character)<suspends> : void =
        Target.PutInStasis(stasis_args{})
        Sleep(FreezeTime)
        Target.ReleaseFromStasis()

    OnPlayerAdded(Player : player) : void =
        if (FortCharacter := Player.GetFortCharacter[]):
            FortCharacter.DamagedEvent().Subscribe(OnPlayerDamaged)
            FortCharacter.DamagedShieldEvent().Subscribe(OnPlayerDamaged)

# End of file: freeze_player.verse


# File: C:\Users\chrisromp\dev\verse-examples\Ability Scripts\invisibility.verse
using { /Fortnite.com/Characters }
using { /Fortnite.com/UI }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Colors }
using { /Verse.org/Random }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/UI }
using { /Fortnite.com/Game }

#    _______ .______    __  .__   __.  _______ .______   .__   __.     ______ .______    _______     ___   .___________. _______     _____.
#   /  _____||   _  \  |  | |  \ |  | |   ____||   _  \  |  \ |  |    /      ||   _  \  |   ____|   /   \  |           ||   ____|   /     |
#  |  |  __  |  |_)  | |  | |   \|  | |  |__   |  |_)  | |   \|  |   |  ,----'|  |_)  | |  |__     /  ^  \ `---|  |----`|  |__     |   (--`
#  |  | |_ | |      /  |  | |  . `  | |   __|  |      /  |  . `  |   |  |     |      /  |   __|   /  /_\  \    |  |     |   __|     \   \  
#  |  |__| | |  |\  \-.|  | |  |\   | |  |____ |  |\  \-.|  |\   |   |  `----.|  |\  \-.|  |____ /  _____  \   |  |     |  |____  .--)   | 
#   \______| | _| `.__||__| |__| \__| |_______|| _| `.__||__| \__|    \______|| _| `.__||_______/__/     \__\  |__|     |_______| |_____/  
                                                                                                                                         
#Discord: @Grinern
#Twitter: @GrinernCreates
#Youtube: @GrinernCreates

invisibility := class(creative_device):

    @editable
    CardDetector: conditional_button_device = conditional_button_device{}

    OnBegin<override>()<suspends>:void=
        Print("@GrinernCreates Script Started")
        spawn:
            CheckForKeycard()

    CheckForKeycard()<suspends>:void=
        loop:
           Sleep(0.5)
           AllPlayers:=GetPlayspace().GetPlayers()
           for(Player:AllPlayers):
               if(Agent:agent = agent[Player]):
                   if(CardDetector.IsHoldingItem[Agent]):
                       Print("Hiding player")
                       HidePlayer(Agent)
                   else:
                       Print("Player is shown")
                       ShowPlayer(Agent)
    
    ShowPlayer(Agent:agent):void=
       if(FortCharacter:=Agent.GetFortCharacter[]):
        FortCharacter.Show()
    
    HidePlayer(Agent:agent):void=
       if(FortCharacter:=Agent.GetFortCharacter[]):
        FortCharacter.Hide()

# End of file: invisibility.verse


# File: C:\Users\chrisromp\dev\verse-examples\Ability Scripts\life_steal.verse
using { /Fortnite.com/Characters }
using { /Fortnite.com/UI }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Colors }
using { /Verse.org/Random }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/UI }
using { /Fortnite.com/Game }

#    _______ .______    __  .__   __.  _______ .______   .__   __.     ______ .______    _______     ___   .___________. _______     _____.
#   /  _____||   _  \  |  | |  \ |  | |   ____||   _  \  |  \ |  |    /      ||   _  \  |   ____|   /   \  |           ||   ____|   /     |
#  |  |  __  |  |_)  | |  | |   \|  | |  |__   |  |_)  | |   \|  |   |  ,----'|  |_)  | |  |__     /  ^  \ `---|  |----`|  |__     |   (--`
#  |  | |_ | |      /  |  | |  . `  | |   __|  |      /  |  . `  |   |  |     |      /  |   __|   /  /_\  \    |  |     |   __|     \   \  
#  |  |__| | |  |\  \-.|  | |  |\   | |  |____ |  |\  \-.|  |\   |   |  `----.|  |\  \-.|  |____ /  _____  \   |  |     |  |____  .--)   | 
#   \______| | _| `.__||__| |__| \__| |_______|| _| `.__||__| \__|    \______|| _| `.__||_______/__/     \__\  |__|     |_______| |_____/  
                                                                                                                                         
#Discord: @Grinern
#Twitter: @GrinernCreates
#Youtube: @GrinernCreates

life_steal := class(creative_device):

    @editable
    LifeStealClass: class_and_team_selector_device = class_and_team_selector_device{}

    OnBegin<override>()<suspends>:void=
        Print("@GrinernCreates Script Started")

        LifeStealClass.ClassSwitchedEvent.Subscribe(LifeStealEvent)

    LifeStealEvent(Agent:agent):void=
        for (Player : GetPlayspace().GetPlayers(), FortCharacter := Player.GetFortCharacter[]):
            FortCharacter.DamagedEvent().Subscribe(HealAttacker)
        GetPlayspace().PlayerAddedEvent().Subscribe(HandlePlayerJoin)

    HealAttacker( Result : damage_result) : void =
        Amount := Result.Amount
        if (Instigator := Result.Instigator?, Agent := Instigator.GetInstigatorAgent[], FortCharacter := Agent.GetFortCharacter[]):
            FortCharacter.Heal(Amount)
            Print("Healed for {Amount}")

    HandlePlayerJoin ( Player : player ) : void =
        if (FortCharacter := Player.GetFortCharacter[]):
            FortCharacter.DamagedEvent().Subscribe(HealAttacker)

# End of file: life_steal.verse


# File: C:\Users\chrisromp\dev\verse-examples\Ability Scripts\move_explosive_to_player.verse
using { /Fortnite.com/Characters }
using { /Fortnite.com/UI }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Colors }
using { /Verse.org/Random }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/UI }
using { /Fortnite.com/Game }

#    _______ .______    __  .__   __.  _______ .______   .__   __.     ______ .______    _______     ___   .___________. _______     _____.
#   /  _____||   _  \  |  | |  \ |  | |   ____||   _  \  |  \ |  |    /      ||   _  \  |   ____|   /   \  |           ||   ____|   /     |
#  |  |  __  |  |_)  | |  | |   \|  | |  |__   |  |_)  | |   \|  |   |  ,----'|  |_)  | |  |__     /  ^  \ `---|  |----`|  |__     |   (--`
#  |  | |_ | |      /  |  | |  . `  | |   __|  |      /  |  . `  |   |  |     |      /  |   __|   /  /_\  \    |  |     |   __|     \   \  
#  |  |__| | |  |\  \-.|  | |  |\   | |  |____ |  |\  \-.|  |\   |   |  `----.|  |\  \-.|  |____ /  _____  \   |  |     |  |____  .--)   | 
#   \______| | _| `.__||__| |__| \__| |_______|| _| `.__||__| \__|    \______|| _| `.__||_______/__/     \__\  |__|     |_______| |_____/  
                                                                                                                                         
#Discord: @Grinern
#Twitter: @GrinernCreates
#Youtube: @GrinernCreates

move_explosive_to_player := class(creative_device):

    @editable
    BombSignalRemoteManager: signal_remote_manager_device = signal_remote_manager_device{}

    @editable
    ExplosiveDevice: explosive_device = explosive_device{}

    OnBegin<override>()<suspends >:void=
        Print("@GrinernCreates Script Started")
        BombSignalRemoteManager.PrimarySignalEvent.Subscribe(BombEvent)
        BombSignalRemoteManager.SecondarySignalEvent.Subscribe(BombEvent)

    BombEvent(Agent:agent):void=
        spawn:
            BombActivated(Agent)

    MoveExplosive(Agent:agent)<suspends>:void=
        if (Player : fort_character = Agent.GetFortCharacter[]):
            ViewpointLoc := Player.GetViewLocation()
            ViewpointRot := Player.GetViewRotation()

            ExplosiveDevice.MoveTo(vector3(ViewpointLoc), rotation(ViewpointRot), 0.2)

    BombActivated(Agent:agent)<suspends>:void=
        MoveExplosive(Agent)
        ExplosiveDevice.Explode(Agent)
        Sleep(1.0)
        ExplosiveDevice.Reset()

# End of file: move_explosive_to_player.verse


# File: C:\Users\chrisromp\dev\verse-examples\Ability Scripts\play_cinematic.verse
using { /Fortnite.com/Characters }
using { /Fortnite.com/UI }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Colors }
using { /Verse.org/Random }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/UI }
using { /Fortnite.com/Game }

#    _______ .______    __  .__   __.  _______ .______   .__   __.     ______ .______    _______     ___   .___________. _______     _____.
#   /  _____||   _  \  |  | |  \ |  | |   ____||   _  \  |  \ |  |    /      ||   _  \  |   ____|   /   \  |           ||   ____|   /     |
#  |  |  __  |  |_)  | |  | |   \|  | |  |__   |  |_)  | |   \|  |   |  ,----'|  |_)  | |  |__     /  ^  \ `---|  |----`|  |__     |   (--`
#  |  | |_ | |      /  |  | |  . `  | |   __|  |      /  |  . `  |   |  |     |      /  |   __|   /  /_\  \    |  |     |   __|     \   \  
#  |  |__| | |  |\  \-.|  | |  |\   | |  |____ |  |\  \-.|  |\   |   |  `----.|  |\  \-.|  |____ /  _____  \   |  |     |  |____  .--)   | 
#   \______| | _| `.__||__| |__| \__| |_______|| _| `.__||__| \__|    \______|| _| `.__||_______/__/     \__\  |__|     |_______| |_____/  
                                                                                                                                         
#Discord: @Grinern
#Twitter: @GrinernCreates
#Youtube: @GrinernCreates

play_cinematic := class(creative_device):

    #Could use a input device now (might change this in the future)
    @editable
    FlashSignalRemoteManager: signal_remote_manager_device = signal_remote_manager_device{}

    @editable
    Flashbang: cinematic_sequence_device = cinematic_sequence_device{}

    OnBegin<override>()<suspends>:void=
        Print("@GrinernCreates Script Started")

        FlashSignalRemoteManager.PrimarySignalEvent.Subscribe(FlashbangEvent)

    FlashbangEvent(Agent:agent):void=
        spawn:
            FlashbangActivated(Agent)

    FlashbangActivated(Agent:agent)<suspends>:void=
    #Could be paired very good with the get_closest_player
    Flashbang.Play(Agent)

# End of file: play_cinematic.verse


# File: C:\Users\chrisromp\dev\verse-examples\Ability Scripts\play_sound.verse
using { /Fortnite.com/Characters }
using { /Fortnite.com/UI }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Colors }
using { /Verse.org/Random }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/UI }
using { /Fortnite.com/Game }

#    _______ .______    __  .__   __.  _______ .______   .__   __.     ______ .______    _______     ___   .___________. _______     _____.
#   /  _____||   _  \  |  | |  \ |  | |   ____||   _  \  |  \ |  |    /      ||   _  \  |   ____|   /   \  |           ||   ____|   /     |
#  |  |  __  |  |_)  | |  | |   \|  | |  |__   |  |_)  | |   \|  |   |  ,----'|  |_)  | |  |__     /  ^  \ `---|  |----`|  |__     |   (--`
#  |  | |_ | |      /  |  | |  . `  | |   __|  |      /  |  . `  |   |  |     |      /  |   __|   /  /_\  \    |  |     |   __|     \   \  
#  |  |__| | |  |\  \-.|  | |  |\   | |  |____ |  |\  \-.|  |\   |   |  `----.|  |\  \-.|  |____ /  _____  \   |  |     |  |____  .--)   | 
#   \______| | _| `.__||__| |__| \__| |_______|| _| `.__||__| \__|    \______|| _| `.__||_______/__/     \__\  |__|     |_______| |_____/  
                                                                                                                                         
#Discord: @Grinern
#Twitter: @GrinernCreates
#Youtube: @GrinernCreates

play_sound := class(creative_device):

    #Could use a input device now (might change this in the future)
    @editable
    SoundRemoteManager: signal_remote_manager_device = signal_remote_manager_device{}

    @editable
    SoundDevice: audio_player_device = audio_player_device{}

    OnBegin<override>()<suspends>:void=
        Print("@GrinernCreates Script Started")

        SoundRemoteManager.PrimarySignalEvent.Subscribe(SoundEvent)

    SoundEvent(Agent:agent):void=
        spawn:
            SoundActivated(Agent)
        Print("Sound Event")

    SoundActivated(Agent:agent)<suspends>:void=
        #Could be paired very good with the get_closest_player
        SoundDevice.Play(ClosestAgent)

# End of file: play_sound.verse


# File: C:\Users\chrisromp\dev\verse-examples\Ability Scripts\timed_abilities.verse
using { /Fortnite.com/Characters }
using { /Fortnite.com/UI }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Colors }
using { /Verse.org/Random }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/UI }
using { /Fortnite.com/Game }

#    _______ .______    __  .__   __.  _______ .______   .__   __.     ______ .______    _______     ___   .___________. _______     _____.
#   /  _____||   _  \  |  | |  \ |  | |   ____||   _  \  |  \ |  |    /      ||   _  \  |   ____|   /   \  |           ||   ____|   /     |
#  |  |  __  |  |_)  | |  | |   \|  | |  |__   |  |_)  | |   \|  |   |  ,----'|  |_)  | |  |__     /  ^  \ `---|  |----`|  |__     |   (--`
#  |  | |_ | |      /  |  | |  . `  | |   __|  |      /  |  . `  |   |  |     |      /  |   __|   /  /_\  \    |  |     |   __|     \   \  
#  |  |__| | |  |\  \-.|  | |  |\   | |  |____ |  |\  \-.|  |\   |   |  `----.|  |\  \-.|  |____ /  _____  \   |  |     |  |____  .--)   | 
#   \______| | _| `.__||__| |__| \__| |_______|| _| `.__||__| \__|    \______|| _| `.__||_______/__/     \__\  |__|     |_______| |_____/  
                                                                                                                                         
#Discord: @Grinern
#Twitter: @GrinernCreates
#Youtube: @GrinernCreates

timed_abilities := class(creative_device):

    @editable
    DefaultClass: class_and_team_selector_device = class_and_team_selector_device{}
    
    # I'm going to use an example in this script. However in you could implement this into mostly anything.
    # In this example we will use a "double damage" ability.

    # How this works is based on classes. So whenever a button event happens it subscribes to the ability then a timer also starts. 
    # When that timer is then done it will go back to the default class.


    OnBegin<override>()<suspends>:void=
        # Subscribe all DamageButtons to DamageActivated
        for (Button : DamageButtons):
            Button.ActivatedEvent.Subscribe(DamageActivated)

        DamageTimer.SuccessEvent.Subscribe(Default)

    Default(Agent:?agent):void=
        if (ActualAgent := Agent?):
            DefaultClass.ChangeClass(ActualAgent)

    
    # :------------ THIS IS THE PART YOU CAN "CHANGE" TO YOUR LIKEING ------------:
            
    @editable
    DamageButtons: []conditional_button_device = array{conditional_button_device{} , conditional_button_device{} ,conditional_button_device{} ,conditional_button_device{}}

    @editable
    DamageTimer: timer_device = timer_device{}

    @editable
    DamageHud: hud_message_device = hud_message_device{}

    @editable
    Damage: damage_amplifier_powerup_device = damage_amplifier_powerup_device {}

    DamageActivated(Agent:agent):void=
        Damage.Pickup(Agent)
        DamageHud.Show(Agent)
        DamageTimer.Start(Agent)

# End of file: timed_abilities.verse


# File: C:\Users\chrisromp\dev\verse-examples\Ability Scripts\underground_teleport.verse
using { /Fortnite.com/Characters }
using { /Fortnite.com/UI }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Colors }
using { /Verse.org/Random }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/UI }
using { /Fortnite.com/Game }

#    _______ .______    __  .__   __.  _______ .______   .__   __.     ______ .______    _______     ___   .___________. _______     _____.
#   /  _____||   _  \  |  | |  \ |  | |   ____||   _  \  |  \ |  |    /      ||   _  \  |   ____|   /   \  |           ||   ____|   /     |
#  |  |  __  |  |_)  | |  | |   \|  | |  |__   |  |_)  | |   \|  |   |  ,----'|  |_)  | |  |__     /  ^  \ `---|  |----`|  |__     |   (--`
#  |  | |_ | |      /  |  | |  . `  | |   __|  |      /  |  . `  |   |  |     |      /  |   __|   /  /_\  \    |  |     |   __|     \   \  
#  |  |__| | |  |\  \-.|  | |  |\   | |  |____ |  |\  \-.|  |\   |   |  `----.|  |\  \-.|  |____ /  _____  \   |  |     |  |____  .--)   | 
#   \______| | _| `.__||__| |__| \__| |_______|| _| `.__||__| \__|    \______|| _| `.__||_______/__/     \__\  |__|     |_______| |_____/  
                                                                                                                                         
#Discord: @Grinern
#Twitter: @GrinernCreates
#Youtube: @GrinernCreates

underground_teleport := class(creative_device):

    #THIS SCRIPT REQUIRES ATLEAST SOME KNOWLEDGE OF VERSE (I WILL NOT ANSWER ANY QUESTIONS REGARDING THIS ONE OTHER THAN THE COMMENTS IN HERE.)

    @editable
    TeleportClass: class_and_team_selector_device = class_and_team_selector_device{}

    @editable
    TeleportSignalRemoteManager: signal_remote_manager_device = signal_remote_manager_device{}

    @editable
    DownTeleporter: teleporter_device = teleporter_device{}

    @editable
    UpTeleporter: teleporter_device = teleporter_device{}

    @editable
    DownTrigger: trigger_device = trigger_device{}

    @editable
    UpTrigger: trigger_device = trigger_device{}

    OnBegin<override>()<suspends>:void=
        Print("@GrinernCreates Script Started")
        #This part you could in theory make it so primary teleports down and secondary teleports up but you need to tweak the script a bit for that.
        TeleportSignalRemoteManager.PrimarySignalEvent.Subscribe(TeleportDownEvent)
        TeleportSignalRemoteManager.SecondarySignalEvent.Subscribe(TeleportDownEvent)
        #This part can be changed and tweaked (You need some sort of trigger to make the teleport follow the player).
        TeleportClass.ClassSwitchedEvent.Subscribe(TeleportFollowEvent)

    TeleportDownEvent(Agent:agent):void=
        spawn:
            TeleportDownActivated(Agent)

    TeleportFollowEvent(Agent:agent):void=
        spawn:
            TeleportFollow(Agent)

    MoveTeleport(Agent:agent)<suspends>:void=
        if (Player : fort_character = Agent.GetFortCharacter[]):
            ViewpointLocX := Player.GetViewLocation().X
            ViewpointLocY := Player.GetViewLocation().Y
            ViewpointLocZ := Player.GetViewLocation().Z
            ViewpointRot := Player.GetViewRotation()

            #This basically ensure that the teleporters are at the required location. (If you want to tweak specifically what height then change the Z for both of them).
            UpTeleporter.MoveTo(vector3{X:= ViewpointLocX, Y:= ViewpointLocY, Z:= 500.00}, rotation(ViewpointRot), 0.2)
            DownTeleporter.MoveTo(vector3{X:= ViewpointLocX, Y:= ViewpointLocY, Z:= 150.00}, rotation(ViewpointRot), 0.2)

    TeleportDownActivated(Agent:agent)<suspends>:void=
        #This is the part you in theory could change to make it that you have to press each trigger once to come up and down.

        #Currently it just teleports you back up from going underground after 10 seconds.
        DownTrigger.Trigger(Agent)
        Sleep(10.0)
        UpTrigger.Trigger(Agent)
    
    TeleportFollow(Agent: agent)<suspends>:void =
        #Ensures that the teleporters always follows the player.
        loop:
            MoveTeleport(Agent)

# End of file: underground_teleport.verse


# File: C:\Users\chrisromp\dev\verse-examples\Fortnite\Fortnite.digest.verse
# Copyright Epic Games, Inc. All Rights Reserved.
#################################################
# Generated Digest of Verse API
# DO NOT modify this manually!
# Generated from build: ++Fortnite+Release-28.20-CL-31165234
#################################################

using {/Verse.org/Colors}
using {/UnrealEngine.com/Temporary/SpatialMath}
using {/Fortnite.com/Playspaces}
using {/UnrealEngine.com/Temporary/UI}
# Module import path: /Fortnite.com/UI
UI<public> := module:
    # Button with text message common base class. Displays a button with a custom message string.
    text_button_base<native><public> := class<abstract><epic_internal>(widget):
        # The text to display to the user. Used only during initialization of the widget and not modified by SetText.
        DefaultText<localizes><native><public>:message = external {}

        # Subscribable event that fires when the button is clicked.
        OnClick<public>():listenable(widget_message) = external {}

        # Sets the text displayed in the widget.
        SetText<native><public>(InText:message):void

        # Gets the text currently in the widget.
        GetText<native><public>():[]char

    # Text button with big and loud styling applied.
    button_loud<native><public> := class<final>(text_button_base):

    # Text button with normal styling applied.
    button_regular<native><public> := class<final>(text_button_base):

    # Text button with quiet styling applied.
    button_quiet<native><public> := class<final>(text_button_base):

    # Deprecated. This function affects all players. Please use `fort_playspace.GetHUDController().ShowElements()`.
    # Shows a set of HUD elements.
    (PlayerUI:player_ui).ShowHUDElements<native><public>(HUDElements:[]hud_element_identifier):void

    # Deprecated. This function affects all players. Please use `fort_playspace.GetHUDController().HideElements()`.
    # Hides a set of HUD elements.
    (PlayerUI:player_ui).HideHUDElements<native><public>(HUDElements:[]hud_element_identifier):void

    # Deprecated. This function affects all players. Please use `fort_playspace.GetHUDController().ResetElementVisibility()`.
    # Resets the visibility for a set of HUD elements.
    (PlayerUI:player_ui).ResetHUDElementVisibility<native><public>(HUDElements:[]hud_element_identifier):void

    # A HUD controller that allows for showing and hiding of HUD elements.
    fort_hud_controller<native><public> := interface:
        # Shows a set of HUD elements.
        ShowElements<public>(HUDElements:[]hud_element_identifier):void

        # Hides a set of HUD elements.
        HideElements<public>(HUDElements:[]hud_element_identifier):void

        # Resets the visibility for a set of HUD elements.
        ResetElementVisibility<public>(HUDElements:[]hud_element_identifier):void

    # Get the `fort_hud_controller` for the current `fort_playspace`.
    (Playspace:fort_playspace).GetHUDController<native><public>():fort_hud_controller

    creative_hud_identifier_all<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_build_menu<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_crafting_resources<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_elimination_counter<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_equipped_item<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_experience_level<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_experience_supercharged<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_experience_ui<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_health<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_health_numbers<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_hud_info<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_interaction_prompts<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_map_prompts<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_mimimap<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_minimap<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_pickup_stream<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_player_count<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_player_inventory<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_round_info<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_round_timer<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_shield_numbers<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_shileds<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_shields<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_storm_notifications<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_storm_timer<public> := class<final>(hud_element_identifier):

    creative_hud_identifier_team_info<public> := class<final>(hud_element_identifier):

    player_hud_identifier_all<public> := class<final>(hud_element_identifier):

    hud_identifier_world_resource_wood<public> := class<final>(hud_element_identifier):

    hud_identifier_world_resource_stone<public> := class<final>(hud_element_identifier):

    hud_identifier_world_resource_metal<public> := class<final>(hud_element_identifier):

    hud_identifier_world_resource_permanite<public> := class<final>(hud_element_identifier):

    hud_identifier_world_resource_gold_currency<public> := class<final>(hud_element_identifier):

    hud_identifier_world_resource_ingredient<public> := class<final>(hud_element_identifier):

    # Used to identify a HUD element.
    hud_element_identifier<native><public> := class<abstract><epic_internal>:

    # Slider with a text value. Displays a slider, its progress bar and value.
    slider_regular<native><public> := class<final>(widget):
        # The value to display to the user. Used only during initialization of the widget and not modified by SetValue.
        DefaultValue<native><public>:float = external {}

        # The minimum value that the slider can haver. Used only during initialization of the widget and not modified by SetMinValue.
        DefaultMinValue<native><public>:float = external {}

        # The maximum value that the slider can haver. Used only during initialization of the widget and not modified by SetMaxValue.
        DefaultMaxValue<native><public>:float = external {}

        # The amount to adjust the value by, when using a controller or keyboard. Used only during initialization of the widget and not modified by SetStepSize.
        DefaultStepSize<native><public>:float = external {}

        # Sets the value of the slider, will clamp the value to be within the sliders minimum and maximum value.
        SetValue<native><public>(InValue:float):void

        # Gets the value of the slider.
        GetValue<native><public>():float

        # Sets the minimum value of the slider, will enforce that the sliders maximum value is always larger than or equal to the minimum value.
        SetMinValue<native><public>(InMinValue:float):void

        # Gets the minimum value of the slider.
        GetMinValue<native><public>():float

        # Sets the maximum value of the slider, will enforce that the sliders maximum value is always larger than or equal to the minimum value.
        SetMaxValue<native><public>(InMaxValue:float):void

        # Gets the maximum value of the slider.
        GetMaxValue<native><public>():float

        # Sets the amount to adjust the value by, when using a controller or keyboard.
        SetStepSize<native><public>(InValue:float):void

        # Gets the amount to adjust the value by.
        GetStepSize<native><public>():float

        # Subscribable event that fires when the value of the slider has changed.
        OnValueChanged<public>():listenable(widget_message) = external {}

    # Text block widget. Displays text to the user.
    text_block<native><public> := class<final>(text_base):
        # The direction the shadow is cast. Used only during initialization of the widget and not modified by SetShadowOffset.
        DefaultShadowOffset<native><public>:?vector2 = external {}

        # The color of the shadow. Used only during initialization of the widget and not modified by SetShadowColor.
        DefaultShadowColor<native><public>:color = external {}

        # Sets the direction the shadow is cast.
        SetShadowOffset<native><public>(InShadowOffset:?vector2):void

        # Gets the direction the shadow is cast.
        GetShadowOffset<native><public>():?vector2

        # Sets the color of the shadow.
        SetShadowColor<native><public>(InColor:color):void

        # Gets the color of the shadow.
        GetShadowColor<native><public>():color

        # Sets the opacity of the shadow.
        SetShadowOpacity<native><public>(InOpacity:type {_X:float where 0.000000 <= _X, _X <= 1.000000}):void

        # Gets the opacity of the shadow.
        GetShadowOpacity<native><public>():type {_X:float where 0.000000 <= _X, _X <= 1.000000}

using {/Verse.org/Simulation}
using {/Verse.org/Assets}
using {/Verse.org/Simulation/Tags}
using {/Fortnite.com/Game}
# Module import path: /Fortnite.com/Devices
Devices<public> := module:
    # Module import path: /Fortnite.com/Devices/Animation
    Animation<public> := module:

    # Module import path: /Fortnite.com/Devices/CreativeAnimation
    CreativeAnimation<public> := module:
        # A structure for defining Bezier interpolation parameters.
        # See https://en.wikipedia.org/wiki/B%C3%A9zier_curve for more info on Bezier curves.
        cubic_bezier_parameters<native><public> := struct<computes>:
            # X value of the P1 control point. `0.0 <= X0 <= 1.0` or an error will be generated when calling `animation_controller.SetAnimation`.
            X0<native><public>:float = external {}

            # Y value of the P1 control point.
            Y0<native><public>:float = external {}

            # X value of the P2 control point. `0.0 <= X1 <= 1.0 or an error will be generated when calling `animation_controller.SetAnimation`.
            X1<native><public>:float = external {}

            # Y value of the P2 control point.
            Y1<native><public>:float = external {}

        # Module import path: /Fortnite.com/Devices/CreativeAnimation/InterpolationTypes
        # Convenience interpolation modes. These built in modes are based on the CSS animation standard: https://www.w3.org/TR/css-easing-1/
        InterpolationTypes<public> := module:
            # `Linear` animations move at a constant speed.
            Linear<public>:cubic_bezier_parameters = external {}

            # `Ease` animations start slowly, speed up, then end slowly. The speed of the animation is slightly slower at the end than the start.
            Ease<public>:cubic_bezier_parameters = external {}

            # `EaseIn` animations start slow, then speed up towards the end.
            EaseIn<public>:cubic_bezier_parameters = external {}

            # `EaseOut` animations start fast, then slow down towards the end.
            EaseOut<public>:cubic_bezier_parameters = external {}

            # `EaseInOut` animations are similar to `Ease` but the start and end animation speed is symmetric.
            EaseInOut<public>:cubic_bezier_parameters = external {}

        # Instead of specifying the actual keyframe positions, we specify the keyframe *deltas*. This allows us to treat the initial position of the prop as keyframe 0 and avoid the question of how to get the prop to its initial location. For a `animation_mode.Loop` animation, the net rotation and translation must both be zero. Each delta is interpreted as a world-space transformation to be concatenated onto the previous transform(s).
        keyframe_delta<native><public> := struct:
            # Target position of the `creative_prop`. This is a world-space coordinate in cm, with the initial position of the `creative_prop` acting as coordinate (0,0).
            DeltaLocation<native><public>:vector3

            # Target rotation for the `creative_prop`. Rotations are relative to the starting rotation of the `creative_prop`
            DeltaRotation<native><public>:rotation

            # Target scale for the `creative_prop`. Scale is multiplicative to the starting Scale of the `creative_prop`
            DeltaScale<native><public>:vector3 = external {}

            # Time in seconds the `creative_prop` should animate between its last frame and this frame.
            Time<native><public>:float

            # Interpolation mode for this `keyframe_delta`. See `InterpolationTypes` for standard interpolation options. See `cubic_bezier_parameters` for authoring custom interpolations. 
            # Default = `InterpolationTypes.Linear`
            Interpolation<native><public>:cubic_bezier_parameters = external {}

        # Animation play modes.
        animation_mode<native><public> := enum:
            # Stop after playing the animation once.
            OneShot
            # Reverse direction after reaching the final `keyframe_delta`, then play the animation in reverse.
            PingPong
            # Play the animation in a loop. This requires the animation ends exactly where it began.
            Loop

        # `animation_controller` states.
        animation_controller_state<native><public> := enum:
            # The target of the animation is not an animatable prop. This could be because:
            #  * It is not a `creative_prop` that can be animated.
            #  * It was disposed or otherwise destroyed.
            #  * It has the 'Register with Structural Grid' option set in UEFN.
            InvalidObject
            # No animation has been successfully set via `animation_controller.SetAnimation`, or that animation has been cleared by a failed call to `animation_controller.SetAnimation`.
            AnimationNotSet
            # Animation has either never started, finished, or was explicitly stopped.
            Stopped
            # Animation is playing.
            Playing
            # Animation is paused.
            Paused

        # Results for `animation_controller.AwaitNextKeyframe` function.
        await_next_keyframe_result<native><public> := enum:
            # The next keyframe has been reached successfully.
            KeyframeReached
            # No animation is currently playing and this function call has returned immediately.
            NotPlaying
            # The animation was canceled either due to the object being destroyed, becoming invalid, or because it was moved via some other API.
            AnimationAborted

        # Used to move and animate the position of `creative_prop` objects.
        #  * See `creative_prop.GetAnimationController` for information on acquiring an instance of an
        #    `animation_controller` for a given `creative_prop`.
        #  * See `SetAnimation` for details on authoring movement and animations.
        animation_controller<native><public> := class<epic_internal>:
            # Suspends at the callsite until the next `keyframe_delta` is finished. This will also return if the animation is aborted or not playing. See `await_next_keyframe_result` if your code needs to take different paths based on why `AwaitNextKeyframe` returned.
            AwaitNextKeyframe<native><public>()<suspends>:await_next_keyframe_result

            # Starts or resumes playback of the animation.
            Play<public>():void = external {}

            # Pauses the animation if it is already playing.
            Pause<public>():void = external {}

            # Stops playback and resets the animation to the first keyframe. Also resets the prop transform. Calling this method is valid while the animation is in the `Playing` or `Paused` states.
            Stop<public>():void = external {}

            # Returns the current state of this `animation_controller`.
            GetState<native><public>()<transacts>:animation_controller_state

            # Succeeds if this `animation_controller`s target is still valid (i.e., the target has not been disposed of either via `Dispose` or through any external system.)
            IsValid<native><public>()<transacts><decides>:void

            # Sets the animation for the `animation_controller`. Animations are processed in the order provided in `Keyframes`. See notes in `keyframe_delta` and `animation_mode` for more details on controlling the animations.
            SetAnimation<public>(Keyframes:[]keyframe_delta, ?Mode:animation_mode):void = external {}

            # Signaled each time a keyframe is reached. Callback(KeyframeIndex:int, InReverse:logic). Note that the KeyframeIndex in the callback is generally in [1, NumDeltaKeyframes] except that in a PingPong animation the final keyframe played in reverse is identified as index 0. This is because SetAnimation takes *delta* keyframes whereas this event notifies the listener that a specific keyframe has been reached.
            KeyframeReachedEvent<native><public>:listenable(tuple(int, logic)) = external {}

            # Signaled when the entire animation is complete. This will only fire for `OneShot` animations.
            MovementCompleteEvent<native><public>:listenable(tuple()) = external {}

            # Signaled when the state has changed. Use `GetState` to get the new state.
            StateChangedEvent<native><public>:listenable(tuple()) = external {}

        # Returns an `animation_controller` used to animate `Prop`. Only a subset of `creative_prop` types can be animated, though this may change in the future. A few examples of props that cannot be animated yet are:
        #  * Walls attached to buildings
        #  * Treasure chests
        #  * Loot llamas
        (Prop:creative_prop).GetAnimationController<public>()<transacts><decides>:animation_controller = external {}

    # Inherit from this to create a custom creative device. Inherited classes will appear in the UEFN content browser the next time Verse compiles. Instances of your derived `creative_device` can then be placed in the island by dragging them from the content browser into the scene.
    creative_device<native><public> := class<concrete>(creative_object_interface):
        # Override to add custom logic when the game experience begins.
        OnBegin<native_callable><public>()<suspends>:void = external {}

        # Override to add custom logic when the game experience ends. Any coroutines spawned inside `OnEnd` may never execute.
        OnEnd<native_callable><public>():void = external {}

        # Returns the transform of the `creative_device` with units in cm.
        GetTransform<override>()<transacts>:transform = external {}

        # Teleports the `creative_device` to the specified `Position` and `Rotation`.
        TeleportTo<public>(Position:vector3, Rotation:rotation)<transacts><decides>:void = external {}

        # Teleports the `creative_device` to the specified location defined by `Transform`, also applies rotation and scale accordingly.
        TeleportTo<public>(Transform:transform)<transacts><decides>:void = external {}

        # Moves the `creative_device` to the specified `Position` and `Rotation` over the specified time, in seconds. If an animation is currently playing on the `creative_device` it will be stopped and put into the `AnimationNotSet` state.
        MoveTo<public>(Position:vector3, Rotation:rotation, OverTime:float)<suspends>:move_to_result = external {}

        # Moves the `creative_device` to the specified `Transform` over the specified time, in seconds. If an animation is currently playing on the `creative_device` it will be stopped and put into the `AnimationNotSet` state.
        MoveTo<public>(Transform:transform, OverTime:float)<suspends>:move_to_result = external {}

        # Shows this device in the world.
        Show<native><public>()<transacts>:void

        # Hides this device in the world.
        Hide<native><public>()<transacts>:void

    # Base class for creative_device.
    creative_device_base<native><public> := class<abstract><epic_internal>(creative_object):

    # Internal asset for representing creative devices.
    creative_device_asset<native><public> := class<computes><final><epic_internal>:

    creative_object_interface<native><public> := interface<epic_internal>(positional):

    # Base class for creative devices and props.
    creative_object<native><public> := class<epic_internal>(creative_object_interface):
        # Returns the transform of the `creative_object` with units in cm. You must check `creative_object.IsValid` before calling this if there is a possibility the object has been disposed or destroyed by gameplay.
        # Otherwise a runtime error will result.
        GetTransform<override>()<transacts>:transform = external {}

        # Teleports the `creative_object` to the specified `Position` and `Rotation`.
        TeleportTo<public>(Position:vector3, Rotation:rotation)<transacts><decides>:void = external {}

        # Teleports the `creative_object` to the specified location defined by `Transform`, also applies rotation and scale accordingly.
        TeleportTo<public>(Transform:transform)<transacts><decides>:void = external {}

        # Moves the `creative_object` to the specified `Position` and `Rotation` over the specified time, in seconds. If an animation is currently playing on the `creative_object` it will be stopped and put into the `AnimationNotSet` state.
        MoveTo<public>(Position:vector3, Rotation:rotation, OverTime:float)<suspends>:move_to_result = external {}

        # Moves the `creative_object` to the specified `Transform` over the specified time, in seconds. If an animation is currently playing on the `creative_object` it will be stopped and put into the `AnimationNotSet` state.
        MoveTo<public>(Transform:transform, OverTime:float)<suspends>:move_to_result = external {}

    # Returns an array containing all creative objects which have been marked with the specified `Tag`.
    GetCreativeObjectsWithTag<native><public>(Tag:tag)<transacts>:[]creative_object_interface

    # Returns an array containing creative objects which have tag(s) matching the specified `SearchCriteria`.
    GetCreativeObjectsWithTags<native><public>(SearchCriteria:tag_search_criteria)<transacts>:[]creative_object_interface

    # Returns a queryable `tag_view` which can be used to query the tags on `CreativeObject`.
    (CreativeObject:creative_object_interface).GetTags<native><public>():tag_view

    # Returns the `fort_playspace` that `CreativeObject` belongs to.
    (CreativeObject:creative_object_interface).GetPlayspace<native><public>()<transacts>:fort_playspace

    # A Fortnite prop that has been placed or spawned in the island.
    creative_prop<native><public> := class<concrete><final>(creative_object, invalidatable):
        # Destroys the `creative_prop` and remove it from the island.
        Dispose<native><override>():void

        # Succeeds if this object has not been disposed of either via `Dispose()` or through an external system.
        IsValid<native><override>()<transacts><decides>:void

        # Changes the Mesh used by this instance.
        SetMesh<native><public>(Mesh:mesh)<transacts>:void

        # Changes the Material of the Mesh used by this instance. Optionally can specify which Mesh element index to apply the material to, otherwise defaults to the 0 (default) Mesh element
        SetMaterial<native><public>(Material:material, ?Index:int = external {})<transacts>:void

        # Shows the `creative_prop` in the world and enable collisions.
        Show<native><public>()<transacts>:void

        # Hides the `creative_prop` in the world and disable collisions.
        Hide<native><public>()<transacts>:void

    # Asset used to spawn `creative_prop` instances.
    creative_prop_asset<native><public> := class<computes><concrete><final><epic_internal>:

    # A default asset to be used when creating an editor-specified `creative_prop_asset` variable.
    DefaultCreativePropAsset<public>:creative_prop_asset = external {}

    # Results for `SpawnProp`.
    spawn_prop_result<native><public> := enum:
        # Success.
        Ok
        # An unknown error occurred. If this happens frequently, contact Epic support.
        UnknownError
        # The spawn point contains NaN or Inf.
        InvalidSpawnPoint
        # The spawn point is outside the island's boundaries.
        SpawnPointOutOfBounds
        # The asset is not a valid `creative_prop`.
        InvalidAsset
        # More props have been spawned than are permitted by the island's rules (currently 100 per script device and 200 total per island).
        TooManyProps

    # Spawns a `creative_prop` at the specified `Position` and `Rotation`. `Position` and `Rotation` units are in cm.
    # Returns tuple:
    #  0: Instance of a `creative_prop`. False if no `creative_prop` could be created. See `spawn_prop_result` for failure cases.
    #  1: Success or failure results.
    SpawnProp<native><public>(Asset:creative_prop_asset, Position:vector3, Rotation:rotation)<transacts>:tuple(?creative_prop, spawn_prop_result)

    # Spawns a `creative_prop` at the specified `Transform`. `Units are in cm.
    # Returns tuple:
    #  0: Instance of a `creative_prop`. False if no `creative_prop` could be created. See `spawn_prop_result` for failure cases.
    #  1: Success or failure results.
    SpawnProp<native><public>(Asset:creative_prop_asset, Transform:transform)<transacts>:tuple(?creative_prop, spawn_prop_result)

    # Payload of `device_event_ai_interaction`.
    device_ai_interaction_result<native><public> := struct<epic_internal>:
        # Optional agent that triggered the interaction
        Source<native><public>:?agent

        # Optional agent targeted by `Source`.
        Target<native><public>:?agent

    # Results for `MoveTo`.
    move_to_result<public> := enum:
        # The destination has been reached.
        DestinationReached
        # The destination will not be reached. See debug log in UEFN for more info.
        WillNotReachDestination

    using {/Verse.org/Simulation}
    # Used to spawn an `agent` on an island. Use multiple `player_spawner_device`s to spawn multiple `agent`s.
    player_spawner_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when an `agent` is spawned from this device.
        # Sends the `agent` that spawned.
        SpawnedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

    # Used to relay `agent` statistics to other devices and `agent`s. Can transmit statistics such as elimination count, eliminated count, or scores when certain conditions are met. Can also project a hologram of the `agent` and display text that can be altered in various positions and curvatures.
    player_reference_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when this device is activated.
        # Sends the `agent` stored in the device.
        ActivatedEvent<public>:listenable(agent) = external {}

        # Signaled when a stat tracked by this device is updated.
        # Sends the `agent` stored in the device.
        TrackedStatChangedEvent<public>:listenable(agent) = external {}

        # Signaled when the `agent` tracked by this device is updated.
        # Sends the new `agent` stored in the device.
        AgentUpdatedEvent<public>:listenable(agent) = external {}

        # Signaled when the `agent` tracked by this fails to be updated.
        # Sends the `agent` that attempted to be stored in this device.
        AgentUpdateFailsEvent<public>:listenable(agent) = external {}

        # Signaled when the `agent` tracked by this device is replaced.
        # Sends the new `agent` stored in the device.
        AgentReplacedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Ends the round/game.
        Activate<public>():void = external {}

        # Registers `Agent` as the `agent` being tracked by this device.
        Register<public>(Agent:agent):void = external {}

        # Clears the state of this device.
        Clear<public>():void = external {}

        # Is true when `Agent` is the player being referenced by the device.
        IsReferenced<public>(Agent:agent)<transacts><decides>:void = external {}

        # Returns the `agent` currently referenced by the device.
        GetAgent<public>():?agent = external {}

        # Returns the stat value that this device is currently tracking
        GetStatValue<public>():int = external {}
    Patchwork<public> := module:
        # Base class for all Patchwork devices.
        patchwork_device<public> := class<concrete>(creative_device_base):
            # Enables this device.
            Enable<public>():void = external {}

            # Disables this device.
            Disable<public>():void = external {}

        # Create drum note patterns for Patchwork devices.
        drum_sequencer_device<public> := class<concrete><final>(patchwork_device):

        # Define shared settings for Patchwork devices.
        music_manager_device<public> := class<concrete><final>(patchwork_device):

        # Apply an echo effect to Patchwork audio inputs.
        echo_effect_device<public> := class<concrete><final>(patchwork_device):

        # Modify a setting on another Patchwork device in a regularly repeating pattern.
        lfo_modulator_device<public> := class<concrete><final>(patchwork_device):

        # Turn Patchwork note inputs into audio using instrument samples.
        instrument_player_device<public> := class<concrete><final>(patchwork_device):

        # Apply a distortion effect to Patchwork audio inputs.
        distortion_effect_device<public> := class<concrete><final>(patchwork_device):

        # Modify a setting on another Patchwork device in steps over time.
        step_modulator_device<public> := class<concrete><final>(patchwork_device):

        # Turn Patchwork note inputs into audio using drum samples.
        drum_player_device<public> := class<concrete><final>(patchwork_device):

        # Modify a setting on another Patchwork device when triggered.
        value_setter_device<public> := class<concrete><final>(patchwork_device):

        # Send events to devices based on Patchwork note inputs.
        note_trigger_device<public> := class<concrete><final>(patchwork_device):

        # Turn Patchwork note inputs into audio using customizable sound synthesis.
        omega_synthesizer_device<public> := class<concrete><final>(patchwork_device):

        # Output Patchwork audio for players to hear.
        speaker_device<public> := class<concrete><final>(patchwork_device):

        # Transpose Patchwork note inputs to follow a chord progression.
        note_progressor_device<public> := class<concrete><final>(patchwork_device):

        # Create melodic note patterns for Patchwork devices.
        note_sequencer_device<public> := class<concrete><final>(patchwork_device):

    # Used to create a customizable turret that can search for nearby targets.
    automated_turret_device<public> := class<concrete><final>(creative_device_base):
        # Triggers when someone enters the activation radius while nobody else is there.
        # Sends the activating `agent`. If the activator is a non-agent then `false` is returned.
        ActivatedEvent<public>:listenable(?agent) = external {}

        # Triggers when the turret is damaged.
        # Sends the triggering `agent`. If the activator is a non-agent then `false` is returned.
        DamagedEvent<public>:listenable(?agent) = external {}

        # Triggers when the turret is destroyed.
        # Sends the triggering `agent`. If the activator is a non-agent then `false` is returned.
        DestroyedEvent<public>:listenable(?agent) = external {}

        # Triggers when the turret finds a target.
        # Sends the `agent` that was found.
        TargetFoundEvent<public>:listenable(agent) = external {}

        # Triggers when the turret loses a target.
        # Sends the `agent` that was lost.
        TargetLostEvent<public>:listenable(agent) = external {}

        # Enables the turret to rotate, target, and track.
        Enable<public>():void = external {}

        # Disables the turret, causing it to close and ignore its activation radius.
        Disable<public>():void = external {}

        # Set the turret to the Default Team.
        #  * Only usable if `Possible Targets` is not set to `Everyone`.
        UseDefaultTeam<public>():void = external {}

        # Set the turret to the Wildlife & Creatures team.
        #  * Only usable if `Possible Targets` is not set to `Everyone`.
        UseTeamWildlifeAndCreatures<public>():void = external {}

        # Set the turret to the same team as the supplied `Agent`.
        #  * Only usable if `Possible Targets` is not set to `Everyone`.
        SetTeam<public>(Agent:agent):void = external {}

        # Set the supplied `Agent` as the turret's target.
        #  * The target will only change if `Agent` is within the activation radius, has direct line-of-sight to the turret,
        # is on a targetable team as determined by `Possible Targets`, and is not Down But Not Out.
        SetTarget<public>(Agent:agent):void = external {}

    # Used to select, spawn, and configure a skeletal mesh to play a specific animation.
    animated_mesh_device<public> := class<concrete><final>(creative_device_base):
        # Starts or resumes playback of the animation.
        Play<public>():void = external {}

        # Pauses playback of the animation.
        Pause<public>():void = external {}

        # Starts or resumes reverse playback of the animation.
        PlayReverse<public>():void = external {}

    # Used to update the cameras current viewpoint and rotation based on a fixed angle.
    gameplay_camera_fixed_angle_device<public> := class<concrete><final>(gameplay_camera_device):

    # Used to update the cameras current viewpoint and rotation based on a fixed point.
    gameplay_camera_fixed_point_device<public> := class<concrete><final>(gameplay_camera_device):

    # Used to update the cameras current viewpoint and rotation based on current camera mode.
    gameplay_camera_device<public> := class<abstract><epic_internal>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Adds the camera to the `Agent`s camera stack and pushes it to be the active camera.
        AddTo<public>(Agent:agent):void = external {}

        # Adds the camera to all `Agent`s camera stacks and pushes it to be the active camera.
        AddToAll<public>():void = external {}

        # Removes the camera from the `Agent`s camera stack and pops from being the active camera replacing it with the next one in the stack.
        RemoveFrom<public>(Agent:agent):void = external {}

        # Removes the camera from all `Agent`s camera stacks and pops from being the active camera replacing it with the next one in the stack.
        RemoveFromAll<public>():void = external {}

    # Used to trigger level sequences that allow coordination of cinematic animation, transformation, and audio tracks.
    cinematic_sequence_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the sequence is stopped.
        StoppedEvent<public>:listenable(tuple()) = external {}

        # Plays the sequence. This will only work when the device is set to *Everyone*
        Play<public>():void = external {}

        # Plays the sequence. An instigating 'Agent' is required when the device is set to anything except *Everyone*.
        Play<public>(Agent:agent):void = external {}

        # Stops the sequence.
        Stop<public>():void = external {}

        # Stops the sequence. An instigating 'Agent' is required when the device is set to anything except *Everyone*.
        Stop<public>(Agent:agent):void = external {}

        # Go to the end and stop the sequence.
        GoToEndAndStop<public>():void = external {}

        # Go to the end and stop the sequence. An instigating 'Agent' is required when the device is set to anything except *Everyone*.
        GoToEndAndStop<public>(Agent:agent):void = external {}

        # Pauses the sequence.
        Pause<public>():void = external {}

        # Pauses the sequence. An instigating 'Agent' is required when the device is set to anything except *Everyone*.
        Pause<public>(Agent:agent):void = external {}

        # Toggles between `Play` and `Stop`.
        TogglePause<public>():void = external {}

        # Toggles between `Play` and `Stop`. An instigating 'Agent' is required when the device is set to anything except *Everyone*.
        TogglePause<public>(Agent:agent):void = external {}

        # Set the playback position (in frames) of the sequence.
        SetPlaybackFrame<public>(PlaybackFrame:int):void = external {}

        # Returns the playback position (in frames) of the sequence.
        GetPlaybackFrame<public>()<transacts>:int = external {}

        # Set the playback position (in time/seconds) of the sequence.
        SetPlaybackTime<public>(PlaybackTime:float):void = external {}

        # Returns the playback position (in time/seconds) of the sequence.
        GetPlaybackTime<public>()<transacts>:float = external {}

        # Set the playback rate of the sequence.
        SetPlayRate<public>(PlayRate:float):void = external {}

        # Returns the playback rate of the sequence.
        GetPlayRate<public>()<transacts>:float = external {}

    # Used to allow players to select their *Class* from a *Class Selector UI*.
    class_selector_ui_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when an `agent` selects a class.
        # Sends the `agent` that selected a class.
        ClassSelectedEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` closes the UI.
        # Sends the `agent` that closed the UI.
        UIClosedEvent<public>:listenable(agent) = external {}

        # Signaled when the UI is opened.
        # Sends the `agent` that is responsible for opening the UI.
        UIOpenedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Show the *Class Selector UI* to `Agent`.
        Show<public>(Agent:agent):void = external {}

    # Used to adapt the controls to the camera perspective
    gameplay_controls_third_person_device<public> := class<concrete><final>(gameplay_controls_device):

    # Used to update the gameplay controls scheme based on current control mode.
    gameplay_controls_device<public> := class<abstract><epic_internal>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Adds the gameplay control to the `Player`s gameplay controls stack and pushes it to be the active control.
        AddTo<public>(Agent:agent):void = external {}

        # Adds the gameplay control to all `Agent`s gameplay controls stack and pushes it to be the active control.
        AddToAll<public>():void = external {}

        # Removes the gameplay control from the `Agent`s gameplay controls stack and pops from being the active control replacing it with the next one in the stack.
        RemoveFrom<public>(Agent:agent):void = external {}

        # Removes the gameplay control from all `Agent`s gameplay controls stack and pops from being the active control replacing it with the next one in the stack.
        RemoveFromAll<public>():void = external {}

    # Used to control the behavior of the map & minimap.
    # Activation for a given `agent` can occur automatically via the device's *Activate Automatically* user option, by the `agent` entering and exiting the device's volume if using the *Activate on Trigger* user option, or via events from other devices or verse.
    # When more than one map controller is activated for a given `agent`, the one with the highest *Map Priority* user option applies.
    map_controller_device<public> := class<concrete><final>(creative_device_base):
        # Adds the map controller to the provided `Agent`'s map controller stack.
        # If multiple map controllers are active for an `agent`, the one with the highest *Map Priority* is used.
        Activate<public>(Agent:agent):void = external {}

        # Adds the map controller to all `agent`s in the experience.
        # If multiple map controllers are active for an `agent`, the one with the highest *Map Priority* is used.
        Activate<public>():void = external {}

        # Removes the map controller from the provided `Agent`'s map controller stack.
        # The next highest priority active map controller will be used, or if none exists, the default behavior will be restored.
        Deactivate<public>(Agent:agent):void = external {}

        # Removes the map controller from all `agent`s in the experience.
        # The next highest priority active map controller will be used, or if none exists, the default behavior will be restored.
        Deactivate<public>():void = external {}

        # Enables the device.
        # Enabling the device will allow it to be activated, both by incoming events, and by trigger if using *Activate on Trigger*.
        Enable<public>():void = external {}

        # Disables the device.
        # Disabling the device will deactivate it for all `agents` in the experience, turn off the trigger functionality, and prevent it from responding to events.
        Disable<public>():void = external {}

        # Sets the *Capture Box Size* (in meters).
        # *Capture Box Size* refers to the length and width of the area used for both the map capture image as well as the activation trigger.
        # Value is clamped between `25.0` and `2500.0` meters. 
        SetCaptureBoxSize<public>(Size:float):void = external {}

        # Returns the *Capture Box Size* (in meters).
        GetCaptureBoxSize<public>()<transacts>:float = external {}

    # Used to place a campfire in the world that an `agent` can use to heal themselves.
    campfire_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when an `agent` enters the area of effect for this device.
        # Sends the entering `agent`.
        AgentEntersEffectAreaEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` exits the area of effect for this device.
        # Sends the exiting `agent`.
        AgentExitsEffectAreaEvent<public>:listenable(agent) = external {}

        # Signaled when this device generates a pulse.
        CampfirePulseEvent<public>:listenable(tuple()) = external {}

        # Signaled when an `agent` is affected by a pulse generated by this device.
        # Sends the affected `agent`.
        AgentPulsedEvent<public>:listenable(agent) = external {}

        # Signaled when this device is lit by an `agent`.
        # Sends the lighting `agent`.
        LitEvent<public>:listenable(agent) = external {}

        # Signaled when this device is extinguished by an `agent`.
        # Sends the extinguishing `agent`.
        ExtinguishedEvent<public>:listenable(agent) = external {}

        # Signaled when this device is enabled.
        EnabledEvent<public>:listenable(tuple()) = external {}

        # Signaled when this device is disabled.
        DisabledEvent<public>:listenable(tuple()) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Adds wood to this device.
        AddWood<public>():void = external {}

        # Lights this device.
        Light<public>(Agent:agent):void = external {}

        # Extinguishes this device.
        Extinguish<public>(Agent:agent):void = external {}

    # Used to set up islands so players will earn Battle Pass XP when they interact with your island. Accolades are achievements or accomplishments that players can complete to earn XP.
    accolades_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when testing the accolade to make sure it is awarded as expected. Only signals within unpublished island environments.
        # Sends the `agent` receiving the achievement.
        TestAwardEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Awards the XP to `agent`.
        Award<public>(Agent:agent):void = external {}

    # Used to track `agent` events used to generate analytics.
    analytics_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Submits an event for `Agent`.
        Submit<public>(Agent:agent):void = external {}

    # Spawns a crowd to cheer you on.
    crowd_volume_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

    # Used to cause `agent`s to drop or lose items from their inventory. For example, if an `agent` is *Down But Not Out*, they could drop items from their inventory, and other `agent`s could then pick up those items.
    item_remover_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Remove items from `Agent`s inventory. The items that are removed can be configured using *Affected Items*.
        Remove<public>(Agent:agent):void = external {}

    # Used to configure a single interactive mannequin, that can visualize characters, clothing, and perform emotes.
    character_device<public> := class<concrete>(creative_device_base):
        # Signaled when an `agent` interacts with this device.
        # Sends the `agent` that interacted with this device.
        InteractedWithEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Shows this device.
        Show<public>():void = external {}

        # Hides this device.
        Hide<public>():void = external {}

        # Plays an emote on the character created by this device.
        PlayEmote<public>():void = external {}

    # Used to set an `agent`'s spawn point when activated. This can also clear the `agent`'s inventory.
    player_checkpoint_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when this device is first activated by any `agent`.
        # Sends the `agent` that activated this device.
        FirstActivationEvent<public>:listenable(agent) = external {}

        # Signaled each time a new `agent` activates this device.
        # Sends the `agent` that activated this device.
        FirstActivationPerAgentEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Registers this checkpoint for `Agent`. This sets the respawn point and can clear `Agent`'s inventory depending on this device's settings. Multiple `agent`s can be registered to this device at one time.
        Register<public>(Agent:agent):void = external {}

    # Used to trigger in game events based on real world time.
    real_time_clock_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the optional second *Duration* time has been reached.
        DurationElapsedEvent<public>:listenable(tuple()) = external {}

        # Signaled when the target time is reached.
        TimeReachedEvent<public>:listenable(tuple()) = external {}

        # Signaled when this device is enabled after the target time has been reached.
        EnablingAfterTimeReachedEvent<public>:listenable(tuple()) = external {}

        # Signaled when this device is enabled before the target time has been reached.
        EnablingBeforeTimeReachedEvent<public>:listenable(tuple()) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

    # Used to move around a building or prop, and customize responses to various collision event types.
    prop_mover_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when this device is enabled.
        EnabledEvent<public>:listenable(tuple()) = external {}

        # Signaled when this device is disabled.
        DisabledEvent<public>:listenable(tuple()) = external {}

        # Signaled when the prop movement begins.
        BeganEvent<public>:listenable(tuple()) = external {}

        # Signaled when the prop movement ends.
        EndedEvent<public>:listenable(tuple()) = external {}

        # Signaled when the prop reaches its destination.
        FinishedEvent<public>:listenable(tuple()) = external {}

        # Signaled when the prop changes its direction.
        MovementModeChangedEvent<public>:listenable(tuple()) = external {}

        # Signaled when the prop hits an `agent`.
        # Sends the `agent` hit by the prop.
        AgentHitEvent<public>:listenable(agent) = external {}

        # Signaled when the prop hits a creature, animal, or NPC.
        AIHitEvent<public>:listenable(tuple()) = external {}

        # Signaled when the prop hits another prop.
        PropHitEvent<public>:listenable(tuple()) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Moves the prop to its original position.
        Reset<public>():void = external {}

        # Begins the prop moving.
        Begin<public>():void = external {}

        # Ends the prop moving.
        End<public>():void = external {}

        # Moves the prop forward based on this device's default configuration, ignoring the prop's previous movement.
        Advance<public>():void = external {}

        # Reverses the prop's moving direction.
        Reverse<public>():void = external {}

        # Sets the total distance (in meters) that the prop will move.
        SetTargetDistance<public>(InDistance:float):void = external {}

        # Returns the total distance (in meters) that the prop will move.
        GetTargetDistance<public>()<transacts>:float = external {}

        # Sets the speed (in meters per second) at which the prop will move to its destination.
        SetTargetSpeed<public>(Speed:float):void = external {}

        # Returns the speed (in meters per second) at which the prop mover will move the prop to its destination.
        GetTargetSpeed<public>()<transacts>:float = external {}

    # Used to mark an `agent`'s position on the minimap and configure the information shown for marked `agent`s.
    # 
    # Example configuration options:
    #  * Health and shield bars for marked players.
    #  * Distance to a marked player.
    # 
    # Example marker appearance options:
    #  * Customized text label displayed on marked players.
    #  * Alternative minimap icon and icon color.
    player_marker_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the first item type monitored on marked agents has changed.
        # Sends the marked `agent`.
        FirstItemValueChangedEvent<public>:listenable(agent) = external {}

        # Signaled when the second item type monitored on marked agents has changed.
        # Sends the marked `agent`.
        SecondItemValueChangedEvent<public>:listenable(agent) = external {}

        # Signaled when a marked `agent` meets the quantity condition for the first monitored item type (e.g. Fewer Than, Equal To, More Than X).
        # Sends the marked `agent`.
        FirstItemValueReachedEvent<public>:listenable(agent) = external {}

        # Signaled when a marked `agent` meets the quantity condition for the second monitored item type (e.g. Fewer Than, Equal To, More Than X).
        # Sends the marked `agent`.
        SecondItemValueReachedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Attaches a marker to `Agent`.
        Attach<public>(Agent:agent):void = external {}

        # Detaches a marker from `Agent`.
        Detach<public>(Agent:agent):void = external {}

        # Detaches markers from all marked `agent`s.
        DetachFromAll<public>():void = external {}

    # Used to allow agents to turn other linked devices on/off or other custom state changes.
    switch_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the switch is turned on by the specified `agent`.
        # Sends the `agent` that turned on the device.
        TurnedOnEvent<public>:listenable(agent) = external {}

        # Signaled when the switch is turned off by the specified `agent`.
        # Sends the `agent` that turned off the device.
        TurnedOffEvent<public>:listenable(agent) = external {}

        # Signaled if the switch is on when the state is checked.
        IfOnWhenCheckedEvent<public>:listenable(tuple()) = external {}

        # Signaled if the switch is off when the state is checked.
        IfOffWhenCheckedEvent<public>:listenable(tuple()) = external {}

        # Signaled when the switch state is saved.
        StateSaveEvent<public>:listenable(tuple()) = external {}

        # Signaled when the switch state changes.
        StateChangesEvent<public>:listenable(tuple()) = external {}

        # Signaled when the switch state is loaded by the specified `agent`.
        # Sends the `agent` that loaded the state on the device.
        StateLoadEvent<public>:listenable(agent) = external {}

        # Signaled when the persistent data is cleared by the specified `agent`.
        # Sends the `agent` that cleared persistent data on the device.
        ClearEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Turns on this device with `Agent` acting as the instigator of the action.
        TurnOn<public>(Agent:agent):void = external {}

        # Turns off the device with `Agent` acting as the instigator of the action.
        TurnOff<public>(Agent:agent):void = external {}

        # Toggles between `TurnOn` and `TurnOff` with `Agent` acting as the instigator of the action.
        ToggleState<public>(Agent:agent):void = external {}

        # Loads the device state with `Agent` acting as the instigator of the action.
        LoadState<public>(Agent:agent):void = external {}

        # Saves the device state with `Agent` acting as the instigator of the action.
        SaveState<public>(Agent:agent):void = external {}

        # Loads the device state for all players.
        LoadStateForAll<public>():void = external {}

        # Saves the device state for all players
        SaveStateForAll<public>():void = external {}

        # Checks the device state with `Agent` acting as the instigator of the action.
        CheckState<public>(Agent:agent):void = external {}

        # Clears persistence data for `Agent`.
        ClearPersistenceData<public>(Agent:agent):void = external {}

        # Clears persistence data for all `agent`s.
        ClearAllPersistenceData<public>():void = external {}

        # Returns the current state of this switch: true (on) or false (off). Use this overload  of `GetCurrentState` when this device has *Store State Per Player* set to *Yes*.
        GetCurrentState<public>(Agent:agent)<transacts><decides>:void = external {}

        # Returns the current state of this switch: true (on) or false (off). Use this overload  of `GetCurrentState` when this device has *Store State Per Player* set to *No*.
        GetCurrentState<public>()<transacts><decides>:void = external {}

        # Query whether this device has a single global on/off state, or has a personalized on/off state for each individual agent.
        IsStatePerAgent<public>()<transacts><decides>:void = external {}

        # Sets the *Interaction Time* required to activate this device (in seconds).
        SetInteractionTime<public>(Time:float):void = external {}

        # Returns the *Interaction Time* required to activate this device (in seconds).
        GetInteractionTime<public>()<transacts>:float = external {}

        # Sets the *Turn On Text* to be displayed to a user when the switch is currently off, and offers an interaction to switch it on. Clamped to 150 characters.
        SetTurnOnInteractionText<public>(Text:message):void = external {}

        # Sets the *Turn Off Text* to be displayed to a user when the switch is currently on, and offers an interaction to switch it off. Clamped to 150 characters.
        SetTurnOffInteractionText<public>(Text:message):void = external {}

        # Sets the state of the switch to a specific value for a specific `Agent`.
        #  Use when the device has *Store State Per Player* set to *Yes*.
        SetState<public>(Agent:agent, State:logic):void = external {}

        # Sets the state of the switch to a specific value.
        #  Use when the device has *Store State Per Player* set to *No*.
        SetState<public>(State:logic):void = external {}

        # Updates the *State Reset Time* for the device, in seconds, clamped to the Min and Max defined in the device.
        #  This will not apply to any state reset timers currently in effect.
        #  Set to 0.0 to disable the State Reset Time. Set to less than 0.0 to reset to default.
        SetStateResetTime<public>(Time:float):void = external {}

        # Updates the *State Reset Time* for the device, in seconds,for a specific player (if *Store State Per Player* is *Yes*), clamped to the Min and Max defined in the device.
        #  This will not apply to any state reset timers currently in effect.
        #  Set to 0.0 to disable the State Reset Time. Set to less than 0.0 to reset to default.
        SetStateResetTime<public>(Agent:agent, Time:float):void = external {}

        # Returns the value of *State Reset Time*, in seconds, for the device. Returns -1.0 if *State Reset Time* is not used.
        GetStateResetTime<public>()<transacts>:float = external {}

        # Returns the value of *State Reset Time*, in seconds, for the device, for a specific player. Returns -1.0 if *State Reset Time* is not used.
        GetStateResetTime<public>(Agent:agent)<transacts>:float = external {}

        # Returns the time, in seconds, before the switch will reset itself to default.
        #  Returns -1.0 if *Store State Per Player* is *Yes* or if  there is no active reset timer.
        GetCurrentResetTime<public>():float = external {}

        # Returns the time, in seconds, before the switch will reset itself to default for *Agent*.
        #  Returns -1.0 if there is no active reset timer.
        GetCurrentResetTime<public>(Agent:agent):float = external {}

    # Used to track when agents enter and exit a volume.
    volume_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when an `agent` enters the device volume.
        AgentEntersEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` exits the device volume.
        AgentExitsEvent<public>:listenable(agent) = external {}

    # Used to show or hide parts of the HUD for players or teams. Use this with other devices such as the `hud_message_device`, `map_indicator_device`, and `billboard_device` to control exactly how much information players can see during a game, as well as how and when they see that information.
    hud_controller_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Sets the *Affected Class* option to `Agent`'s class.
        UpdateAffectedClass<public>(Agent:agent):void = external {}

        # Sets the *Affected Team* option to `Agent`'s team.
        UpdateAffectedTeam<public>(Agent:agent):void = external {}

        # Resets the *Affected Class* option to its starting value.
        ResetAffectedClass<public>():void = external {}

        # Resets the *Affected Team* option to its starting value.
        ResetAffectedTeam<public>():void = external {}

    # Used to place a crash pad that can bounce players and protect them from fall damage.
    crash_pad_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when an `agent` is launched by this device.
        # Sends the launched `agent`.
        LaunchedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

    # Used to add fishing mechanics to experiences, such as:
    #  * Fishing competitions between players.
    #  * Collecting fish as a resource.
    #  * Fishing minigames with their own rewards.
    fishing_zone_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when an `agent` catches a fish.
        # Sends the `agent` that caught the fish.
        CaughtEvent<public>:listenable(agent) = external {}

        # Signaled when all items have been caught and removed.
        # Sends the `agent` that caught the last fish.
        EmptyEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Resets the number of available uses for this device back to *Uses Allowed*.
        Reset<public>():void = external {}

        # Returns all caught and removed items to the inventory. This only works when *Pool Type* is set to *Device Inventory*.
        Restock<public>():void = external {}

    # Used with the `race_checkpoint_device` to create more advanced racing modes.
    race_manager_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the race begins.
        # Sends the `agent` that started the race.
        RaceBeganEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` finishes the race.
        # Sends the `agent` that finished the race.
        RaceCompletedEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` completes their first lap.
        # Sends the `agent` that finished the lap.
        FirstLapCompletedEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` completes a lap.
        # Sends the `agent` that finished the lap.
        LapCompletedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Begins the race.
        Begin<public>():void = external {}

        # Ends the race.
        End<public>():void = external {}

    # Used in tandem with `race_manager_device` to define the route players must traverse.
    race_checkpoint_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when this checkpoint becomes the next checkpoint that `agent`s need to pass for the first time.
        # Sends the first `agent` who is now targeting this checkpoint.
        CheckpointBecomesCurrentForTheFirstTimeEvent<public>:listenable(agent) = external {}

        # Signaled when this checkpoint becomes the current checkpoint for `agent`.
        # Sends the `agent` who is now targeting this checkpoint.
        CheckpointBecomesCurrentEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` passes this checkpoint.
        # Sends the `agent` that passed this checkpoint.
        CheckpointCompletedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Sets this checkpoint as the current checkpoint for `Agent`. This only functions if `Agent` has not already passed this checkpoint.
        SetAsCurrentCheckpoint<public>(Agent:agent):void = external {}

    # Used to configure rules that can end the current round or game.
    end_game_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Ends the round/game. Uses `Agent`'s team to determine if the round/game ends when *Activating Team* is enabled.
        Activate<public>(Agent:agent):void = external {}

    # Allows players to change their outfit in game!
    changing_booth_device<public> := class<concrete><final>(creative_device_base):

    # Allows the item shop to be opened when activated
    item_shop_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

    # Used to create patrolling behavior for guards spawned with the `guard_spawner_device`.
    ai_patrol_path_device<public> := class<concrete><final>(creative_device_base):
        # Assign an AI to this patrol path.
        Assign<public>(Patroller:agent):void = external {}

        # Signaled when a guard reaches this device.
        NodeReachedEvent<public>:listenable(agent) = external {}

        # Signaled when a guard cannot reach the next `ai_patrol_path_device`.
        NextNodeUnreachableEvent<public>:listenable(agent) = external {}

        # Signaled when a guard starts moving on the patrol path.
        PatrolPathStartedEvent<public>:listenable(agent) = external {}

        # Signaled when a guard stops moving on the patrol path.
        PatrolPathStoppedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Commands patroller to follow the *Next Patrol Path Group* instead of the default *Patrol Path Group*.
        GoToNextPatrolGroup<public>(Patroller:agent):void = external {}

    # Used to manage sound buses via control bus mixes set on the Audio Mixer Device.
    audio_mixer_device<public> := class<concrete><final>(creative_device_base):
        # Activates the mix set on the audio mixer.
        ActivateMix<public>():void = external {}

        # Deactivates the mix set on the audio mixer.
        DeactivateMix<public>():void = external {}

        # Adds `Agent` as a target when using the *CanBeHeardBy* Registered Players or NonRegisteredPlayers options.
        Register<public>(Agent:agent):void = external {}

        # Removes `Agent` as a target when using the *CanBeHeardBy* Registered Players or NonRegisteredPlayers options.
        Unregister<public>(Agent:agent):void = external {}

        # Removes all previously registered `agent`s when using the *CanBeHeardBy* Registered Players or NonRegisteredPlayers options.
        UnregisterAll<public>():void = external {}

    # Used to configure and play audio from the device location or from registered `agent`s.
    audio_player_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device. Allows this device to be triggered from other linked devices (i.e. triggers) and allow calls to `Play` to succeed.
        Enable<public>():void = external {}

        # Disables this device. No longer allows this device to be triggered from other linked devices (i.e. triggers) and will stop any currently playing audio.
        Disable<public>():void = external {}

        # Starts playing audio from this device for `Agent`. This can only be used when the device is set to be *Heard by Instigator*.
        Play<public>(Agent:agent):void = external {}

        # Starts playing audio from this device.
        Play<public>():void = external {}

        # Stops any audio playing from this device for `Agent`. This can only be used when the device is set to be *Heard by Instigator*.
        Stop<public>(Agent:agent):void = external {}

        # Stops any audio playing from this device.
        Stop<public>():void = external {}

        # Adds `Agent` as a target to play audio from when activated.
        Register<public>(Agent:agent):void = external {}

        # Removes `Agent` as a target to play audio from when activated.
        Unregister<public>(Agent:agent):void = external {}

        # Removes all previously registered `agent`s as valid targets to play audio from when activated.
        UnregisterAll<public>():void = external {}

        # Shows this device in the world.
        Show<public>()<transacts>:void = external {}

        # Hides this device from the world.
        Hide<public>()<transacts>:void = external {}

    # Used to send custom messages to the elimination feed.
    elimination_feed_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Activates this device. `Agent` is used as the instigator of the action.
        Activate<public>(Agent:agent):void = external {}

        # Activates this device.
        # Requires *Activated by Team / Class* be set to `All`.
        Activate<public>():void = external {}

    # Used to create a bouncer that can launch players, vehicles, and more into the air with optional effects.
    bouncer_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the condition in the *On Bounced Trigger* option is met and someone or something is launched.
        #  * Sends the `agent` that bounced. If a vehicle bounced, sends the driver. If a projectile bounced, sends its instigator.
        #  * Sends `false` if something else bounced, including a vehicle with no driver
        BouncedEvent<public>:listenable(?agent) = external {}

        # Signaled when the heal effect starts for an `agent`.
        HealStartEvent<public>:listenable(agent) = external {}

        # Signaled when the heal effect stops for an `agent`.
        HealStopEvent<public>:listenable(agent) = external {}

        # Enables bouncing on this device, as well as any visual and audio effects.
        Enable<public>():void = external {}

        # Disables bouncing on this device, as well as any visual and audio effects.
        Disable<public>():void = external {}

    # Used to trigger a custom response to a *Primary* or *Secondary* signal, sent by a *Signal Remote* item.
    signal_remote_manager_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when a player has triggered the *Primary* signal using a *Signal Remote* item.
        # Sends the `agent` that triggered the signal.
        PrimarySignalEvent<public>:listenable(agent) = external {}

        # Signaled when a player has triggered the *Secondary* signal using a *Signal Remote* item.
        # Sends the `agent` that triggered the signal.
        SecondarySignalEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

    # Used to spawn one or more waves of creatures of customizable types at selected time intervals.
    creature_spawner_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when a creature is spawned.
        # Sends the `agent` creature who was spawned.
        SpawnedEvent<public>:listenable(agent) = external {}

        # Signaled when a creature is eliminated.
        #  `Source` is the `agent` that has eliminated the creature. If the creature was eliminated by a non-agent then `Source` is 'false'.
        #  `Target` is the creature that was eliminated.
        EliminatedEvent<public>:listenable(device_ai_interaction_result) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Destroys this device.
        DestroySpawner<public>():void = external {}

        # Eliminates all creatures spawned by this device.
        EliminateCreatures<public>():void = external {}

        # Returns the spawn limit of the device.
        GetSpawnLimit<public>()<transacts>:int = external {}

    # Used to spawn a creature at a specified location.
    creature_placer_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when a creature is spawned.
        # Sends the `agent` creature who was spawned.
        SpawnedEvent<public>:listenable(agent) = external {}

        # Signaled when the creature is eliminated.
        #  * Sends the `agent` that eliminated the creature.
        #  * Sends `false` if the creature was eliminated by something other than an `agent` (e.g. a vehicle).
        EliminatedEvent<public>:listenable(?agent) = external {}

        # Spawns the creature.
        Spawn<public>():void = external {}

        # Despawns the creature.
        Despawn<public>():void = external {}

    # Used to customize one creature type at a time. Place multiple `creature_manager_device`s for each type of creature on your island.
    creature_manager_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when a creature of the selected *Creature Type* is eliminated.
        # Sends the `agent` that eliminated the creature.
        MatchingCreatureTypeEliminatedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

    # Used to spawn fireflies that can be collected by `agent`s.
    firefly_spawner_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when a firefly is collected.
        # Sends the `agent` collected the firefly.
        OnFirefliesCollected<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Spawns new fireflies. The previous fireflies will be destroyed before a new fireflies spawn.
        Respawn<public>():void = external {}

        # Resets respawn count.
        ResetRespawnCount<public>():void = external {}

    # Used to customize (or prevent) the 'down but not out' player state between 'healthy' and 'removed from game'.
    down_but_not_out_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when an `agent` is set to the `down but not out` player state.
        # Sends the `agent` that was downed.
        AgentDownedEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` in the `down but not out` player state is picked up.
        # Sends the `agent` that was picked up.
        AgentPickedUpEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` in the `down but not out` player state is dropped.
        # Sends the `agent` that was dropped.
        AgentDroppedEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` in the `down but not out` player state is thrown.
        # Sends the `agent` that was thrown.
        AgentThrownEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` in the `down but not out` player state is revived.
        # Sends the `agent` that was revived.
        AgentRevivedEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` is the aggressor of a shake down.
        # Sends the `agent` that is the aggressor.
        ShakeDownEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` is the victim of a shake down.
        # Sends the `agent` that is the victim.
        ShakenDownEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Sets the `Agent` to the `down but not out` player state.
        Down<public>(Agent:agent):void = external {}

        # Sets the `Agent` to the `healthy` player state if they are in the `down but not out` player state.
        Revive<public>(Agent:agent):void = external {}

    # Used to listen for the player activating or releasing certain inputs.
    # The input is defined by the *Input* option.
    # Players can configure the key for the input in the Creative Input Actions section of the Keyboard Settings.
    input_trigger_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        # An Input Trigger will listen for inputs from players that meet the device requirements.
        Enable<public>():void = external {}

        # Disables this device.
        # A disabled Input Trigger will not listen for inputs 
        # and will never show on the HUD.
        Disable<public>():void = external {}

        # Signaled when the tracked input is pressed by an `agent`.
        # Sends the `agent` that pressed the input.
        PressedEvent<public>:listenable(agent) = external {}

        # Signaled when the tracked input is released by an `agent`.
        # Sends the `agent` that released the input.
        # Sends the `float` duration that the input was held.
        ReleasedEvent<public>:listenable(tuple(agent, float)) = external {}

        # Adds `Agent` to the registered player list.
        # *Registered Player Behavior* determines whether registered players meet the device requirements.
        Register<public>(Agent:agent):void = external {}

        # Removes `Agent` from the registered player list.
        # *Registered Player Behavior* determines whether registered players meet the device requirements.
        Unregister<public>(Agent:agent):void = external {}

        # Clears the list of registered players.
        # *Registered Player Behavior* determines whether registered players meet the device requirements.
        UnregisterAll<public>():void = external {}

        # Succeeds if `Agent` is currently holding the input.
        IsHeld<public>(Agent:agent)<transacts><decides>:void = external {}

    # Allows pickup items to be placed in the world..
    item_placer_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

    # Used to project a hologram of a character performing dance emotes.
    dance_mannequin_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Activates the hologram using *Default Preset* options.
        ActivateDefaultPreset<public>():void = external {}

        # Activates the hologram using *Preset 2* options.
        ActivatePreset2<public>():void = external {}

        # Activates the hologram using *Preset 3* options.
        ActivatePreset3<public>():void = external {}

        # Activates the hologram using `Agent`'s skin and emotes.
        ActivateSkinAndEmoteCapture<public>(Agent:agent):void = external {}

        # Deactivates the hologram.
        DeactivateSkinAndEmoteCapture<public>():void = external {}

    # Used to manipulate the properties of one or more props in a specified area (e.g. Visibility/Destructibility).
    prop_manipulator_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when props affected by this device are damaged.
        # Sends the `agent` that damaged the prop.
        DamagedEvent<public>:listenable(agent) = external {}

        # Signaled when props affected by this device are destroyed.
        # Sends the `agent` that destroyed the prop.
        DestroyedEvent<public>:listenable(agent) = external {}

        # Signaled when prop resource nodes affected by this device are harvested.
        # Sends the `agent` that harvested resources from the prop.
        HarvestingEvent<public>:listenable(agent) = external {}

        # Signaled when prop resource nodes affected by this device are completely depleted of energy.
        # Sends the `agent` that depleted the prop's energy.
        ResourceDepletionEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Shows all props affected by this device.
        ShowProps<public>():void = external {}

        # Hides all props affected by this device.
        HideProps<public>():void = external {}

        # Empties the resources of all props affected by this device.
        ExhaustResources<public>():void = external {}

        # Restocks the resources of all props affected by this device.
        RestockResources<public>():void = external {}

        # Restores health of all props affected by this device.
        RestoreHealth<public>():void = external {}

        # Sets the *Override Resource* option to *Yes*.
        SetResourceOverridesActive<public>():void = external {}

        # Sets the *Override Resource* option to *No*.
        DisableResourceNodeOverrides<public>():void = external {}

    # Used to display curated videos onto in-game screens or player HUDs.
    video_player_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when this device becomes the controlling streaming device for the `agent`.
        StreamStartedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Enables collision checks on this device.
        EnableCollision<public>():void = external {}

        # Disables collision checks on this device.
        DisableCollision<public>():void = external {}

        # Transitions to fullscreen for `Agent`.
        EnterFullScreen<public>(Agent:agent):void = external {}

        # Transitions to fullscreen for `Agent`.
        ExitFullScreen<public>(Agent:agent):void = external {}

        # Hides the picture-in-picture video from `Agent`.
        HidePIP<public>(Agent:agent):void = external {}

        # Transitions the picture-in-picture video to the default size for `Agent`.
        MakePIPDefaultSize<public>(Agent:agent):void = external {}

        # Transitions the picture-in-picture video to full screen for `Agent`.
        MakePIPFullScreen<public>(Agent:agent):void = external {}

        # Turns off all streaming devices of this type on the island.
        EndForAll<public>():void = external {}

        # Restart the stream from the beginning.
        Restart<public>():void = external {}

        # Seeks to the *Triggered Seek Time*. Caution: The stream will pause while the video buffers when seeking.
        Seek<public>():void = external {}

        # Stops the currently playing stream and starts the custom stream with the audio only playing from this device. *Stream Priority* will not work until control is released.
        TakeControl<public>():void = external {}

        # If any streaming device has forced control of the stream, this will release it and play the highest priority stream in line.
        ReleaseControl<public>():void = external {}

    # Controls how the sky looks, as well as giving you options for changing the sun, clouds, stars or other objects in the sky above your island. You can control the sun and moon, and add other atmospheric elements like stars, fog and clouds. You can change the color of your light source, and blend different colors for your island's sky to create the perfect atmosphere for your game.
    skydome_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

    # Used to track and react to how many players are in a particular area, and optionally display that information in game.
    player_counter_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the player count matches *Target Player Count*. The frequency of evaluation against *Target Player Count* can be controlled through the device settings.
        CountSucceedsEvent<public>:listenable(tuple()) = external {}

        # Signaled when the player count does not match *Target Player Count*. The frequency of evaluation against *Target Player Count* can be controlled through the device settings.
        CountFailsEvent<public>:listenable(tuple()) = external {}

        # Signaled when a valid player enters the zone and is counted. The frequency of evaluation against the *Target Player Count* can be controlled through the device settings.
        # Sends the `agent` that is now being counted.
        CountedEvent<public>:listenable(agent) = external {}

        # Signaled when a player is no longer counted by this device, such as when they leave the zone, leave the game, or are assigned to a different `team` or class.
        # Sends the `agent` that is no longer being counted.
        RemovedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Resets *Target Player Count* to the default value defined in the device settings. If *Target Player Count* was previously incremented or decremented, this reset immediately triggers a new comparison.
        Reset<public>():void = external {}

        # Increments *Target Player Count* by `1`. Immediately triggers a new comparison.
        IncrementTargetCount<public>():void = external {}

        # Decrements *Target Player Count* by `1`. Immediately triggers a new comparison.
        DecrementTargetCount<public>():void = external {}

        # Triggers an evaluation of the current count vs *Target Player Count*, signaling `CountSucceedsEvent` or `CountFailsEvent` based on the evaluation result.
        CompareToTarget<public>():void = external {}

        # Triggers `CountedEvent` for all `agent`s currently being counted.
        TransmitForAllCounted<public>():void = external {}

        # Adds the player to the registered player list.
        # *Track Registered Players* determines how registered players are counted.
        Register<public>(Agent:agent):void = external {}

        # Removes the player from the registered player list.
        # *Track Registered Players* determines how registered players are counted.
        Unregister<public>(Agent:agent):void = external {}

        # Clears all players from the list of registered players.
        # *Track Registered Players* determines how registered players are counted.
        UnregisterAll<public>():void = external {}

        # Show this device in the world as an info panel showing Current + Required player counts.
        ShowInfoPanel<public>():void = external {}

        # Hide this device info panel from the world.
        HideInfoPanel<public>():void = external {}

        # Returns whether this device is represented in the world as an info panel showing Current + Required player counts.
        IsShowingInfoPanel<public>()<transacts><decides>:void = external {}

        # Sets the number of players required for this counter to succeed. Immediately triggers a new comparison.
        SetTargetCount<public>(Count:int):void = external {}

        # Returns the number of players required for this counter to succeed.
        GetTargetCount<public>()<transacts>:int = external {}

        # Returns the number of players currently counted by this device
        GetCount<public>()<transacts>:int = external {}

        # Is true if the device is currently succeeding in its comparison.
        IsPassingTest<public>()<transacts><decides>:void = external {}

        # Is true if `Agent` is currently counted by this device.
        IsCounted<public>(Agent:agent)<transacts><decides>:void = external {}

    # Used to create a light which can have its color and brightness manipulated in response to in-game events.
    customizable_light_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Resets the light to its initial state.
        Reset<public>():void = external {}

        # Turns on the light.
        TurnOn<public>():void = external {}

        # Turns off the light.
        TurnOff<public>():void = external {}

        # Toggles between `TurnOn` and `TurnOff`.
        Toggle<public>():void = external {}

        # Dims the light by *Dimming Amount*.
        DimLight<public>():void = external {}

        # Brightens the light by *Dimming Amount*.
        UndimLight<public>():void = external {}

    # Generates an AI bot that spawns in a location and usually attacks players when they come in range.
    sentry_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the sentry is alerted to an `agent`.
        # Sends the `agent` who alerted the sentry.
        AlertedEvent<public>:listenable(agent) = external {}

        # Signaled when the sentry exists the alert state.
        ExitsAlertEvent<public>:listenable(tuple()) = external {}

        # Signaled when the sentry enters the alert state.
        EntersAlertCooldownEvent<public>:listenable(tuple()) = external {}

        # Signaled when a sentry attacks an `agent`.
        # Sends the `agent` who is being attacked.
        AttackingEvent<public>:listenable(agent) = external {}

        # Signaled when a sentry is eliminated.
        # Sends the `agent` that eliminated the sentry. If the sentry was eliminated by a non-agent then `false` is returned.
        EliminatedEvent<public>:listenable(?agent) = external {}

        # Signaled when the sentry eliminates a creature.
        EliminatingACreatureEvent<public>:listenable(tuple()) = external {}

        # Signaled when a sentry eliminates an `agent`.
        # Sends the `agent` who was eliminated by the sentry.
        EliminatingAgentEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Spawns the sentry.
        Spawn<public>():void = external {}

        # Destroys the current sentry.
        DestroySentry<public>():void = external {}

        # Sets the sentry to the same team `Agent` is on.
        JoinTeam<public>(Agent:agent):void = external {}

        # Resets the sentry to the original team designated in the device options.
        ResetTeam<public>():void = external {}

        # Puts the sentry into the pacify state, preventing from entering the alert (attacking) state.
        Pacify<public>():void = external {}

        # Puts the sentry into the alert state.
        EnableAlert<public>():void = external {}

        # Sets the sentry to target `Agent`. The sentry will not target agents on the same team as the sentry.
        Target<public>(Agent:agent):void = external {}

        # Resets the alert state.
        ResetAlertCooldown<public>():void = external {}

    # Used to spawn and configure an aerial supply drop that can provide players with customized weapons/supplies.
    supply_drop_spawner_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the balloon on the supply crate is popped.
        # Sends the `?agent` that popped the balloon. If no `agent` popped the balloon returns `false`.
        BalloonPoppedEvent<public>:listenable(?agent) = external {}

        # Signaled when the supply crate is opened.
        # Sends the `agent` that opened the crate.
        OpenedEvent<public>:listenable(agent) = external {}

        # Signaled when the supply crate lands for the first time.
        LandingEvent<public>:listenable(tuple()) = external {}

        # Spawns a supply drop provided one hasn't already spawned. *Owning Team* is set to `Agent`'s team.
        Spawn<public>(Agent:agent):void = external {}

        # Spawns a supply drop provided one hasn't already spawned.
        Spawn<public>():void = external {}

        # Destroys the balloon and causes the supply crate to freefall.
        DestroyBalloon<public>():void = external {}

        # Opens the supply crate, ignoring the locked or unlocked state. `Agent` acts as the instigator of the open action.
        Open<public>(Agent:agent):void = external {}

        # Locks the supply crate so `agent`s cannot open it.
        Lock<public>():void = external {}

        # Unlocks the supply crate so `agent`s can open it.
        Unlock<public>():void = external {}

    # Used to create and customize your own visual effects. This is more flexible than the `vfx_spawner_device`, which gives you a selection of pre-made visual effects to choose from but limits how much you can customize or change those effects.
    vfx_creator_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Toggles between `Enable` and `Disable`.
        ToggleEnabled<public>():void = external {}

        # Starts playing the effect.
        Begin<public>():void = external {}

        # Starts the effect at `Agent`'s location. This option is only valid if *Stick to Player* is enabled.
        Begin<public>(Agent:agent):void = external {}

        # Starts the effect at every `agent`'s location. This option is only valid if *Stick to Player* is enabled.
        BeginForAll<public>():void = external {}

        # Ends playing the effect.
        End<public>():void = external {}

        # Ends the effect at `Agent`'s location. This option is only valid if *Stick to Player* is enabled.
        End<public>(Agent:agent):void = external {}

        # Ends the effect at every `agent`'s locations. This option is only valid if *Stick to Player* is enabled.
        EndForAll<public>():void = external {}

        # Toggles between `Begin` and `End`.
        Toggle<public>():void = external {}

        # Toggles between `Begin` and `End`.
        Toggle<public>(Agent:agent):void = external {}

        # Toggles between `BeginForAll` and `EndForAll`.
        ToggleForAll<public>():void = external {}

        # Pauses the effect if the effect is running. If the effect is paused, unpauses the effect. Pausing an effect causes the effect to freeze in place.
        TogglePause<public>():void = external {}

        # Pauses the effect at `Agent`'s locations if it is playing, or resumes the effect if it is paused.
        # When paused the effect freezes in place.
        TogglePause<public>(Agent:agent):void = external {}

        # Pauses the effect at every `agent`'s locations if it is playing, or resumes the effect if it is paused.
        # When paused the effect freezes in place.
        TogglePauseForAll<public>():void = external {}

        # Removes the effect from `Agent` and continues playing at the device location. This option is only valid if *Stick to Player* is enabled.
        Remove<public>(Agent:agent):void = external {}

        # Removes the effect for every `agent` and continues playing at the device location. This option is only valid if *Stick to Player* is enabled.
        RemoveFromAll<public>():void = external {}

        # Spawns the effect at `Agent`'s location. This option is only valid if *Stick to Player* is enabled.
        SpawnAt<public>(Agent:agent):void = external {}

    # Used to place visual effects around your island. You can use these effects to enhance the overall theme and experience of your game.
    vfx_spawner_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the effect is enabled.
        EffectEnabledEvent<public>:listenable(tuple()) = external {}

        # Signaled when the effect is disabled.
        EffectDisabledEvent<public>:listenable(tuple()) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

    # Used to create and manipulate volumes of water where players can swim, fish, or drive boats.
    water_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when an `agent` enters the water.
        # Sends `agent` that entered the water.
        AgentEntersWaterEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` exits the water.
        # Sends `agent` that exited the water.
        AgentExitsWaterEvent<public>:listenable(agent) = external {}

        # Signals when the volume is filled to the water level set in the *Default Vertical Water Percentage* option.
        VerticalFillingCompletedEvent<public>:listenable(tuple()) = external {}

        # Signals when the water volume is completely empty.
        VerticalEmptyingCompletedEvent<public>:listenable(tuple()) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Resets the water level in the volume to the value set in the *Default Vertical Water Percentage* option.
        Reset<public>():void = external {}

        # Starts vertically emptying the water in the volume.
        BeginVerticalEmptying<public>():void = external {}

        # Starts vertically filling the water in the volume.
        BeginVerticalFilling<public>():void = external {}

        # Stops filling or emptying the volume.
        StopVerticalMovement<public>():void = external {}

        # Resumes either filling or emptying the volume.
        ResumeVerticalMovement<public>():void = external {}

    # Used to create a zone where players are put into a skydive state. Can customize the amount of force used to push the player, and how fast players are launched into the air. The direction of the push is in relation to the device, so you can rotate and overlap several devices, then use variable speeds to create pneumatic tubes that propel players in different directions. You can even create unique traversal (traveling) options, where players can use these zones to reach places on your island they couldn't reach any other way.
    skydive_volume_device<public> := class<concrete><final>(effect_volume_device):
        # Signaled when an `agent` enters the volume.
        # Sends the `agent` that entered the volume.
        AgentEntersEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` exits the volume.
        # Sends the `agent` that exited the volume.
        AgentExitsEvent<public>:listenable(agent) = external {}

        # Signaled when the zone changes from empty to occupied.
        # Sends the `agent` that entered the volume.
        ZoneOccupiedEvent<public>:listenable(agent) = external {}

        # Signaled when the zone changes from occupied to empty.
        # Sends the `agent` that last left the volume.
        ZoneEmptiedEvent<public>:listenable(agent) = external {}

        # Enables volume locking which prevents users from leaving the volume once they've entered.
        EnableVolumeLocking<public>():void = external {}

        # Disables volume locking which prevents users from leaving the volume once they've entered.
        DisableVolumeLocking<public>():void = external {}

        # Is true when `Agent` is in the volume.
        IsInVolume<public>(Agent:agent)<transacts><decides>:void = external {}

    # Used to specify a zone where custom gameplay effects can be applied (e.g. gravity, no build, no weapons).
    mutator_zone_device<public> := class<concrete><final>(effect_volume_device):
        # Signaled when an `agent` in this zone begins emoting. This will not signal if the `agent` is on the *Safe Team* or if *Affects Players* is disabled.
        # Sends the `agent` that started emoting.
        AgentBeginsEmotingEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` in this zone ends emoting. This will not signal if the `agent` is on the *Safe Team* or if *Affects Players* is disabled.
        # Sends the `agent` that stopped emoting.
        AgentEndsEmotingEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` enters this zone.
        # Sends the `agent` entering this zone.
        AgentEntersEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` exits this zone.
        # Sends the `agent` exiting this zone.
        AgentExitsEvent<public>:listenable(agent) = external {}

        # Updates *Selected Class* to `Agent`'s class.
        UpdateSelectedClass<public>(Agent:agent):void = external {}

        # Updates *Selected Team* to `Agent`'s team.
        UpdateSelectedTeam<public>(Agent:agent):void = external {}

        # Is true when `Agent` is in the zone.
        IsInVolume<public>(Agent:agent)<transacts><decides>:void = external {}

    # Used to specify an area which allows (or prevents) various objects, terrain, or buildings from being set on fire.
    fire_volume_device<public> := class<concrete><final>(effect_volume_device):
        # Extinguishes objects inside this device area.
        Extinguish<public>():void = external {}

        # Ignites objects inside this device area.
        Ignite<public>():void = external {}

    # Base class for types of volumes with special gameplay properties.
    effect_volume_device<public> := class<abstract><epic_internal>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

    # Used to specify an area volume which can damage `agent`s, vehicles, and creatures.
    damage_volume_device<public> := class<concrete><final>(effect_volume_device):
        # Signaled when an `agent` enters the volume.
        # Sends the `agent` entering the volume.
        AgentEntersEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` exits the volume.
        # Sends the `agent` exiting the volume.
        AgentExitsEvent<public>:listenable(agent) = external {}

        # Updates *Selected Class* to `Agent`'s class.
        UpdateSelectedClass<public>(Agent:agent):void = external {}

        # Updates *Selected Team* to `Agent`'s team.
        UpdateSelectedTeam<public>(Agent:agent):void = external {}

        # Sets the damage to be applied each tick within the volume. `Damage` is clamped between `1` and `500`.
        SetDamage<public>(Damage:int):void = external {}

        # Returns the damage to be applied each tick within the volume.
        GetDamage<public>()<transacts>:int = external {}

        # Is true when `Agent` is in the zone.
        IsInVolume<public>(Agent:agent)<transacts><decides>:void = external {}

    # Creates an impenetrable zone that can block `agent` movement and weapon fire.
    barrier_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Adds the specified `agent` to a list of additional `agent`s that the Barrier should ignore. This list is in addition to the Ignore Team and Ignore Class options. Note: Has no effect on bullets.
        AddToIgnoreList<public>(Agent:agent):void = external {}

        # Removes the specified `agent` from the ignore list. The `agent` will still be ignored if they are on an ignored team or of an ignored class.
        RemoveFromIgnoreList<public>(Agent:agent):void = external {}

        # Removes all `agent`s from the ignore list. `Agent`s will still be ignored if they are on an ignored team or of an ignored class.
        RemoveAllFromIgnoreList<public>():void = external {}

    using {/UnrealEngine.com/Temporary/SpatialMath}
    # Used to trigger a visual effect (a glow or an outline) when `agent`s pick it up.
    visual_effect_powerup_device<public> := class<concrete><final>(powerup_device):

    # Holds and spawns items, with an optional cost for each item. Can hold up to three items, and `agent`s can cycle between these by hitting the machine with their pickaxe.
    vending_machine_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when an item is spawned from this device.
        # Sends the `agent` that used this device.
        ItemSpawnedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Cycles the screen to show the next item.
        CycleToNextItem<public>():void = external {}

        # Spawns an item.
        SpawnItem<public>():void = external {}

    # Used to relay events to other linked devices.
    trigger_device<public> := class<concrete><final>(trigger_base_device):
        # Signaled when an `agent` triggers this device.
        # Sends the `agent` that used this device. Returns `false` if no `agent` triggered the action (ex: it was triggered through code).
        TriggeredEvent<public>:listenable(?agent) = external {}

        # Triggers this device with `Agent` being passed as the `agent` that triggered the action. Use an `agent` reference when this device is setup to require one (for instance, you want to trigger the device only with a particular `agent`.
        Trigger<public>(Agent:agent):void = external {}

        # Triggers this device, causing it to activate its `TriggeredEvent` event.
        Trigger<public>():void = external {}

    # Base class for various specialized trigger devices. See also: * `trigger_device` * `perception_trigger_device` * `attribute_evaluator_device`
    trigger_base_device<public> := class<abstract><epic_internal>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Resets the number of times this device has been activated. This will set `GetTriggerCountRemaining` back to `0`
        Reset<public>():void = external {}

        # Sets the maximum amount of times this device can trigger.
        #  * `0` can be used to indicate no limit on trigger count.
        #  * `MaxCount` is clamped between [0,20].
        SetMaxTriggerCount<public>(MaxCount:int):void = external {}

        # Gets the maximum amount of times this device can trigger.
        #  * `0` indicates no limit on trigger count.
        GetMaxTriggerCount<public>()<transacts>:int = external {}

        # Returns the number of times that this device can still be triggered before hitting `GetMaxTriggerCount`.
        # Returns `0` if `GetMaxTriggerCount` is unlimited.
        GetTriggerCountRemaining<public>()<transacts>:int = external {}

        # Sets the time (in seconds) after triggering, before the device can be triggered again (if `MaxTrigger` count allows).
        SetResetDelay<public>(Time:float):void = external {}

        # Gets the time (in seconds) before the device can be triggered again (if `MaxTrigger` count allows).
        GetResetDelay<public>()<transacts>:float = external {}

        # Sets the time (in seconds) which must pass after triggering, before this device informs other external devices that it has been triggered.
        SetTransmitDelay<public>(Time:float):void = external {}

        # Gets the time (in seconds) which must pass after triggering, before this device informs other external devices that it has been triggered.
        GetTransmitDelay<public>()<transacts>:float = external {}

    # A trap device that destroys the tile it's placed on when activated.
    trick_tile_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the tile this device is attached to is removed. This may occur later than `TriggeredEvent` if *Activation Delay* is set on the device.
        # Sends the `agent` that activated this device.
        ActivatedEvent<public>:listenable(agent) = external {}

        # Signaled when this device is triggered.
        # Sends the `agent` that triggered this device.
        TriggeredEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device. While disabled this device will not react to incoming events.
        Disable<public>():void = external {}

        # Flips the device between `Enabled` and `Disable`.
        ToggleEnabled<public>():void = external {}

        # Restores the tile removed when this device was triggered.
        Reset<public>():void = external {}

        # Enables this device to trigger when an `agent` makes contact with the device.
        EnableAgentContactTrigger<public>():void = external {}

        # Disables this device from triggering when an `agent` makes contact with the device.
        DisableAgentContactTrigger<public>():void = external {}

        # Flips the device between `EnableAgentContactTrigger` and `DisableAgentContactTrigger.
        ToggleAgentContactTrigger<public>():void = external {}

        # Triggers the device, removing the associated tile.
        Trigger<public>():void = external {}

        # Teleports the `trick_tile_device` to the specified `Position` and `Rotation`. 
        # Only the trigger will teleport, the target buildings will not change. 
        TeleportTo<override>(Position:vector3, Rotation:rotation)<transacts><decides>:void = external {}

        # Teleports the `trick_tile_device` to the specified location defined by `Transform`, also applies rotation and scale accordingly. 
        # Only the trigger will teleport, the target buildings will not change. 
        TeleportTo<override>(Transform:transform)<transacts><decides>:void = external {}

        # Moves the `trick_tile_device` to the specified `Position` and `Rotation` over the specified time, in seconds. 
        # Only the trigger will move, the target buildings will not change. 
        MoveTo<override>(Position:vector3, Rotation:rotation, OverTime:float)<suspends>:move_to_result = external {}

        # Moves the `trick_tile_device` to the specified `Transform` over the specified time, in seconds. 
        # Only the trigger will move, the target buildings will not change. 
        MoveTo<override>(Transform:transform, OverTime:float)<suspends>:move_to_result = external {}

    # Allows creation and HUD tracking of custom objectives for `agent`s to complete.
    tracker_device<public> := class<concrete><final>(creative_device_base):
        # Resets the progress for `Agent` (and any `agent`s sharing progress).
        Reset<public>(Agent:agent):void = external {}

        # Signaled when the tracked value reaches `GetTarget` for an `agent`.
        # Sends the `agent` that reached `GetTarget` for their tracked value.
        CompleteEvent<public>:listenable(agent) = external {}

        # Assigns the device to `Agent` (and any `agent`s sharing progress).
        Assign<public>(Agent:agent):void = external {}

        # Assigns this device to all valid `agent`s.
        AssignToAll<public>():void = external {}

        # Removes this device from `Agent` (and any `agent`s sharing progress).
        Remove<public>(Agent:agent):void = external {}

        # Removes this device from all valid `agent`s.
        RemoveFromAll<public>():void = external {}

        # The objective immediately completes.
        Complete<public>(Agent:agent):void = external {}

        # Increases the tracked value by *Amount to Change on Received Signal* for `Agent`.
        Increment<public>(Agent:agent):void = external {}

        # Decrease the tracked value by *Amount to Change on Received Signal* for `Agent`.
        Decrement<public>(Agent:agent):void = external {}

        # Increases the target value for `Agent` by 1.
        IncreaseTargetValue<public>(Agent:agent):void = external {}

        # Decreases the target value for `Agent` by 1.
        DecreaseTargetValue<public>(Agent:agent):void = external {}

        # Saves tracked progress for `Agent`. Only valid if *Use Persistence* is set to *Use*.
        Save<public>(Agent:agent):void = external {}

        # Loads tracked progress for `Agent`. Only valid if *Use Persistence* is set to *Use*.
        Load<public>(Agent:agent):void = external {}

        # Loads tracked progress for all valid `agent`s. Only valid if *Use Persistence* is set to *Use*.
        LoadForAll<public>():void = external {}

        # Clears tracked progress for `Agent`. Only valid if *Use Persistence* is set to *Use*.
        ClearPersistence<public>(Agent:agent):void = external {}

        # Sets a description for the `tracker_device`, which is displayed if *Show on HUD* is enabled.
        # `Text` has a 64 character limit.
        SetDescriptionText<public>(Text:message):void = external {}

        # Sets the target value that must be achieved in order for `CompleteEvent` to trigger.
        # Clamped to `0 <= TargetValue <= 10000`.
        SetTarget<public>(TargetValue:int):void = external {}

        # Returns the target value that must be achieved in order for `CompleteEvent` to trigger.
        # Clamped to `0 <= GetTarget <= 10000`.
        GetTarget<public>()<transacts>:int = external {}

        # Sets the current tracked value for the device for all active players.
        SetValue<public>(Value:int):void = external {}

        # Sets the current tracked value for the device for the Team at the `TeamIndex`.
        # If *Sharing* is set to *Individual*, this will set the value for all team members.
        # If *Sharing* is set to *All*, this will set the value for all players.
        SetValue<public>(TeamIndex:int, Value:int):void = external {}

        # Sets the current tracked value for the device for a specific 'Agent'.
        # If *Sharing* is set to *Team*, this will set the value for their team.
        # If *Sharing* is set to *All*, this will set the value for everyone.
        SetValue<public>(Agent:agent, Value:int):void = external {}

        # Returns the current total tracked value for all players.
        GetValue<public>()<transacts>:int = external {}

        # Returns the current total tracked value for the team at `TeamIndex`.
        GetValue<public>(TeamIndex:int)<transacts>:int = external {}

        # Returns the current tracked value for `Agent`.
        GetValue<public>(Agent:agent)<transacts>:int = external {}

        # Sets the title for the `tracker_device`, which is displayed if *Show on HUD* is enabled.
        # `Text` has a 32 character limit.
        SetTitleText<public>(Text:message):void = external {}

        # Is true if `Agent` currently has the quest active.
        IsActive<public>(Agent:agent)<transacts><decides>:void = external {}

        # Is true if `Agent` has reached the *TargetValue* for the tracker.
        HasReachedTarget<public>(Agent:agent)<transacts><decides>:void = external {}

    # Provides a way to keep track of the time something has taken, either for scoreboard purposes, or to trigger actions. It can be configured in several ways, either acting as a countdown to an event that is triggered at the end, or as a stopwatch for an action that needs to be completed before a set time runs out.
    timer_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the timer completes or ends with success.
        # Sends the `agent` that activated the timer, if any.
        SuccessEvent<public>:listenable(?agent) = external {}

        # Signaled when the timer completes or ends with failure.
        # Sends the `agent` that activated the timer, if any.
        FailureEvent<public>:listenable(?agent) = external {}

        # Signaled when the timer enters *Urgency Mode*.
        # Sends the `agent` that activated the timer, if any.
        StartUrgencyModeEvent<public>:listenable(?agent) = external {}

        # Enables this device for `Agent`.
        Enable<public>(Agent:agent):void = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device for `Agent`. While disabled this device will not receive signals.
        Disable<public>(Agent:agent):void = external {}

        # Disables this device. While disabled this device will not receive signals.
        Disable<public>():void = external {}

        # Resets the timer back to its base time and stops it for `Agent`.
        Reset<public>(Agent:agent):void = external {}

        # Resets the timer back to its base time and stops it.
        Reset<public>():void = external {}

        # Resets the timer back to its base time and stops it for all `agent`s.
        ResetForAll<public>(Agent:agent):void = external {}

        # Resets the timer back to its base time and stops it for all `agent`s.
        ResetForAll<public>():void = external {}

        # Starts the timer for `Agent`.
        Start<public>(Agent:agent):void = external {}

        # Starts the timer.
        Start<public>():void = external {}

        # Pauses the timer for `Agent`.
        Pause<public>(Agent:agent):void = external {}

        # Pauses the timer.
        Pause<public>():void = external {}

        # Resumes the timer for `Agent`.
        Resume<public>(Agent:agent):void = external {}

        # Resumes the timer.
        Resume<public>():void = external {}

        # Completes the timer for `Agent`.
        Complete<public>(Agent:agent):void = external {}

        # Completes the timer.
        Complete<public>():void = external {}

        # Starts the timer for all `agent`s.
        StartForAll<public>(Agent:agent):void = external {}

        # Starts the timer for all `agent`s.
        StartForAll<public>():void = external {}

        # Pauses the timer for all `agent`s.
        PauseForAll<public>(Agent:agent):void = external {}

        # Pauses the timer for all `agent`s.
        PauseForAll<public>():void = external {}

        # Resumes the timer for all `agent`s.
        ResumeForAll<public>(Agent:agent):void = external {}

        # Resumes the timer for all `agent`s.
        ResumeForAll<public>():void = external {}

        # Completes the timer for all `agent`s.
        CompleteForAll<public>(Agent:agent):void = external {}

        # Completes the timer for all `agent`s.
        CompleteForAll<public>():void = external {}

        # Saves this device's data for `Agent`.
        Save<public>(Agent:agent):void = external {}

        # Loads this device's saved data for `Agent`.
        Load<public>(Agent:agent):void = external {}

        # Clears this device's saved data for `Agent`.
        ClearPersistenceData<public>(Agent:agent):void = external {}

        # Clears this device's saved data for all `agent`s.
        ClearPersistenceDataForAll<public>(Agent:agent):void = external {}

        # Clears this device's saved data for all `agent`s.
        ClearPersistenceDataForAll<public>():void = external {}

        # Sets the remaining time (in seconds) on the timer, if active, on `Agent`.
        SetActiveDuration<public>(Time:float, Agent:agent):void = external {}

        # Sets the remaining time (in seconds) on the timer, if active. Use this function if the timer is set to use the same time for all `agent`'s.
        SetActiveDuration<public>(Time:float):void = external {}

        # Returns the remaining time (in seconds) on the timer for `Agent`.
        GetActiveDuration<public>(Agent:agent)<transacts>:float = external {}

        # Returns the remaining time (in seconds) on the timer if it is set to be global.
        GetActiveDuration<public>()<transacts>:float = external {}

        # Sets the lap time indicator for `Agent`.
        SetLapTime<public>(Agent:agent):void = external {}

        # Sets the lap time indicator for all `agent`s.
        SetLapTimeForAll<public>(Agent:agent):void = external {}

        # Sets the lap time indicator for all `agent`s.
        SetLapTimeForAll<public>():void = external {}

        # Sets the maximum duration of the timer (in seconds).
        SetMaxDuration<public>(Time:float):void = external {}

        # Returns the maximum duration of the timer (in seconds).
        GetMaxDuration<public>()<transacts>:float = external {}

        # Succeeds if this device is tracking timer state for each individual `agent` independently. Fails if state is being tracked globally for all `agent`'s.
        IsStatePerAgent<public>()<transacts><decides>:void = external {}

    # Configures game modes where players can start or stop timers to advance gameplay objectives, such as Attack/Defend Bomb objectives.
    timed_objective_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the objective begins.
        # Sends the `agent` that started the timer.
        BeganEvent<public>:listenable(agent) = external {}

        # Signaled when the objective ends.
        # Sends the `agent` that stopped the timer.
        EndedEvent<public>:listenable(agent) = external {}

        # Signaled when the objective is paused.
        # Sends the `agent` that paused the timer.
        PausedEvent<public>:listenable(agent) = external {}

        # Signaled when the objective is resumed.
        # Sends the `agent` that resumed the timer.
        ResumedEvent<public>:listenable(agent) = external {}

        # Signaled when the objective is restarted.
        # Sends the `agent` that restarted the timer.
        RestartedEvent<public>:listenable(agent) = external {}

        # Signaled when the objective is completed.
        # Sends the `agent` that started the timer or completed the timer by calling `Complete`.
        CompletedEvent<public>:listenable(agent) = external {}

        # Enables the objective for `Agent`.
        Enable<public>(Agent:agent):void = external {}

        # Disables the objective for `Agent`.
        Disable<public>(Agent:agent):void = external {}

        # Makes this device visible.
        Show<public>():void = external {}

        # Makes this device invisible.
        Hide<public>():void = external {}

        # Starts the objective with `Agent` acting as the user the interacted this device.
        Begin<public>(Agent:agent):void = external {}

        # Ends the objective with `Agent` acting as the user the interacted this device.
        End<public>(Agent:agent):void = external {}

        # Pauses the objective with `Agent` acting as the user the interacted this device.
        Pause<public>(Agent:agent):void = external {}

        # Resumes the objective with `Agent` acting as the user the interacted this device.
        Resume<public>(Agent:agent):void = external {}

        # Restarts the objective with `Agent` acting as the user the interacted this device.
        Restart<public>(Agent:agent):void = external {}

        # Completes the objective with `Agent` acting as the user the interacted this device.
        Complete<public>(Agent:agent):void = external {}

    # Customizable rift that allows `agent`s to move instantly between locations. You can use this to move players around your island, or create multi-island experiences with teleporters that take players from one island to another.
    teleporter_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when an `agent` enters this device.
        # Sends the `agent` that entered this device.
        EnterEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` emerges from this device.
        # Sends the `agent` that emerged from this device.
        TeleportedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Teleport `Agent` to the target group using this device.
        Activate<public>(Agent:agent):void = external {}

        # When a link is activated, the current destination teleporter will be able to bring the `agent` back to this origin teleporter. Both origin and destination teleporters need to have this activated to work as expected.
        ActivateLinkToTarget<public>():void = external {}

        # Deactivates any currently active Link. The current destination teleporter will no longer be able to return the agent to this origin teleporter.
        DeactivateLinkToTarget<public>():void = external {}

        # Resets the currently selected destination teleporter, and selects an eligible destination. If the target is a *Teleporter Group*, this may be another randomly chosen `teleporter_device` from that group.
        ResetLinkToTarget<public>():void = external {}

        # Teleport `Agent` to this device.
        Teleport<public>(Agent:agent):void = external {}

    # Provides team and inventory configurations that go beyond the choices the My Island settings provide.
    # Can also be used to customize individual devices and create variations in team setup.
    team_settings_and_inventory_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when an enemy of *Team* is eliminated by a team member.
        # Sends the `agent` team member who eliminated the enemy.
        EnemyEliminatedEvent<public>:listenable(agent) = external {}

        # Signaled when a member of *Team* is eliminated.
        # Sends the `agent` that was eliminated.
        TeamMemberEliminatedEvent<public>:listenable(agent) = external {}

        # Signaled when a member of *Team* is spawned.Sends the `agent` that has spawned.
        TeamMemberSpawnedEvent<public>:listenable(agent) = external {}

        # Signaled when *Team* runs out of respawns.
        TeamOutOfRespawnsEvent<public>:listenable(tuple()) = external {}

        # Ends the round and *Team* wins the round.
        EndRound<public>():void = external {}

        # Is true if `Agent` is on *Team*.
        IsOnTeam<public>(Agent:agent)<transacts><decides>:void = external {}

    # Used to place the Infinity Blade on your island. When placed, the Infinity Blade becomes available to any player regardless of team affiliation.
    sword_in_the_stone_device<public> := class<concrete><final>(creative_device_base):

    # DEPRECATED This device is no longer supported.Used to inform players of other content made by a creator using a Support-A-Creator code. When players activate the device, it will bring up the same Support-A-Creator dialog box they would see in the Creative hub. The Support-A-Creator information shows when the dialog box opens for the player.
    support_a_creator_device<public> := class<concrete><final>(creative_device_base):

    # Base class for various specialized storm devices. See also: * `basic_storm_controller_device` * `advanced_storm_controller_device`
    storm_controller_device<public> := class<abstract><epic_internal>(creative_device_base):
        # Signaled when storm resizing ends. Use this with the *On Finish Behavior* option for better controls.
        PhaseEndedEvent<public>:listenable(tuple()) = external {}

        # Generates the storm. *Generate Storm On Game Start* must be set to *No* if you choose to use `GenerateStorm`.
        GenerateStorm<public>():void = external {}

        # Destroys the storm.
        DestroyStorm<public>():void = external {}

        # Teleports the `storm_controller_device` to the specified `Position` and `Rotation`. 
        # Existing storms will not target the new location, but newly generated storms will.
        TeleportTo<override>(Position:vector3, Rotation:rotation)<transacts><decides>:void = external {}

        # Teleports the `storm_controller_device` to the specified location defined by `Transform`, also applies rotation and scale accordingly. 
        # Existing storms will not target the new location, but newly generated storms will.
        TeleportTo<override>(Transform:transform)<transacts><decides>:void = external {}

        # Moves the `storm_controller_device` to the specified `Position` and `Rotation` over the specified time, in seconds. 
        # Existing storms will not target the new location, but newly generated storms will.
        MoveTo<override>(Position:vector3, Rotation:rotation, OverTime:float)<suspends>:move_to_result = external {}

        # Moves the `storm_controller_device` to the specified `Transform` over the specified time, in seconds. 
        # Existing storms will not target the new location, but newly generated storms will.
        MoveTo<override>(Transform:transform, OverTime:float)<suspends>:move_to_result = external {}

    # A set of customizable pop up targets that can be hit by players to trigger various events.
    shooting_range_target_track_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when target is hit in the bullseye area.
        BullseyeHitEvent<public>:listenable(tuple()) = external {}

        # Signaled when the target is hit by a player.
        HitEvent<public>:listenable(tuple()) = external {}

        # Signaled when the target is hit by a player.
        KnockdownEvent<public>:listenable(tuple()) = external {}

        # Signaled when the target moves up slightly, making it harder to hit.
        HopUpEvent<public>:listenable(tuple()) = external {}

        # Signaled when the target moves down slightly, making it harder to hit.
        HopDownEvent<public>:listenable(tuple()) = external {}

        # Signaled when the target moves from laying flat to standing upright.
        PopUpEvent<public>:listenable(tuple()) = external {}

        # Signaled when the target moves from standing upright to laying flat.
        PopDownEvent<public>:listenable(tuple()) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Resets the target to its initial settings.
        Reset<public>():void = external {}

        # Moves an active (standing upright) target attached to the track up slightly, in an effort to make it harder to hit
        HopUp<public>():void = external {}

        # Moves an active (standing upright) target attached to the track down slightly, in an effort to make it harder to hit
        HopDown<public>():void = external {}

        # Causes the target attached to the track to transition from lying flat (inactive) to standing upright (active)
        PopUp<public>():void = external {}

        # Causes the target attached to the track to transition from standing upright (active) to lying flat (inactive)
        PopDown<public>():void = external {}

        # Enables movement on the track. This does not start the target moving, it only enables movement.
        EnableTrackMovement<public>():void = external {}

        # Disables movement on the track. This prevents any movement from occurring, until track movement is enabled again.
        DisableTrackMovement<public>():void = external {}

        # Activates the movement track.
        ActivateTrack<public>():void = external {}

        # Deactivates the movement track.
        DeactivateTrack<public>():void = external {}

        # Starts the target moving toward the end of the track.
        MoveToEnd<public>():void = external {}

        # Starts the target moving toward the start of the track.
        MoveToStart<public>():void = external {}

    # A single customizable pop up target that can be hit by `agent`s to trigger various events.
    shooting_range_target_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the target is hit in the bullseye area.
        BullseyeHitEvent<public>:listenable(tuple()) = external {}

        # Signaled when the target is hit by an `agent`.
        HitEvent<public>:listenable(tuple()) = external {}

        # Signaled when the target takes enough damage to get knocked down.
        KnockdownEvent<public>:listenable(tuple()) = external {}

        # Signaled when the target moves up slightly, making it harder to hit.
        HopUpEvent<public>:listenable(tuple()) = external {}

        # Signaled when the target moves down slightly, making it harder to hit.
        HopDownEvent<public>:listenable(tuple()) = external {}

        # Signaled when the target moves from laying flat to standing upright.
        PopUpEvent<public>:listenable(tuple()) = external {}

        # Signaled when the target moves from standing upright to laying flat.
        PopDownEvent<public>:listenable(tuple()) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Resets the target to its initial settings.
        Reset<public>():void = external {}

        # Moves an active (standing upright) target up slightly, in an effort to make it harder to hit.
        HopUp<public>():void = external {}

        # Moves an active (standing upright) target down slightly, in an effort to make it harder to hit.
        HopDown<public>():void = external {}

        # Causes a target to transition from lying flat (inactive) to standing upright (active).
        PopUp<public>():void = external {}

        # Causes a target to transition from standing upright (active) to lying flat (inactive).
        PopDown<public>():void = external {}

    # Used to manipulate scores using in-experience triggers. If *Activating Team* is set to a specific team, then you should use the `agent` overloads of each function. The `agent`'s team will be used to determine if that `agent` is allowed to affect the state of the device.
    score_manager_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the this device reaches its maximum number of triggers as defined by *Times Can Trigger*.
        # Sends the `agent` who last triggered the device.
        MaxTriggersEvent<public>:listenable(agent) = external {}

        # Signaled when the this device awards points to an `agent`.
        # Sends the `agent` who received the points.
        ScoreOutputEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>(Agent:agent):void = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>(Agent:agent):void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Resets this device to its original state.
        Reset<public>(Agent:agent):void = external {}

        # Resets this device to its original state.
        Reset<public>():void = external {}

        # Grant points to `Agent`.
        Activate<public>(Agent:agent):void = external {}

        # Grants points.
        Activate<public>():void = external {}

        # Increments the score quantity to be awarded by the next activation by `1`.
        Increment<public>(Agent:agent):void = external {}

        # Increments the score quantity to be awarded by the next activation by `1`.
        Increment<public>():void = external {}

        # Decrements the score quantity to be awarded by the next activation by `1`.
        Decrement<public>(Agent:agent):void = external {}

        # Decrements the score quantity to be awarded by the next activation by `1`.
        Decrement<public>():void = external {}

        # Sets the score to be awarded by the next activation to `Value`.
        SetScoreAward<public>(Value:int):void = external {}

        # Returns the score to be awarded by the next activation.
        GetScoreAward<public>()<transacts>:int = external {}

        # Sets the score to be awarded by the next activation to `Agent`'s current score.
        SetToAgentScore<public>(Agent:agent):void = external {}

        # Returns the current score for `Agent`.
        GetCurrentScore<public>(Agent:agent)<transacts>:int = external {}

    # Used to customize gameplay for any round-based game. It generally defines what happens to the`agent`'s inventory and rewards in each round.
    round_settings_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when a game round starts.
        RoundBeginEvent<public>:listenable(tuple()) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Enables the ability for players to Matchmake into the Island. Only applies to published games that have matchmaking turned on in the Island settings
        EnableMatchmaking<public>():void = external {}

        # Disables the ability for players to Matchmake into the Island. Only applies to published games that have matchmaking turned on in the Island settings
        DisableMatchmaking<public>():void = external {}

        # Toggles between `EnableMatchmaking` and `DisableMatchmaking`.
        ToggleMatchmaking<public>():void = external {}

        # Disables all end-round conditions. The round must be ended through calling `EndRound` or a creative event after this is called.
        DisableEndRoundConditions<public>():void = external {}

        # Ends the round immediately with `Agent`'s team set as the winner of the round.
        EndRound<public>(Agent:agent):void = external {}

    # Used to generate random numbers between a minimum and maximum value. Events are signaled when numbers are generated.
    #  * *Value Limit 1* is the minimum value for generation.
    #  * *Value Limit 2* is the maximum value for generation.
    rng_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the generated number >= *Winning Value*.
        WinEvent<public>:listenable(tuple()) = external {}

        # Signaled when the generated number < *Winning Value*.
        LoseEvent<public>:listenable(tuple()) = external {}

        # Signaled when the generated number = maximum.
        RolledMaxEvent<public>:listenable(tuple()) = external {}

        # Signaled when the generated number = minimum.
        RolledMinEvent<public>:listenable(tuple()) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Randomly generate a number between *Value Limit 1* and *Value Limit 2*.
        #  * If the number is >= *Winning Value* then `WinEvent` is fired.
        #  * If the number is < *Winning Value* then `LoseEvent` is fired.
        #  * If the number = minimum then `RolledMinEvent` is fired.
        #  * If the number = maximum then `RolledMaxEvent` is fired.
        #  * `Agent` is used as the Instigator of the roll event.
        Activate<public>(Agent:agent):void = external {}

        # Randomly roll a number within the configured min + max value range.
        #  * If the number is >= *Winning Value* then `WinEvent` is fired.
        #  * If the number is < *Winning Value* then `LoseEvent` is fired.
        #  * If the number = minimum then `RolledMinEvent` is fired.
        #  * If the number = maximum then `RolledMaxEvent` is fired.
        Activate<public>():void = external {}

        # Cancels the active number generation.
        Cancel<public>():void = external {}

    # Used to play curated music from the device or one or more registered `agent`s.
    radio_device<public> := class<concrete><final>(creative_device_base):
        # Starts playing audio from this device.
        Play<public>():void = external {}

        # Stops playing audio from this device.
        Stop<public>():void = external {}

        # Adds the specified agent as a target for the Radio to play audio from
        Register<public>(Agent:agent):void = external {}

        # Removes the specified agent as a target for the Radio to play audio from if previously Registered
        Unregister<public>(Agent:agent):void = external {}

        # Removes all previously registered agents as targets for the Radio to play audio from
        UnregisterAll<public>():void = external {}

        # Shows this device in the world.
        Show<public>()<transacts>:void = external {}

        # Hides this device from the world.
        Hide<public>()<transacts>:void = external {}

    # A device used to damage players who collide with it. Can also be used as a trigger to activate other devices.
    pulse_trigger_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Starts the damage sequence.
        Begin<public>():void = external {}

        # Stops the damage sequence.
        End<public>():void = external {}

        # Resumes the damage sequence from the last position where it was stopped.
        ResumeSequence<public>():void = external {}

        # Sets the damage to be applied to those hit by an active wave. Clamped between `0 <= GetDamage <= 100000`.
        # Wave visuals will change to reflect whether the wave causes damage or not.
        SetDamage<public>(Damage:float):void = external {}

        # Returns the damage to be applied to those hit by an active wave. Clamped between `0 <= GetDamage <= 100000`.
        GetDamage<public>()<transacts>:float = external {}

        # Sets the total number of waves this sequence will complete before ending its sequence. `LoopCount = 0` indicates the sequence should continue indefinitely.
        SetLoopCount<public>(LoopCount:int):void = external {}

        # Returns the total number of waves this sequence will complete before ending its sequence.
        # `0` indicates the sequence will continue indefinitely.
        GetLoopCount<public>()<transacts>:int = external {}

        # Sets the speed (in meters per second) at which the waves generated by this sequencer will travel.
        SetWaveSpeed<public>(Speed:float):void = external {}

        # Returns the speed (in meters per second) at which the waves generated by this sequencer will travel.
        GetWaveSpeed<public>()<transacts>:float = external {}

    # Base class for devices that spawn a prop object.
    prop_spawner_base_device<public> := class<abstract><epic_internal>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Spawns the prop associated with this device.
        SpawnObject<public>():void = external {}

        # Destroys all props spawned from this device.
        DestroyAllSpawnedObjects<public>():void = external {}

    # Allows customization of the Prop-o-Matic weapon functions and how the game reacts to players using it.
    prop_o_matic_manager_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when an `agent` begins entering a disguise.
        # Sends the `agent` that began entering the disguise.
        BeginEnteringDisguiseEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` finishes entering a disguise.
        # Sends the `agent` that finished entering the disguise.
        FinishEnteringDisguiseEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` exits a disguise.
        # Sends the `agent` that exited the disguise.
        ExitingDisguiseEvent<public>:listenable(agent) = external {}

        # Toggle Pinging props on/off.
        SetPingProps<public>(On:logic):void = external {}

        # Adjust the ping time.
        SetPingFrequency<public>(Time:float):void = external {}

        # Toggle showing the props remaining on the UI.
        SetShowPropsRemaining<public>(On:logic):void = external {}

        # Toggle showing the prop ping cooldown.
        SetShowPropPingCooldown<public>(On:logic):void = external {}

        # Manually ping all players that are currently hiding as props.
        PingPlayerProps<public>():void = external {}

        # Manually ping a specific player if they are currently a prop.
        PingPlayerProp<public>(Agent:agent):void = external {}

        # Returns whether a player is currently hiding or not.
        IsPlayerProp<public>(Agent:agent)<transacts><decides>:void = external {}

    # Base class for various powerup devices offering common events like `ItemPickedUpEvent`.
    powerup_device<public> := class<abstract><epic_internal>(creative_device_base):
        # Signaled when the powerup is picked up by an `agent`.
        # Sends the `agent` that picked up the powerup.
        ItemPickedUpEvent<public>:listenable(agent) = external {}

        # Spawns the powerup into the experience so users can interact with it.
        Spawn<public>():void = external {}

        # Despawns this powerup from the experience.
        Despawn<public>():void = external {}

        # Updates the *Duration* for this powerup, clamped to the Min and Max defined in the device.
        # Will not apply to any currently applied effects.
        SetDuration<public>(Time:float):void = external {}

        # Returns the *Duration* that this powerup will be active for on any player it is applied to.
        GetDuration<public>()<transacts>:float = external {}

        # If the `Agent` has the effect applied to them, this will return the remaining time the effect has.
        # Returns -1.0 if the effect has an infinite duration.
        # Returns 0 if the `Agent` does not have the effect applied.
        GetRemainingTime<public>(Agent:agent)<transacts>:float = external {}

        # Returns the `Agent` has the powerup's effect (or another of the same type) applied to them.
        HasEffect<public>(Agent:agent)<transacts><decides>:void = external {}

        # Grants this powerup to `Agent`.
        Pickup<public>(Agent:agent):void = external {}

        # Grants this powerup without an agent reference.
        # Requires *Apply To* set to *All Players*.
        Pickup<public>():void = external {}

    # Used to move, damage, and give scores to players that interact with it. By default, it is activated by any player touching its front face, which rotates it counterclockwise and knocks those players away from it and slightly upward.
    pinball_flipper_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when this device is activated by an `agent`.
        # Sends the `agent` that activated this device.
        ActivatedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Causes `Agent` to activate this device.
        Activate<public>(Agent:agent):void = external {}

    # A triggered bumper that can knock players back, damage them, and award points.
    pinball_bumper_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when this device is activated by an `agent`.
        # Sends the `agent` that activated this device.
        ActivatedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Activates this device.
        Activate<public>():void = external {}

    # Specialized `trigger_base_device` that will fire output events based on line of sight between `agent`s and the device.
    perception_trigger_device<public> := class<concrete><final>(trigger_base_device):
        # Signaled when an `agent` has direct line of sight to this device.
        # Sends the `agent` that has seen this device.
        AgentLooksAtDeviceEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` has lost direct line of sight to this device.
        # Sends the `agent` that has lost sight of this device.
        AgentLooksAwayFromDeviceEvent<public>:listenable(agent) = external {}

        # Signaled when this device has direct line of sight to an `agent`.
        # Sends the `agent` seen by this device.
        DeviceSeesAgentEvent<public>:listenable(agent) = external {}

        # Signaled when this device loses direct line of sight to an `agent`.
        # Sends the `agent` this device has lost sight of.
        DeviceLosesSightOfAgentEvent<public>:listenable(agent) = external {}

    # Provides a collection of destructible devices that you can select from to use as objectives in your game.
    objective_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when this device has been destroyed by an `agent`.
        # Sends the `agent` that destroyed this device.
        DestroyedEvent<public>:listenable(agent) = external {}

        # Shows this device in the world.
        Show<public>():void = external {}

        # Hides this device from the world.
        Hide<public>():void = external {}

        # Activates an objective pulse at `Agent`'s location pointing toward this device.
        ActivateObjectivePulse<public>(Agent:agent):void = external {}

        # Deactivates the objective pulse at `Agent`'s location.
        DeactivateObjectivePulse<public>(Agent:agent):void = external {}

        # Destroys the objective item. This is done regardless of the visibility or health of the item.
        Destroy<public>(Agent:agent):void = external {}

    # Used to temporarily modify the speed of `agent`s and vehicles.
    movement_modulator_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when this device is activated by an `agent`.
        # Sends the `agent` that activated this device.
        ActivationEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Activates this device's movement effect on `Agent`.
        Activate<public>(Agent:agent):void = external {}

    # Used to take players to different islands and to link experiences together.
    matchmaking_portal_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

    # Used to create custom points of interest and markers on the minimap and overview map.
    map_indicator_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Activates an objective pulse at `Agent`'s location pointing toward this device.
        ActivateObjectivePulse<public>(Agent:agent):void = external {}

        # Deactivates the objective pulse at `Agent`'s location.
        DeactivateObjectivePulse<public>(Agent:agent):void = external {}

    # Used to customize the state and accessibility of doors. `lock_device` only works with assets that have a door attached.
    lock_device<public> := class<concrete><final>(creative_device_base):
        # Locks the door. `Agent` is the instigator of the action.
        Lock<public>(Agent:agent):void = external {}

        # Unlocks the door. `Agent` is the instigator of the action.
        Unlock<public>(Agent:agent):void = external {}

        # Toggles between `Lock` and `Unlock`. `Agent` is the instigator of the action.
        ToggleLocked<public>(Agent:agent):void = external {}

        # Opens the door. `Agent` is the instigator of the action.
        Open<public>(Agent:agent):void = external {}

        # Closes the door. `Agent` is the instigator of the action.
        Close<public>(Agent:agent):void = external {}

        # Toggles between `Open` and `Close`. `Agent` is the instigator of the action.
        ToggleOpened<public>(Agent:agent):void = external {}

    # Used to configuration and spawn items that players can pick up and use.
    item_spawner_device<public> := class<concrete><final>(base_item_spawner_device):
        # Cycles device to next configured item.
        CycleToNextItem<public>():void = external {}

        # Spawns the current item.
        SpawnItem<public>():void = external {}

        # Sets device *Respawn Item on Timer* option (see `SetTimeBetweenSpawns`)
        SetEnableRespawnTimer<public>(Respawn:logic):void = external {}

        # Returns device *Respawn Item on Timer* option (see `SetTimeBetweenSpawns`)
        GetEnableRespawnTimer<public>()<transacts>:logic = external {}

        # Sets the *Time Between Spawns* (in seconds) after an item is collected before the next is spawned, if this device has *Respawn Item on Timer* enabled (see `SetEnableRespawnTimer`)
        SetTimeBetweenSpawns<public>(Time:float):void = external {}

        # Returns the *Time Between Spawns* (in seconds) after an item is collected before the next is spawned, if this device has *Respawn Item on Timer* enabled (see `SetEnableRespawnTimer`)
        GetTimeBetweenSpawns<public>()<transacts>:float = external {}

    # Used to grant items to `agent`s. Items can either be dropped at the `agent`'s location or added directly to their inventory.
    item_granter_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when an item is granted to an `agent`.
        # Sends the `agent` that was granted the item.
        ItemGrantedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Clears saved data for `Agent`, preventing them from receiving items while offline. This only works when *Grant While Offline* is set to *Yes*.
        ClearSaveData<public>(Agent:agent):void = external {}

        # Cycles to the next item. If *Grant on Cycle* is set `Agent` will be granted the item.
        CycleToNextItem<public>(Agent:agent):void = external {}

        # Cycles to the previous item. If *Grant on Cycle* is set `Agent` will be granted the item.
        CycleToPreviousItem<public>(Agent:agent):void = external {}

        # Cycles to a random item. If *Grant on Cycle* is set `Agent` will be granted the item.
        CycleToRandomItem<public>(Agent:agent):void = external {}

        # Grants an item to `Agent`.
        GrantItem<public>(Agent:agent):void = external {}

        # Restocks this device back to its starting inventory count.
        RestockItems<public>():void = external {}

        # Sets the next item to be granted.
        #  * `Index` should be between `0` and the available item count - 1.
        #  * Calling `SetNextItem` with an invalid index will do nothing.
        SetNextItem<public>(Index:int):void = external {}

    # Used to show custom HUD messages to one or more `agent`s.
    hud_message_device<public> := class<concrete><final>(creative_device_base):
        # Shows the currently set HUD *Message* on `Agent`s screen. Will replace any previously active message.
        # Use this when the device is setup to target specific `agent`s.
        Show<public>(Agent:agent):void = external {}

        # Shows the currently set *Message* HUD message on screen. Will replace any previously active message.
        Show<public>():void = external {}

        # Hides the HUD message.
        Hide<public>():void = external {}

        # Displays a Custom message to a specific *Agent* that you define.Setting *DisplayTime* to `0.0` will display the HUD message persistently.If not defined, or less than `0.0` the message will show for the time set on the device.
        Show<public>(Agent:agent, Message:message, ?DisplayTime:float = external {}):void = external {}

        # Displays a Custom message that you define for all PlayersSetting *DisplayTime* to `0.0` will display the HUD message persistently.If not defined, or less than `0.0` the message will show for the time set on the device.
        Show<public>(Message:message, ?DisplayTime:float = external {}):void = external {}

        # Sets the time (in seconds) the HUD message will be displayed. `0.0` will display the HUD message persistently.
        SetDisplayTime<public>(Time:float):void = external {}

        # Returns the time (in seconds) for which the HUD message will be displayed. `0.0` means the message is displayed persistently.
        GetDisplayTime<public>()<transacts>:float = external {}

        # Sets the *Message* to be displayed when the HUD message is activated. `Text` is clamped to 150 characters.
        SetText<public>(Text:message):void = external {}

    # Used to create a holographic screen that displays a clock or other curated images.
    holoscreen_device<public> := class<concrete><final>(creative_device_base):

    # Used to let `agent`s slide on any surface with accompanying visual and audio effects.
    grind_powerup_device<public> := class<concrete><final>(powerup_device):

    # Used to provide fuel sources for vehicles. Can also be used to deal considerable damage to `agent`s and the environment when destroyed.
    fuel_pump_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the fuel pump is emptied.
        # Sends the `agent` that emptied the fuel pump.
        EmptyEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Resets fuel stock to *Fuel Capacity* value.
        Reset<public>():void = external {}

        # Grants fuel to `Agent`.
        Empty<public>(Agent:agent):void = external {}

    # Hazard which deals damage in a radius around it when destroyed or triggered.
    explosive_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when this device explodes.
        # Sends the `agent` that caused the explosion.
        ExplodedEvent<public>:listenable(agent) = external {}

        # Shows this device in the world.
        Show<public>():void = external {}

        # Hides this device from the world.
        Hide<public>():void = external {}

        # Resets this device.
        Reset<public>():void = external {}

        # Triggers this device to explode. Passes `Agent` as the instigator of the explosion.
        Explode<public>(Agent:agent):void = external {}

    # Used to customize high level properties of the game mode.
    experience_settings_device<public> := class<concrete><final>(creative_device_base):

    # Used to spawn items when an `agent` or specified target is eliminated.
    elimination_manager_device<public> := class<concrete><final>(base_item_spawner_device):
        # Signaled when a qualifying elimination occurs.
        # Sends the eliminated `agent`.
        EliminatedEvent<public>:listenable(agent) = external {}

        # Signaled when a qualifying elimination occurs.
        # Sends the eliminator `agent`. If the eliminator is a non-agent then `false` is returned.
        EliminationEvent<public>:listenable(?agent) = external {}

    # Used to amplify an `agent`'s damage temporarily. This applies to any weapon the `agent` is using at the time of the powerup.
    damage_amplifier_powerup_device<public> := class<concrete><final>(powerup_device):
        # Sets the *Magnitude* for this powerup, clamped to the Min and Max defined in the device.
        # Will not apply to any currently applied effects.
        # For the Damage Amplifier Powerup, this is the damage multiplier.
        SetMagnitude<public>(Magnitude:float):void = external {}

        # Returns the current *Magnitude* for the powerup.
        # For the Damage Amplifier Powerup, this is the damage multiplier.
        GetMagnitude<public>()<transacts>:float = external {}

    # Used to create a specialized button which can only be activated when `agent`s are carrying specific items.
    conditional_button_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when this device is activated.
        # Sends the `agent` that activated this device.
        ActivatedEvent<public>:listenable(agent) = external {}

        # Signaled when this device fails to activate because `agent` didn't have the required items.
        # Sends the `agent` that attempted to activate the device.
        NotEnoughItemsEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Resets this device to its original settings.
        Reset<public>():void = external {}

        # Activates this device. `Agent` is used as the instigator of the action.
        Activate<public>(Agent:agent):void = external {}

        # Toggles the conditional button state. `Agent` is used as the instigator of the action.
        Toggle<public>(Agent:agent):void = external {}

        # Sets the text that appears when `agent`s approach the device. `Text` is limited to `150` characters and will revert back to default if empty.
        SetInteractionText<public>(Text:message):void = external {}

        # Sets the time (in seconds) that an interaction with this device should take to complete.
        SetInteractionTime<public>(Time:float):void = external {}

        # Returns the time (in seconds) that an interaction with this device will take to complete.
        GetInteractionTime<public>()<transacts>:float = external {}

        # Sets the quantity of a specific key item type that needs to be collected in order to activate the switch.
        # `KeyItemIndex` ranges from `0` to number of key item types - 1.
        SetItemCountRequired<public>(KeyItemIndex:int, Count:int):void = external {}

        # Returns the total quantity of a specific key item type that needs to be collected in order to activate the switch.
        GetItemCountRequired<public>(KeyItemIndex:int)<transacts>:int = external {}

        # Returns the remaining quantity of a specific key item type that needs to be collected in order to activate the switch.
        GetRemainingItemCountRequired<public>(KeyItemIndex:int)<transacts>:int = external {}

        # Sets the score to be awarded for a key item. `KeyItemIndex` ranges from `0` to number of key item types - 1.
        SetItemScore<public>(KeyItemIndex:int, Score:int):void = external {}

        # Returns the score to be awarded for a key item.
        GetItemScore<public>(KeyItemIndex:int)<transacts>:int = external {}

        # Returns how many items an `Agent` has of the item stored at `KeyItemIndex`.
        GetItemCount<public>(Agent:agent, KeyItemIndex:int):int = external {}

        # Returns if the `Agent` has all of the items required to interact with this Device.
        HasAllItems<public>(Agent:agent)<transacts><decides>:void = external {}

        # Returns if the `Agent` is currently holding any of the items stored in the Device.
        IsHoldingItem<public>(Agent:agent)<transacts><decides>:void = external {}

        # Returns if the `Agent` is currently holding the item stored at `KeyItemIndex`.
        IsHoldingItem<public>(Agent:agent, KeyItemIndex:int)<transacts><decides>:void = external {}

    # Used to create a tile that changes colors when `agent`s interact with it.
    color_changing_tiles_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when this device changes color.
        # Sends the `agent` that interacted with this device.
        ActivatedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Shows this device in the world.
        Show<public>():void = external {}

        # Hides this device from the world.
        Hide<public>():void = external {}

        # Resets this device to its initial settings.
        Reset<public>():void = external {}

        # Sets the color of the tile to `Agent`'s team color.
        SetTeam<public>(Agent:agent):void = external {}

    # Used to place a collectible item into the world.
    collectible_object_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when the collectible item is collected.
        # Sends the `agent` that collected the item.
        CollectedEvent<public>:listenable(agent) = external {}

        # Makes the collectible visible.
        Show<public>():void = external {}

        # Makes the collectible invisible.
        Hide<public>():void = external {}

        # Immediately respawns the object for the instigating agent.
        # This will be affected by the option *Consume If Collected By*.
        Respawn<public>(Agent:agent):void = external {}

        # Immediately respawns the object for all agents.
        RespawnForAll<public>():void = external {}

    # Used together with `class_selector_device` to create class based gameplay. Defines custom class attributes and inventory loadouts.
    class_designer_device<public> := class<concrete><final>(creative_device_base):

    # Used together with `class_designer_device` to control how/when created classes can be accessed by `agent`s.
    class_and_team_selector_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when an `agent` changes class.
        # Sends the `agent` whose class changed.
        ClassSwitchedEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` changes teams.
        # Sends the `agent` whose team changed.
        TeamSwitchedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Changes the `Agent`'s class.
        ChangeClass<public>(Agent:agent):void = external {}

        # Changes the `Agent`'s team.
        ChangeTeam<public>(Agent:agent):void = external {}

        # Changes the `Agent`'s team and class.
        ChangeTeamAndClass<public>(Agent:agent):void = external {}

        # Changes the selecting team.
        ChangeSelectorTeam<public>(Agent:agent):void = external {}

    # Spawns and tracks a single item as a game objective (e.g. flag).
    capture_item_spawner_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when spawned item is captured.
        # Sends the `agent` that captured the item.
        ItemCapturedEvent<public>:listenable(agent) = external {}

        # Signaled when spawned item is picked up.
        # Sends the `agent` that picked up the item.
        ItemPickedUpEvent<public>:listenable(agent) = external {}

        # Signaled when spawned item is dropped.
        # Sends the `agent` that dropped the item.
        ItemDroppedEvent<public>:listenable(agent) = external {}

        # Signaled when spawned item is returned.
        # Sends the `agent` that returned the item.
        ItemReturnedEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

    # Used to create a zone that can trigger effects once players enter it. Can be set up to be capturable by a team, to provide a score while held, or to require a specific item as a drop-off.
    capture_area_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when an `agent` enters this device area.
        # Sends the `agent` that entered this device area.
        AgentEntersEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` exits this device area.
        # Sends the `agent` that exited this device area.
        AgentExitsEvent<public>:listenable(agent) = external {}

        # Signaled when the first `agent` enters this device area.
        # Sends the `agent` that entered this device area.
        FirstAgentEntersEvent<public>:listenable(agent) = external {}

        # Signaled when the last `agent` exits this device area.
        # Sends the `agent` that exited this device area.
        LastAgentExitsEvent<public>:listenable(agent) = external {}

        # Signaled when this device is contested.
        # Sends the `agent` that is contesting this device.
        AreaIsContestedEvent<public>:listenable(agent) = external {}

        # Signaled when this device is scored.
        # Sends the `agent` that scored this device.
        AreaIsScoredEvent<public>:listenable(agent) = external {}

        # Signaled when this device control change starts.
        # Sends the `agent` that is triggering this device control change.
        ControlChangeStartsEvent<public>:listenable(agent) = external {}

        # Signaled when this device control changes.
        # Sends the `agent` that triggered this device control change.
        ControlChangeEvent<public>:listenable(agent) = external {}

        # Signaled when an item is consumed by this device.
        # Sends the `agent` that provided the item to this device.
        ItemIsConsumedEvent<public>:listenable(agent) = external {}

        # Signaled when an item is delivered to this device.
        # Sends the `agent` that delivered the item to this device.
        ItemIsDeliveredEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Toggles between `Enable` and `Disable`.
        ToggleEnabled<public>():void = external {}

        # Allows this device to be captured.
        AllowCapture<public>():void = external {}

        # Disallows this device from being captured.
        DisallowCapture<public>():void = external {}

        # Toggles between `AllowCapture` and `DisallowCapture`.
        ToggleCaptureAllowed<public>():void = external {}

        # Resets control of this device for all teams.
        Reset<public>():void = external {}

        # Gives control of this device to the capturing `agent`'s team.
        GiveControl<public>(Agent:agent):void = external {}

        # Clears control of this device for all teams.
        Neutralize<public>():void = external {}

        # Activates the objective pulse for this device.
        ActivateObjectivePulse<public>():void = external {}

        # Deactivates the objective pulse for this device.
        DeactivateObjectivePulse<public>():void = external {}

        # Sets the *Capture Height* (in meters) of the capture area.
        SetHeight<public>(Height:float):void = external {}

        # Returns the *Capture Height* (in meters) of the capture area.
        GetHeight<public>()<varies>:float = external {}

        # Sets the *Capture Radius* (in meters) of the capture area.
        SetRadius<public>(Radius:float):void = external {}

        # Returns the *Capture Radius* (in meters) of the capture area.
        GetRadius<public>()<varies>:float = external {}

    # Used to create a button which can trigger other devices when an agent interacts with it.
    button_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when an `agent` successfully interacts with the button for `GetInteractionTime` seconds.
        # Sends the `agent` that interacted with the button.
        InteractedWithEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Sets the text that displays when an `agent` is close to this button and looks at it. `Text` is limited to `64` characters.
        SetInteractionText<public>(Text:message):void = external {}

        # Sets the duration of the interaction required to activate this device (in seconds).
        SetInteractionTime<public>(Time:float):void = external {}

        # Returns the duration of the interaction required to activate this device (in seconds).
        GetInteractionTime<public>()<transacts>:float = external {}

        # Sets the maximum amount of times this button can be interacted with before it will be disabled.
        #  * `MaxCount` must be between `0` and `10`.
        #  * `0` indicates no limit on trigger count.
        SetMaxTriggerCount<public>(MaxCount:int):void = external {}

        # Returns the maximum amount of times this button can be interacted with before it will be disabled.
        #  * `GetTriggerMaxCount` will be between `0` and `10`.
        #  * `0` indicates no limit on trigger count.
        GetMaxTriggerCount<public>()<transacts>:int = external {}

        # Returns the number of times that this button can still be interacted with before it will be disabled. Will return `0` if `GetMaxTriggerCount` is unlimited.
        GetTriggerCountRemaining<public>()<transacts>:int = external {}

    # Used to display custom text messages on a billboard.
    billboard_device<public> := class<concrete><final>(creative_device_base):
        # Shows the billboard text.
        ShowText<public>():void = external {}

        # Hides the billboard text.
        HideText<public>():void = external {}

        # Updates the device display to show the current *Text*.
        UpdateDisplay<public>():void = external {}

        # Sets the visibility of the device border mesh. This also determines whether the device collision is enabled.
        SetShowBorder<public>(Show:logic):void = external {}

        # Returns `true` if the device border is enabled.
        GetShowBorder<public>()<transacts>:logic = external {}

        # Sets the device *Text*.
        SetText<public>(Text:message):void = external {}

        # Sets the *Text Size* of the device *Text*. Clamped to range [8, 24].
        SetTextSize<public>(Size:int):void = external {}

        # Returns the *Text Size* of the device *Text*.
        GetTextSize<public>()<transacts>:int = external {}

    # Used to show an in world visual effect and/or a HUD marker at the desired location.
    beacon_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Adds the specified `agent` to a list of `agent`s that the Beacon will be shown to. This list of `agent`s is maintained separately from the Team Visibility set of `agent`s.
        AddToShowList<public>(Agent:agent):void = external {}

        # Removes the specified `agent` from the show list. The `agent` will still see the Beacon if they meet the Team Visibility check.
        RemoveFromShowList<public>(Agent:agent):void = external {}

        # Removes all `agent`s from the show list. `Agent`s will still see the Beacon if they meet the Team Visibility check.
        RemoveAllFromShowList<public>():void = external {}

    # A simplified storm device that provides a way to create a single-phase storm and control its basic behaviors.
    # To control multiple phases of the storm see `advanced_storm_controller_device`.
    basic_storm_controller_device<public> := class<concrete><final>(storm_controller_device):

    # Base class for devices that spawn items.
    base_item_spawner_device<public> := class<abstract><epic_internal>(creative_device_base):
        # Signaled when an `agent` picks up the spawned item.
        # Sends the `agent` that picked up the item.
        ItemPickedUpEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

    # Used to spawn various types of balls. Can be used to control HUD elements related to the spawned balls.
    ball_spawner_device<public> := class<concrete><final>(creative_device_base):
        # Shows the floating HUD Icons to players, if these have been configured by the device.
        ShowHUD<public>():void = external {}

        # Hides the floating HUD Icons from players, if these have been configured by the device.
        HideHUD<public>():void = external {}

    # Evaluates attributes for `agent` when signaled from other devices. Acts as branching logic, checking whether the `agent` associated with the signal passes all of the tests setup in this device, then sends a signal on either `PassEvent` or `FailEvent`.
    attribute_evaluator_device<public> := class<concrete><final>(trigger_base_device):
        # Signaled when the `agent` from `EvaluateAgent` passes the requirements specified by this device.
        # Sends the `agent` originally passed to this device in `EvaluateAgent`.
        PassEvent<public>:listenable(agent) = external {}

        # Signaled when the `agent` from `EvaluateAgent` fails the requirements specified by this device.
        # Sends the `agent` originally passed to this device in `EvaluateAgent`.
        FailEvent<public>:listenable(agent) = external {}

        # Tests whether the specified agent satisfies the required conditions specified on the device (e.g. eliminations/score), and fires either the `PassEvent` or `FailEvent` accordingly.
        EvaluateAgent<public>(Agent:agent):void = external {}

    # Used to boost `agent`s, vehicles, and other objects upwards into the air.
    air_vent_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Activates this device.
        Activate<public>():void = external {}

    # Used to control a Battle Royale-style storm with up to 50 phases.
    # 
    # Like `basic_storm_controller_device`s, you can use this storm to keep players inside a playable area, but unlike the `basic_storm_controller_device`, this device generates multiple storm phases. When used in conjunction with `advanced_storm_beacon_device`s, you can customize each phase of the storm by applying one or more beacons and setting customization options for the specific phase you assign to that beacon.
    advanced_storm_controller_device<public> := class<concrete><final>(storm_controller_device):

    # Used in conjunction with `advanced_storm_controller_device` to customize individual storm phases.
    advanced_storm_beacon_device<public> := class<concrete><final>(creative_device_base):
        # Teleports the `advanced_storm_beacon_device` to the specified `Position` and `Rotation`. 
        # Existing storms will not target the new location, but newly generated storms will.
        TeleportTo<override>(Position:vector3, Rotation:rotation)<transacts><decides>:void = external {}

        # Teleports the `advanced_storm_beacon_device` to the specified location defined by `Transform`, also applies rotation and scale accordingly. 
        # Existing storms will not target the new location, but newly generated storms will.
        TeleportTo<override>(Transform:transform)<transacts><decides>:void = external {}

        # Moves the `advanced_storm_beacon_device` to the specified `Position` and `Rotation` over the specified time, in seconds. 
        # Existing storms will not target the new location, but newly generated storms will.
        MoveTo<override>(Position:vector3, Rotation:rotation, OverTime:float)<suspends>:move_to_result = external {}

        # Moves the `advanced_storm_beacon_device` to the specified `Transform` over the specified time, in seconds. 
        # Existing storms will not target the new location, but newly generated storms will.
        MoveTo<override>(Transform:transform, OverTime:float)<suspends>:move_to_result = external {}

    # Used to spawn guards that can patrol and attack other `agent`s.
    guard_spawner_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when a guard is spawned.
        # Sends the `agent` guard who was spawned.
        SpawnedEvent<public>:listenable(agent) = external {}

        # Signaled when a guard has identified an opponent.
        # `Source` is the guard who is aware.
        # `Target` is the agent who alerted the guard.
        AlertedEvent<public>:listenable(device_ai_interaction_result) = external {}

        # Signaled when a guard has lost track of a target.
        # `Source` is the guard that lost track of a target.
        # `Target` is the `agent` no longer targeted by the guard.
        TargetLostEvent<public>:listenable(device_ai_interaction_result) = external {}

        # Signaled when a guard becomes suspicious.
        # Sends the `agent` guard who is suspicious.
        SuspiciousEvent<public>:listenable(agent) = external {}

        # Signaled when a guard becomes unaware.
        # Sends the `agent` guard who is unaware.
        UnawareEvent<public>:listenable(agent) = external {}

        # Signaled when guard is damaged.
        # `Source` is the `agent` that damaged the guard. If the guard was damaged by a non-agent then `false` is returned.
        # `Target` is the guard that was damaged.
        DamagedEvent<public>:listenable(device_ai_interaction_result) = external {}

        # Signaled when a guard is eliminated.
        # `Source` is the `agent` that eliminated the guard. If the guard was eliminated by a non-agent then `Source` is 'false'.
        # `Target` is the guard that was eliminated.
        EliminatedEvent<public>:listenable(device_ai_interaction_result) = external {}

        # Signaled when a guard eliminates an agent.
        # `Source` is the guard that eliminated the agent.
        # `Target` is the agent that was eliminated.
        EliminatingEvent<public>:listenable(device_ai_interaction_result) = external {}

        # Signaled when a guard is hired by a player.
        # `Source` is the `agent` who hired the guard.
        # `Target` is the guard that was hired.
        HiredEvent<public>:listenable(device_ai_interaction_result) = external {}

        # Signaled when a guard is dismissed by a player.
        # `Source` is the `agent` who dismissed the guard.
        # `Target` is the guard that was dismissed.
        DismissedEvent<public>:listenable(device_ai_interaction_result) = external {}

        # Enables this device. Guards will start to spawn.
        Enable<public>():void = external {}

        # Disables this device. Guards will despawn if *Despawn Guards When Disabled* is set.
        Disable<public>():void = external {}

        # Resets the spawn count allowing spawning of a new batch of guards.
        Reset<public>():void = external {}

        # Tries to spawn a guard.
        Spawn<public>():void = external {}

        # Tries to spawn a guard. If *Auto Hire When Spawned* is set to *Triggering Player* the guard will be hired by `Instigator`.
        Spawn<public>(Instigator:agent):void = external {}

        # Despawns guards.
        Despawn<public>():void = external {}

        # Despawns guards. `Instigator` will be considered as the eliminator of those guards.
        Despawn<public>(Instigator:agent):void = external {}

        # Hires guards to `Instigator`'s team.
        Hire<public>(Instigator:agent):void = external {}

        # Dismisses all hired guards.
        DismissAllHiredGuards<public>():void = external {}

        # Dismisses all hired guards that were recruited by `Instigator`.
        DismissAgentHiredGuards<public>(Instigator:agent):void = external {}

        # Forces guards to attack `Target`, bypassing perception checks.
        # 'ForgetTime' ranges from 0.0 to 600.0 (in seconds, default is 600.0), it is the time after which the target will be ignored if not found.
        # 'ForgetDistance' ranges from 0.0 to 100000.0 (in centimeters, default is 100000.0), it is the distance at which the target will be ignored if not found.
        ForceAttackTarget<public>(Target:agent, ?ForgetTime:float = external {}, ?ForgetDistance:float = external {}):void = external {}

        # Allows guards to be hired.
        SetGuardsHireable<public>():void = external {}

        # Prevents guards from being hired.
        SetGuardsNotHireable<public>():void = external {}

        # Returns the spawn limit of the device.
        GetSpawnLimit<public>()<transacts>:int = external {}

    # Creates a chair where `Agent`s can sit.
    chair_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when an `agent` sits on the Chair.
        # Sends the sitting `agent`.
        SeatedEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` stops sitting on the Chair.
        # Sends the standing `Agent`.
        ExitedEvent<public>:listenable(agent) = external {}

        # Enables the Chair.
        # An enabled Chair can be interacted with and occupied
        # by any `agent` that meets the requirements.
        Enable<public>():void = external {}

        # Disables the Chair.
        # A disabled Chair cannot be interacted with
        # and any `agent` currently occupying the Chair will be ejected.
        Disable<public>():void = external {}

        # Allows any seated `agent` to leave the chair manually.
        EnableExit<public>():void = external {}

        # Prevents any seated `agent` from leaving the Chair manually.
        # While Exit is disabled, call Eject to force them out.
        DisableExit<public>():void = external {}

        # Makes `Agent` sit on this chair if they meet the requirements.
        Seat<public>(Agent:agent):void = external {}

        # Ejects any `agent` currently in the chair.
        Eject<public>():void = external {}

        # Makes `Agent` exit this chair if they are currently in the chair.
        Eject<public>(Agent:agent):void = external {}

        # Succeeds if `Agent` is currently in the chair .
        IsSeated<public>(Agent:agent)<transacts><decides>:void = external {}

        # Succeeds if the chair is currently occupied.
        IsOccupied<public>()<transacts><decides>:void = external {}

        # Returns the `agent` currently occupying the chair.
        GetSeatedAgent<public>():?agent = external {}

    using {/Fortnite.com/Vehicles}
    # Specialized `vehicle_spawner_device` that allows a Whiplash sports car to be configured and spawned.
    vehicle_spawner_sports_car_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Base class for various specialized vehicle spawners which allow specific vehicle types to be spawned and configured with specialized options.
    vehicle_spawner_device<public> := class<abstract><epic_internal>(creative_device_base):
        # Signaled when an `agent` enters the vehicle.
        # Sends the `agent` that entered the vehicle.
        AgentEntersVehicleEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` exits the vehicle.
        # Sends the `agent` that exited the vehicle.
        AgentExitsVehicleEvent<public>:listenable(agent) = external {}

        # Signaled when a vehicle is spawned or respawned by this device.
        # Sends the fort_vehicle who was spawned.
        SpawnedEvent<public>:listenable(fort_vehicle) = external {}

        # Signaled when a vehicle is spawned or respawned by this device.
        # Deprecated, use SpawnedEvent instead.
        VehicleSpawnedEvent<public>:listenable(tuple()) = external {}

        # Signaled when a vehicle is destroyed.
        # Deprecated, use DestroyedEvent instead.
        VehicleDestroyedEvent<public>:listenable(tuple()) = external {}

        # Signaled when a vehicle is destroyed.
        DestroyedEvent<public>:listenable(tuple()) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Sets `agent` as the vehicle's driver.
        AssignDriver<public>(Agent:agent):void = external {}

        # Destroys the vehicle if it exists.
        DestroyVehicle<public>():void = external {}

        # Spawns a new vehicle. The previous vehicle will be destroyed before a new vehicle spawns.
        RespawnVehicle<public>():void = external {}

    # Specialized `vehicle_spawner_device` that allows a taxi to be configured and spawned.
    vehicle_spawner_taxi_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a surfboard to be configured and spawned.
    vehicle_spawner_surfboard_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a shopping cart to be configured and spawned.
    vehicle_spawner_shopping_cart_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a Quadcrasher to be configured and spawned.
    vehicle_spawner_quadcrasher_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a Prevalent sedan to be configured and spawned.
    vehicle_spawner_sedan_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a Mudflap semi truck to be configured and spawned.
    vehicle_spawner_big_rig_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a Driftboard to be configured and spawned.
    vehicle_spawner_driftboard_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a cannon to be configured and spawned.
    vehicle_spawner_cannon_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a boat to be configured and spawned.
    vehicle_spawner_boat_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a Stormwing biplane to be configured and spawned.
    vehicle_spawner_biplane_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a pickup truck to be configured and spawned.
    vehicle_spawner_pickup_truck_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a Baller vehicle to be configured and spawned.
    vehicle_spawner_baller_device<public> := class<concrete><final>(vehicle_spawner_device):
        # Signaled when the vehicle runs out of energy.
        OutOfEnergyEvent<public>:listenable(tuple()) = external {}

        # Refills the vehicle's energy.
        RefillEnergy<public>():void = external {}

    # Specialized `vehicle_spawner_device` that allows an ATK (all terrain kart) to be configured and spawned.
    vehicle_spawner_atk_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Used to create HUD text boxes that give players information, and allows responses to be customized to player choices.
    popup_dialog_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when *Button <Index>* on this device is pushed by an `agent`.
        # Sends the `agent` that pushed the button.
        # Sends the `int` index of the button that was clicked.
        RespondingButtonEvent<public>:listenable(tuple(agent, int)) = external {}

        # Signaled when this device is shown to an `agent`.
        # Sends the `agent` looking at the popup.
        ShownEvent<public>:listenable(agent) = external {}

        # Signaled when this device is dismissed by an `agent`.
        # Sends the `agent` who dismissed the popup.
        DismissedEvent<public>:listenable(agent) = external {}

        # Signaled when this device times out while an `agent` is looking at it.
        # Sends the `agent` who was looking at the popup.
        TimeOutEvent<public>:listenable(agent) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Shows the popup to `Agent`.
        Show<public>(Agent:agent):void = external {}

        # Shows the popup to all `agent`s in the experience.
        Show<public>():void = external {}

        # Hides the popup from `Agent`.
        Hide<public>(Agent:agent):void = external {}

        # Hides the popup from all `agent`s in the experience.
        Hide<public>():void = external {}

        # Sets the number of buttons this popup has.
        # Button Count is not updated on active Popups.
        SetButtonCount<public>(Count:int):void = external {}

        # Returns the *Button Text* for this popup at a specified index.
        GetButtonText<public>(Index:int)<transacts>:[]char = external {}

        # Sets the *Button Text* for a button at a specific index on this popup.
        #  * `Text` should be no more than `8` characters.
        #  * If `Text` is empty the button will show *OK* instead.
        #  * Button 1 uses `Index` 0.
        SetButtonText<public>(Text:message, Index:int):void = external {}

        # Sets the *Description* text for this popup. `Text` should be no more than `350` characters.
        SetDescriptionText<public>(Text:message):void = external {}

        # Returns the *Description* text for this popup.
        GetDescriptionText<public>()<transacts>:[]char = external {}

        # Sets the *Title* text for this popup. `Text` should be no more than `32` characters.
        SetTitleText<public>(Text:message):void = external {}

        # Returns the *Title* text for this popup.
        GetTitleText<public>()<transacts>:[]char = external {}

    # Physics tree that can be chopped down, and damage players, vehicles, creatures, and structures.
    physics_tree_device<public> := class<concrete><final>(physics_object_base_device):
        # Signaled when a tree is spawned.
        TreeSpawnedEvent<public>:listenable(tuple()) = external {}

        # Signaled when the log created by a tree is destroyed.
        LogDestroyedEvent<public>:listenable(tuple()) = external {}

        # Signaled when the stump created by a tree is destroyed.
        StumpDestroyedEvent<public>:listenable(tuple()) = external {}

        # Signaled when a tree has taken enough damage to be knocked down.
        TreeKnockedDownEvent<public>:listenable(tuple()) = external {}

        # Releases the log from the tree, if there is one.
        ReleaseLog<public>():void = external {}

        # Destroys the current log.
        DestroyLog<public>():void = external {}

        # Destroys the current stump.
        DestroyStump<public>():void = external {}

    # Base class for various physics-based gameplay elements (e.g. boulders/trees).
    physics_object_base_device<public> := class<abstract><epic_internal>(prop_spawner_base_device):

    # Physics boulder that can be dislodged and damage `agent`s, vehicles, creatures, and structures.
    physics_boulder_device<public> := class<concrete><final>(physics_object_base_device):
        # Signaled when the balanced boulder is spawned on the base.
        BalancedBoulderSpawnedEvent<public>:listenable(tuple()) = external {}

        # Signaled when the balanced boulder is destroyed.
        BalancedBoulderDestroyedEvent<public>:listenable(tuple()) = external {}

        # Signaled when the base of the boulder is destroyed.
        BaseDestroyedEvent<public>:listenable(tuple()) = external {}

        # Signaled when the rolling boulder is destroyed.
        RollingBoulderDestroyedEvent<public>:listenable(tuple()) = external {}

        # Destroys the boulder's base.
        DestroyBase<public>():void = external {}

        # Releases the boulder sitting on the base, if there is one.
        ReleaseRollingBoulder<public>():void = external {}

        # Destroys the current rolling boulder.
        DestroyRollingBoulder<public>():void = external {}

    # Used to regenerate an `agent`'s health and/or shields.
    health_powerup_device<public> := class<concrete><final>(powerup_device):
        # Sets the *Magnitude* for this powerup, clamped to the Min and Max defined in the device.
        # Will not apply to any currently applied effects.
        # For the Health Powerup, this is the amount of health or shield that the powerup will add or remove,
        SetMagnitude<public>(Magnitude:float):void = external {}

        # Returns the current *Magnitude* for the powerup.
        # For the Health Powerup, this is the amount of health or shield that the powerup will add or remove,
        GetMagnitude<public>()<transacts>:float = external {}

    # Spawns a lightweight vehicle made for defying gravity with its rocket boosting, jumping, and aerial maneuverability capabilities.
    vehicle_spawner_octane_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a helicopter to be configured and spawned.
    vehicle_spawner_helicopter_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows an anti-vehicle turret to be configured and spawned.
    vehicle_spawner_heavy_turret_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a siege cannon to be configured and spawned.
    vehicle_spawner_siege_cannon_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a UFO to be configured and spawned.
    vehicle_spawner_ufo_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a tank to be configured and spawned.
    vehicle_spawner_tank_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows an armored battle bus to be configured and spawned.
    vehicle_spawner_armored_battle_bus_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a dirtbike to be configured and spawned.
    vehicle_spawner_dirtbike_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a Nitro Drifter sedan to be configured and spawned.
    vehicle_spawner_nitro_drifter_sedan_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a sportbike to be configured and spawned.
    vehicle_spawner_sportbike_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Specialized `vehicle_spawner_device` that allows a GetAway Car to be configured and spawned.
    vehicle_spawner_getaway_device<public> := class<concrete><final>(vehicle_spawner_device):

    # Used to create plants with explosive pods that players can detonate and launch.
    wilds_plant_device<public> := class<concrete><final>(creative_device_base):
        # Triggers whenever the plant grows.
        GrowEvent<public>:listenable(tuple()) = external {}

        # Triggers whenever the plant or launched projectile explodes.
        #  * Sends the `agent` that initially launched the projectile or triggered an immediate explosion.
        #  * Sends `false` if no `agent` is found.
        ExplodeEvent<public>:listenable(?agent) = external {}

        # Triggers whenever the plant launches a projectile.
        #  * Sends the `agent` that triggered this event.
        #  * Sends `false` if no `agent` is found.
        LaunchEvent<public>:listenable(?agent) = external {}

        # Enables the device to allow interaction and let it grow.
        Enable<public>():void = external {}

        # Disables the device to prevent interaction and growth.
        Disable<public>():void = external {}

        # Grows the plant if the device is enabled. If *Infinite Regrowths* is `false`, this is limited by *Maximum Regrowths*.
        Grow<public>():void = external {}

        # Detonates the plant if the device is enabled.
        Explode<public>():void = external {}

        # Sets whether the plant can always regrow after launching a projectile or being destroyed.
        SetInfiniteRegrowths<public>(InfiniteRegrowths:logic):void = external {}

        # Sets how many times the plant can regrow after launching a projectile or being destroyed.
        #  * This applies across the devices entire lifetime and is unaffected by *Enable* and *Disable*.
        #  * This value is clamped.
        SetMaximumRegrowths<public>(MaximumRegrowths:int):void = external {}

    using {/Verse.org/Colors}
    # Used to create a customizable vine version of the Grind Rails.
    vine_rail_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device, letting players grind on the vines.
        Enable<public>():void = external {}

        # Disables this device, preventing players from grinding on the vines.
        Disable<public>():void = external {}

        # Hides the track. Players can still grind on the track if it is enabled.
        Hide<public>():void = external {}

        # Make this track visible.
        Show<public>():void = external {}

        # Signaled when an `agent` starts grinding on this `vine_rail_device`.
        StartedGrindingEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` starts grinding on this `vine_rail_device`.
        EndedGrindingEvent<public>:listenable(agent) = external {}

    # Used to create customizable Grind Rails.
    grind_rail_device<public> := class<concrete><final>(creative_device_base):
        # Enables this device, letting players grind on the rail.
        Enable<public>():void = external {}

        # Disables this device, preventing players from grinding on the rail.
        Disable<public>():void = external {}

        # Sets the color of the Grind Rail.
        SetRailColor<public>(Color:color):void = external {}

        # Hides the track. Players can still grind on the track if it is enabled.
        Hide<public>():void = external {}

        # Make this track visible.
        Show<public>():void = external {}

        # Signaled when an `agent` starts grinding on this `grind_rail_device`.
        StartedGrindingEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` starts grinding on this `grind_rail_device`.
        EndedGrindingEvent<public>:listenable(agent) = external {}

    # Used to spawn various wildlife that players can herd, hunt, or tame.
    wildlife_spawner_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when this device spawns wildlife.
        # Sends the `agent` wildlife that was spawned.
        SpawnedEvent<public>:listenable(agent) = external {}

        # Signaled when wildlife is eliminated.
        # `Source` is the `agent` that eliminated the wildlife. If the wildlife was eliminated by a non-agent then `Source` is 'false'.
        # `Target` is the wildlife that was eliminated.
        EliminatedEvent<public>:listenable(device_ai_interaction_result) = external {}

        # Signaled when a wildlife eliminates an agent.
        # `Source` is the wildlife that eliminated the agent.
        # `Target` is the agent that was eliminated.
        EliminatingEvent<public>:listenable(device_ai_interaction_result) = external {}

        # Signaled when wildlife is tamed.
        # `Source` is the `agent` that tamed the wildlife.
        # `Target` is the wildlife that was tamed.
        TamedEvent<public>:listenable(device_ai_interaction_result) = external {}

        # Signaled when wildlife is untamed.
        # `Source` is the `agent` that tamed the wildlife.
        # `Target` is the wildlife that was untamed.
        UntamedEvent<public>:listenable(device_ai_interaction_result) = external {}

        # Signaled when wildlife is force-spawned and causes the oldest wildlife to be eliminated.
        # Sends the `agent` wildlife that was spawned.
        ForceSpawnedEvent<public>:listenable(agent) = external {}

        # Signaled when wildlife is damaged.
        # `Source` is the `agent` that damaged the wildlife. If the wildlife was damaged by a non-agent then `false` is returned.
        # `Target` is the wildlife that was damaged.
        DamagedEvent<public>:listenable(device_ai_interaction_result) = external {}

        # Signaled when wildlife eats a pickup such as a Shroom or Meat.
        #  Sends the wildlife that ate something.
        SomethingIsEatenEvent<public>:listenable(agent) = external {}

        # Signaled when an `agent` rides wildlife.
        # `Source` is the `agent` that started riding the wildlife.
        # `Target` is the wildlife that was ridden.
        RiddenEvent<public>:listenable(device_ai_interaction_result) = external {}

        # Signaled when an `agent` dismounts wildlife.
        # `Source` is the `agent` that dismounted the wildlife.
        # `Target` is the wildlife that was dismounted.
        DismountedEvent<public>:listenable(device_ai_interaction_result) = external {}

        # Enables this device.
        Enable<public>():void = external {}

        # Disables this device.
        Disable<public>():void = external {}

        # Resets the count on the *Total Spawn Count* option.
        Reset<public>():void = external {}

        # Spawns wildlife from this device.
        Spawn<public>():void = external {}

        # Despawns wildlife. `Agent` is marked as the one who eliminated the wildlife.
        Despawn<public>(Agent:agent):void = external {}

        # Destroys this device, marking `Agent` as the destroyer of the device.
        DestroySpawner<public>(Agent:agent):void = external {}

        # Tames wildlife, making them AI partners of `Agent`.
        Tame<public>(Agent:agent):void = external {}

        # Untames any tamed wildlife that belong to `Agent`.
        Untame<public>(Agent:agent):void = external {}

        # Untames all wildlife.
        UntameAll<public>():void = external {}

        # Teleports `Agent` to the nearest wildlife, then `Agent` mounts that wildlife.
        Ride<public>(Agent:agent):void = external {}

        # Dismounts `Agent` from wildlife.
        Dismount<public>(Agent:agent):void = external {}

        # Dismounts all `agent`s from wildlife.
        DismountAll<public>():void = external {}

        # Restores energy to wildlife belonging to `Agent` by *Energy Restore Amount*.
        RestoreEnergy<public>(Agent:agent):void = external {}

        # Restores energy to wildlife by *Energy Restore Amount*.
        RestoreEnergyForAll<public>():void = external {}

        # Consumes energy from wildlife belonging to `Agent` by *Energy Consume Amount*.
        ConsumeEnergy<public>(Agent:agent):void = external {}

        # Consumes energy from wildlife by *Energy Consume Amount*.
        ConsumeEnergyForAll<public>():void = external {}

        # Returns the spawn limit of the device.
        GetSpawnLimit<public>()<transacts>:int = external {}

    # Used to spawn NPCs made with Character Definition asset.
    npc_spawner_device<public> := class<concrete><final>(creative_device_base):
        # Signaled when a character is spawned.
        # Sends the `agent` character who was spawned.
        SpawnedEvent<public>:listenable(agent) = external {}

        # Signaled when a character is eliminated.
        # `Source` is the `agent` that eliminated the character. If the character was eliminated by a non-agent then `Source` is 'false'.
        # `Target` is the character that was eliminated.
        EliminatedEvent<public>:listenable(device_ai_interaction_result) = external {}

        # Enables this device. Characters will start to spawn.
        Enable<public>():void = external {}

        # Disables this device. Characters will despawn if *Despawn AIs When Disabled* is set.
        Disable<public>():void = external {}

        # Resets the spawn count allowing spawning of a new batch of characters.
        Reset<public>():void = external {}

        # Tries to spawn a character.
        Spawn<public>():void = external {}

        # Despawns all characters. If set, `Instigator` will be considered as the eliminator of those characters.
        DespawnAll<public>(Instigator:?agent):void = external {}

using {/Fortnite.com/Teams}
using {/Fortnite.com/Characters}
# Module import path: /Fortnite.com/Vehicles
Vehicles<public> := module:
    # Returns the `fort_vehicle` for `InCharacter`.
    # Fails if `InCharacter` is not associated with a `fort_vehicle`.
    (InCharacter:fort_character).GetVehicle<native><public>()<transacts><decides>:fort_vehicle

    # Main API implemented by Fortnite vehicles.
    fort_vehicle<native><public> := interface<unique><epic_internal>(positional, healthful, damageable, game_action_causer):
        # Succeeds if this `fort_vehicle` is standing on ground.
        IsOnGround<public>()<transacts><decides>:void

        # Succeeds if this `fort_vehicle` is standing in air.
        IsInAir<public>()<transacts><decides>:void

        # Succeeds if this `fort_vehicle` is standing in water.
        IsInWater<public>()<transacts><decides>:void

        # Returns an array with all the passengers of the vehicle.
        GetPassengers<public>():[]fort_character

# Module import path: /Fortnite.com/Teams
Teams<public> := module:
    # A generic set of team attitudes. Use this enum to model relationship behavior between your experience's agents/teams.
    team_attitude<native><public> := enum:
        # Agents/teams are friends. In Fortnite games two `agent`s on the same `team` are `friendly`.
        Friendly
        # Agents/teams are neutral. In Fortnite games items and AI not belonging to a `friendly` or `hostile` team are `neutral`.
        Neutral
        # Agents/teams are hostile. In fortnite games two `agent`s on opposing `team`s are `hostile`.
        Hostile

    # Collection used to manage `team`s and `agent`s on those teams.
    # Use `fort_playspace.GetTeamCollection()` to get the `team_collection` for the active experience.
    fort_team_collection<native><public> := interface:
        # Returns an array of all the `team`s known to this `fort_team_collection`
        GetTeams<public>()<transacts>:[]team

        # Adds `InAgent` to `InTeam`.
        # Fails if `InTeam` is not part of the `fort_team_collection`.
        AddToTeam<public>(InAgent:agent, InTeam:team)<transacts><decides>:void

        # Succeeds if `InAgent` is on `InTeam`.
        # Fails if:
        #  * `InAgent` is not on `InTeam`.
        #  * `InTeam` is not part of the `fort_team_collection`.
        IsOnTeam<public>(InAgent:agent, InTeam:team)<transacts><decides>:void

        # Returns an array of all `agent`s on `InTeam`.
        # Fails if `InTeam` is not part of the `fort_team_collection`.
        GetAgents<public>(InTeam:team)<transacts><decides>:[]agent

        # Get the `team` that `InAgent` is on.
        # Fails if `InAgent` is not on a team in this `fort_team_collection`.
        GetTeam<public>(InAgent:agent)<transacts><decides>:team

        # Returns the `team_attitude` between `Team1` and `Team2`.
        # Fails if:
        #  * `Team1` is not in this `fort_team_collection`.
        #  * `Team2` is not in this `fort_team_collection`.
        GetTeamAttitude<public>(Team1:team, Team2:team)<transacts><decides>:team_attitude

        # Returns the `team_attitude` between `Agent1` and `Agent2`.
        # Fails if:
        #  * `Agent1` is not on a team in this `fort_team_collection`.
        #  * `Agent2` is not on a team in this `fort_team_collection`.
        GetTeamAttitude<public>(Agent1:agent, Agent2:agent)<transacts><decides>:team_attitude

# Module import path: /Fortnite.com/Playspaces
Playspaces<public> := module:
    # A nested container that scopes objects, style, gameplay rules, visuals, etc. All objects and players in an experience will belong to a fort_playspace. There is typically one `fort_playspace` for an entire experience, though this may change in the future as the platform evolves.
    # 
    # To access the `fort_playspace` for a `creative_device` use `creative_device.GetPlayspace`.
    fort_playspace<native><public> := interface:
        # Get an `[]player`s in the current `fort_playspace`.
        GetPlayers<public>()<transacts>:[]player

        # Get the `fort_team_collection` for the current `fort_playspace`.
        GetTeamCollection<public>()<transacts>:fort_team_collection

        # Signaled when a `player` joins the `fort_playspace`. Returns a subscribable with a payload of the`fort_character` that entered the `fort_playspace`.
        PlayerAddedEvent<public>():listenable(player)

        # Signaled when a `player` leaves the `fort_playspace`. Returns a subscribable with a payload of the`fort_character` that left the `fort_playspace`.
        PlayerRemovedEvent<public>():listenable(player)

# Module import path: /Fortnite.com/Game
Game<public> := module:
    # Result data for `fort_character` elimination events.
    elimination_result<native><public> := struct<epic_internal>:
        # The `fort_character` eliminated from the match by `EliminatingCharacter`.
        EliminatedCharacter<native><public>:fort_character

        # `fort_character` that eliminated `EliminatedCharacter` from the match. `EliminatingCharacter` will be false when `EliminatedCharacter` was eliminated through non-character actions, such as environmental damage.
        EliminatingCharacter<native><public>:?fort_character

    # Implemented by objects to allow reading position information.
    positional<native><public> := interface<epic_internal>:
        # Returns the transform of the object.
        GetTransform<public>()<transacts>:transform

    # Implemented by Fortnite objects that have health state and can be eliminated.
    healthful<native><public> := interface<epic_internal>:
        # Returns the health state of the object. This value will between 0.0 and `GetMaxHealth`
        GetHealth<public>()<transacts>:float

        # Sets the health state of the object to `Health`.
        #  * Health state will be clamped between 1.0 and `GetMaxHealth`.
        #  * Health state cannot be directly set to 0.0. To eliminate `healthful` objects use the `damageable.Damage` functions instead.
        SetHealth<public>(Health:float)<transacts>:void

        # Returns the maximum health of the object. This value will be between 1.0 and Inf.
        GetMaxHealth<public>()<transacts>:float

        # Sets the maximum health state of the object.
        #  * MaxHealth will be clamped between 1.0 and Inf.
        #  * Current health state will be scaled up or down based on the scale difference between the old and new MaxHealth state.
        SetMaxHealth<public>(MaxHealth:float)<transacts>:void

    # Implemented by Fortnite objects that have shields. A shield is a method of protection that can take incoming damage while leaving the health state unchanged.
    shieldable<native><public> := interface<epic_internal>:
        # Returns the shield state of the object. This value will between 0.0 and `MaxShield`
        GetShield<public>()<transacts>:float

        # Sets the shield state of the object.
        #  * Shield state will be clamped between 0.0 and `MaxShield`.
        SetShield<public>(Shield:float)<transacts>:void

        # Returns the maximum shield state of the object. This value will be between 0.0 and Inf.
        GetMaxShield<public>()<transacts>:float

        # Sets the maximum shield state of the object.
        #  * MaxShield will be clamped between 0.0 and Inf.
        #  * Current shield state will be scaled up or down based on the scale difference between the old and new MaxShield state.
        SetMaxShield<public>(MaxShield:float)<transacts>:void

        # Signaled when the shield is damaged.
        DamagedShieldEvent<public>():listenable(damage_result)

        # Signaled when the shield is healed.
        HealedShieldEvent<public>():listenable(healing_result)

    # Implemented by Fortnite objects that can be damaged.
    damageable<native><public> := interface<epic_internal>:
        # Damage the `damageable` object anonymously by `Amount`. Setting `Amount` to less than 0 will cause no damage.
        # Use `Damage(:damage_args):void` when damage is being applied from a known instigator and source.
        Damage<public>(Amount:float):void

        # Damage the `damageable` object by `Args.Amount`. Setting `Amount` to less than 0 will cause no damage.
        Damage<public>(Args:damage_args):void

        # Signaled when damage is applied to the `damageable` object.
        DamagedEvent<public>():listenable(damage_result)

    # Implemented by Fortnite objects that can be healed.
    healable<native><public> := interface<epic_internal>:
        # Heal the `healable` object anonymously by `Amount`. Setting `Amount` to less than 0 will cause no healing.
        # Use `Heal(:healing_args):void` when healing is being applied from a known instigator and source.
        Heal<public>(Amount:float):void

        # Cause `Args.Amount` damage to the `damageable` object. Setting `Amount` to less than 0 will cause no damage.
        Heal<public>(Args:healing_args):void

        # Signaled when healing is applied to the `healable` object.
        HealedEvent<public>():listenable(healing_result)

    # Parameters for common damage functions on Fortnite objects.
    damage_args<native><public> := struct:
        # Player, agent, etc. that instigated the damage to the object.
        Instigator<native><public>:?game_action_instigator = external {}

        # Player, weapon, vehicle, etc. that damaged the object.
        Source<native><public>:?game_action_causer = external {}

        # Amount of damage to apply to the object.
        Amount<native><public>:float

    # Results for damage events on Fortnite objects.
    damage_result<native><public> := struct<epic_internal>:
        # Object that was damaged.
        Target<native><public>:damageable

        # Amount of damage applied to `Target`.
        Amount<native><public>:float

        # Player, agent, etc. that instigated the damage to `Target`. Can be false when damage is instigated by code, the environment, etc.
        Instigator<native><public>:?game_action_instigator = external {}

        # Player, weapon, vehicle, etc. that damaged `Target`. Can be false when damage is caused by code, the environment, etc.
        Source<native><public>:?game_action_causer = external {}

    # Parameters for common healing functions on Fortnite objects.
    healing_args<native><public> := struct:
        # Player, agents, etc. that instigated the healing of the object.
        Instigator<native><public>:?game_action_instigator = external {}

        # Player, weapon, vehicle, etc. that healed the object.
        Source<native><public>:?game_action_causer = external {}

        # Amount of healing to apply to the object.
        Amount<native><public>:float

    # Results for healing events on Fortnite objects.
    healing_result<native><public> := struct<epic_internal>:
        # Object that was healed.
        Target<native><public>:healable

        # Amount of healing applied to `Target`.
        Amount<native><public>:float

        # Player, agent, etc. that instigated healing of the `Target`. Can be false when damage is instigated by code, the environment, etc.
        Instigator<native><public>:?game_action_instigator = external {}

        # Player, weapon, vehicle, etc. that healed `Target`. Can be false when damage is caused by code, the environment, etc.
        Source<native><public>:?game_action_causer = external {}

    # Implemented by Fortnite objects that initiate game actions, such as damage and heal. For example, player or agents.
    # Event listeners often use `game_action_instigators` to calculate player damage scores.
    game_action_instigator<native><public> := interface<epic_internal>:

    # Implemented by Fortnite objects that can be passed through game action events, such as damage and heal.
    # For example: player, vehicle, or weapon.
    # 
    # Event Listeners often use `game_action_causer` to pass along additional information about what weapon caused the damage.
    # Systems will then use that information for completing quests or processing game specific event logic.
    game_action_causer<native><public> := interface:

# Module import path: /Fortnite.com/FortPlayerUtilities
FortPlayerUtilities<public> := module:
    # Sends `InPlayer` back to the main game lobby.
    (InPlayer:player).SendToLobby<native><public>()<transacts>:void

    # Succeeds if `InPlayer` is spectating the experience. Fails otherwise.
    (InPlayer:player).IsSpectator<native><public>()<transacts><decides>:void

    # Returns an `[]player`s currently spectating `InPlayer`.
    (InPlayer:player).GetPlayersSpectating<native><public>()<transacts>:[]player

    # Respawns the character for `InAgent` at the provided `RespawnPosition` and applies the yaw of `RespawnRotation`.
    (InAgent:agent).Respawn<native><public>(RespawnPosition:vector3, RespawnRotation:rotation)<transacts>:void

# Module import path: /Fortnite.com/Characters
Characters<public> := module:
    # Main API implemented by Fortnite characters.
    fort_character<native><public> := interface<unique><epic_internal>(positional, healable, healthful, damageable, shieldable, game_action_instigator, game_action_causer):
        # Returns the agent associated with this `fort_character`. Use this when interacting with APIs that require an `agent` reference.
        GetAgent<public>()<transacts><decides>:agent

        # Signaled when this `fort_character` is eliminated from the match.
        EliminatedEvent<public>():listenable(elimination_result)

        # Returns the rotation where this `fort_character` is looking or aiming at.
        GetViewRotation<public>()<transacts>:rotation

        # Returns the location where this `fort_character` is looking or aiming from.
        GetViewLocation<public>()<transacts>:vector3

        # Signaled when this `fort_character` jumps. Returns a listenable with a payload of this `fort_character`.
        JumpedEvent<public>():listenable(fort_character)

        # Signaled when this `fort_character` changes crouch state.
        # Sends `tuple` payload:
        #  - 0: the `fort_character` that changed crouch states.
        #  - 1: `true` if the character is crouching. `false` if the character is not crouching.
        CrouchedEvent<public>():listenable(tuple(fort_character, logic))

        # Signaled when this `fort_character` changes sprint state.
        # Sends `tuple` payload:
        #  - 0: the `fort_character` that changed sprint state.
        #  - 1: `true` if the character is sprinting. `false` if the character stopped sprinting.
        SprintedEvent<public>():listenable(tuple(fort_character, logic))

        # Succeeds if this `fort_character` is in the world and has not been eliminated. Most fort_character actions will silently fail if this fails. Please test IsActive if you want to handle these failure cases rather than allow them to silently fail.
        IsActive<public>()<transacts><decides>:void

        # Succeeds if this `fort_character` is in the 'Down But Not Out' state. In this state the character is down but can still be revived by teammates for a period of time.
        IsDownButNotOut<public>()<transacts><decides>:void

        # Succeeds if this `fort_character` is crouching.
        IsCrouching<public>()<transacts><decides>:void

        # Succeeds if this `fort_character` is standing on the ground.
        IsOnGround<public>()<transacts><decides>:void

        # Succeeds if this `fort_character` is standing in the air.
        IsInAir<public>()<transacts><decides>:void

        # Succeeds if this `fort_character` is inside water volume.
        IsInWater<public>()<transacts><decides>:void

        # Succeeds if this `fort_character` is in falling locomotion state.
        IsFalling<public>()<transacts><decides>:void

        # Succeeds if this `fort_character` is in gliding locomotion state.
        IsGliding<public>()<transacts><decides>:void

        # Succeeds if this `fort_character` is in flying locomotion state.
        IsFlying<public>()<transacts><decides>:void

        # Puts this `fort_character` into stasis, preventing certain types of movement specified by `Args`.
        PutInStasis<public>(Args:stasis_args)<transacts>:void

        # Release this `fort_character` from stasis.
        ReleaseFromStasis<public>()<transacts>:void

        # Sets this `fort_character` visibility to visible.
        Show<public>():void

        # Sets this `fort_character` visibility to invisible.
        Hide<public>():void

        # Control if this `fort_character` can be damaged.
        SetVulnerability<public>(Vulnerable:logic)<transacts>:void

        # Succeeds if this `fort_character` can be damaged. Fails if this `fort_character` cannot be damaged.
        IsVulnerable<public>()<transacts><decides>:void

        # Teleports this `fort_character` to the provided `Position` and applies the yaw of `Rotation`. Will fail if the `Position` specified is e.g. outside of the playspace or specifies a place where the character cannot fit.
        TeleportTo<public>(Position:vector3, Rotation:rotation)<transacts><decides>:void

    # Returns the `fort_character` for `InAgent`. Fails if `InAgent` is not a `fort_character`.
    (InAgent:agent).GetFortCharacter<native><public>()<transacts><decides>:fort_character

    # Returns a `game_action_instigator` interface for `InAgent`.
    (InAgent:agent).GetInstigator<native><public>()<transacts>:game_action_instigator

    # Returns the `agent` for `InInstigator`. Fails if `InInstigator` is not an `agent`.
    (InInstigator:game_action_instigator).GetInstigatorAgent<native><public>()<transacts><decides>:agent

    # Parameters for `fort_character.PutInStasis` function.
    stasis_args<native><public> := struct:
        # Controls if `fort_character` can still turn while in stasis.
        AllowTurning<native><public>:logic = external {}

        # Controls if `fort_character` can still fall while in stasis.
        AllowFalling<native><public>:logic = external {}

        # Controls if `fort_character` can still perform emotes while in stasis.
        AllowEmotes<native><public>:logic = external {}

# Module import path: /Fortnite.com/Assets
Assets<public> := module:

# Module import path: /Fortnite.com/Animation
Animation<public> := module:
    # Module import path: /Fortnite.com/Animation/PlayAnimation
    PlayAnimation<public> := module:
        # Result of a PlayAndAwait request.
        play_animation_result<native><public> := enum:
            # The animation completed successfully.
            Completed
            # The animation was interrupted whilst playing.
            Interrupted
            # The animation encountered an error during initialization or whilst playing.
            Error

        # An interface for playing an animation on an object.
        play_animation_controller<native><public> := interface:
            # Play an animation sequence.
            PlayAndAwait<public>(AnimationSequence:animation_sequence, ?PlayRate:float = external {}, ?StartPositionSeconds:float = external {}, ?BlendInTime:float = external {}, ?BlendOutTime:float = external {})<suspends>:play_animation_result

            # Start an animation sequence and obtain an instance to query and manipulate.
            Play<public>(AnimationSequence:animation_sequence, ?PlayRate:float = external {}, ?StartPositionSeconds:float = external {}, ?BlendInTime:float = external {}, ?BlendOutTime:float = external {}):play_animation_instance

        # An animation instance created from play_animation_controller.Play that can be queried and manipulated.
        play_animation_instance<native><public> := class<epic_internal>:
            # Returns the state of the animation playback.
            GetState<native><public>()<transacts>:play_animation_state

            # Stops the animation.
            Stop<native><public>():void

            # Event triggered when the animation is completed.
            CompletedEvent<native><public>:listenable(tuple()) = external {}

            # Event triggered when the animation is interrupted.
            InterruptedEvent<native><public>:listenable(tuple()) = external {}

            # Event triggered when the animation has finished to blend out.
            BlendedInEvent<native><public>:listenable(tuple()) = external {}

            # Event triggered when the animation is beginning to blend out.
            BlendingOutEvent<native><public>:listenable(tuple()) = external {}

            # Helper function that waits for the animation to complete or be interrupted.
            Await<public>()<suspends>:play_animation_result = external {}

            # Helper function that succeeds if the state is Playing, BlendingIn, or BlendingOut.
            IsPlaying<public>()<transacts><decides>:void = external {}

        # The potential states of a play animation instance.
        play_animation_state<native><public> := enum:
            # The animation is blending in.
            BlendingIn
            # The animation has blended in, is playing, and has not begun blending out.
            Playing
            # The animation is playing and is blending out.
            BlendingOut
            # The animation completed successfully.
            Completed
            # The animation was stopped internally.
            Stopped
            # The animation was interrupted externally.
            Interrupted
            # An error occurred at creation or during playback.
            Error

        # Get the play_animation_controller for the specified character.
        (InCharacter:fort_character).GetPlayAnimationController<native><public>()<transacts><decides>:play_animation_controller

# Module import path: /Fortnite.com/AI
AI<public> := module:
    focus_interface<native><public> := interface:
        # Look At specified location. Will never complete unless interrupted.
        MaintainFocus<public>(Location:vector3)<suspends>:void

        # Look At specified Agent. Will never complete unless interrupted.
        MaintainFocus<public>(Agent:agent)<suspends>:void

    # Get the focus_interface interface for the specified character.
    (InCharacter:fort_character).GetFocusInterface<native><public>()<transacts><decides>:focus_interface

    fort_leashable<native><public> := interface:
        # Set custom leash position.
        #  'InnerRadius' ranges from 0.0 to 20000.0 (in centimeters).
        #  'OuterRadius' ranges from 0.0 to 20000.0 (in centimeters) and no less than 'InnerRadius'.
        SetLeashPosition<public>(Location:vector3, InnerRadius:float, OuterRadius:float):void

        # Set the agent to be the new center of the leash.
        #  'InnerRadius' ranges from 0.0 to 20000.0 (in centimeters).
        #  'OuterRadius' ranges from 0.0 to 20000.0 (in centimeters) and no less than 'InnerRadius'.
        SetLeashAgent<public>(Agent:agent, InnerRadius:float, OuterRadius:float):void

        # Removes the current leash.
        ClearLeash<public>():void

    # Get the current fort_leashable interface for the specified character.
    (InCharacter:fort_character).GetFortLeashable<native><public>()<transacts><decides>:fort_leashable

    navigation_target<native><public> := class<epic_internal>:

    # Generate a navigation_target from any position
    MakeNavigationTarget<constructor><native><public>(Position:vector3):navigation_target

    # Generate a navigation_target from an agent
    MakeNavigationTarget<constructor><native><public>(Target:agent):navigation_target

    # Result of a navigation request
    navigation_result<native><public> := enum:
        # The destination has been reached
        Reached
        # The destination has been partially reached (AllowPartialPath was used)
        PartiallyReached
        # Navigation has been interrupted before completion
        Interrupted
        # The navigating agent is blocked
        Blocked
        # The destination cannot be reached
        Unreachable

    navigatable<native><public> := interface:
        # Return the current destination of the NPC
        GetCurrentDestination<public>()<transacts><decides>:vector3

        # Navigate toward the specified target
        NavigateTo<public>(Target:navigation_target, ?ReachRadius:float = external {}, ?AllowPartialPath:logic = external {})<suspends>:navigation_result

        # Stop navigation
        StopNavigation<public>():void

        # Wait for a specific duration
        Wait<public>(?Duration:float = external {})<suspends>:void

    # Get the navigatable interface for the specified character.
    (InCharacter:fort_character).GetNavigatable<native><public>()<transacts><decides>:navigatable

    # Inherit from this to create a custom NPC behavior.
    # The npc_behavior can be defined for a character in a CharacterDefinition asset, or in a npc_spawner_device.
    npc_behavior<native><public> := class<abstract>:
        # This function is called when the NPC is added to the simulation.
        OnBegin<native_callable><public>()<suspends>:void = external {}

        # This function is called when the NPC is removed from the simulation.
        OnEnd<native_callable><public>():void = external {}

        # Returns the agent associated with this behavior.
        GetAgent<native><public>()<transacts><decides>:agent

    # Returns the `npc_behavior` for `InAgent`.
    (InAgent:agent).GetNPCBehavior<native><public>()<transacts><decides>:npc_behavior


# End of file: Fortnite.digest.verse


# File: C:\Users\chrisromp\dev\verse-examples\Good To Know Scripts\ConvertingMaybeAgent.verse
using { /Fortnite.com/Characters }
using { /Fortnite.com/UI }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Colors }
using { /Verse.org/Random }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/UI }
using { /Fortnite.com/Game }

#    _______ .______    __  .__   __.  _______ .______   .__   __.     ______ .______    _______     ___   .___________. _______     _____.
#   /  _____||   _  \  |  | |  \ |  | |   ____||   _  \  |  \ |  |    /      ||   _  \  |   ____|   /   \  |           ||   ____|   /     |
#  |  |  __  |  |_)  | |  | |   \|  | |  |__   |  |_)  | |   \|  |   |  ,----'|  |_)  | |  |__     /  ^  \ `---|  |----`|  |__     |   (--`
#  |  | |_ | |      /  |  | |  . `  | |   __|  |      /  |  . `  |   |  |     |      /  |   __|   /  /_\  \    |  |     |   __|     \   \  
#  |  |__| | |  |\  \-.|  | |  |\   | |  |____ |  |\  \-.|  |\   |   |  `----.|  |\  \-.|  |____ /  _____  \   |  |     |  |____  .--)   | 
#   \______| | _| `.__||__| |__| \__| |_______|| _| `.__||__| \__|    \______|| _| `.__||_______/__/     \__\  |__|     |_______| |_____/  
                                                                                                                                         
#Discord: @Grinern
#Twitter: @GrinernCreates
#Youtube: @GrinernCreates

ConvertingMaybeAgent := class(creative_device):

    #In some cases devices do not listen to Agents but instead ?agent.

    @editable
    ElimManager: elimination_manager_device = elimination_manager_device{}

    OnBegin<override>()<suspends>:void=
        Print("@GrinernCreates Script Started")
        ElimManager.EliminationEvent.Subscribe(NextWeapon)

    NextWeapon(MaybeAgent:?agent):void=
        if(Agent := MaybeAgent?): # Here is the work around (Basically if the maybe agent is "real" you are allowed to use the Agent.)
            ItemGranter.CycleToNextItem(Agent)

# End of file: ConvertingMaybeAgent.verse


# File: C:\Users\chrisromp\dev\verse-examples\Object Manipulation Scripts\object_follow_player.verse
using { /Fortnite.com/Characters }
using { /Fortnite.com/UI }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Colors }
using { /Verse.org/Random }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/UI }
using { /Fortnite.com/Game }

#    _______ .______    __  .__   __.  _______ .______   .__   __.     ______ .______    _______     ___   .___________. _______     _____.
#   /  _____||   _  \  |  | |  \ |  | |   ____||   _  \  |  \ |  |    /      ||   _  \  |   ____|   /   \  |           ||   ____|   /     |
#  |  |  __  |  |_)  | |  | |   \|  | |  |__   |  |_)  | |   \|  |   |  ,----'|  |_)  | |  |__     /  ^  \ `---|  |----`|  |__     |   (--`
#  |  | |_ | |      /  |  | |  . `  | |   __|  |      /  |  . `  |   |  |     |      /  |   __|   /  /_\  \    |  |     |   __|     \   \  
#  |  |__| | |  |\  \-.|  | |  |\   | |  |____ |  |\  \-.|  |\   |   |  `----.|  |\  \-.|  |____ /  _____  \   |  |     |  |____  .--)   | 
#   \______| | _| `.__||__| |__| \__| |_______|| _| `.__||__| \__|    \______|| _| `.__||_______/__/     \__\  |__|     |_______| |_____/  
                                                                                                                                         
#Discord: @Grinern
#Twitter: @GrinernCreates
#Youtube: @GrinernCreates

object_follow_player := class(creative_device):

    # Change this to the object (Could legit be anything.)
    @editable
    ObjectToMove: button_device = button_device{}

    @editable
    smoothFactor: float = 0.20
 
    # Could change this to be another way of triggering.
    @editable
    SpecificPlayerSpawner: player_spawner_device = player_spawner_device{}
 
    var Agents : []agent = array{}
    OnBegin<override>()<suspends>:void=
        Print("@GrinernCreates Script Started")
        SpecificPlayerSpawner.SpawnedEvent.Subscribe(SpawnEvent)
 
    MoveObjectV2(Agent : agent)<suspends> : void =
        if (InitialCharacter : fort_character = Agent.GetFortCharacter[]):
            PlayerPosition := InitialCharacter.GetTransform().Translation
 
            loop:
                var targetX: float = PlayerPosition.X
                var targetY: float = PlayerPosition.Y
                var targetZ: float = PlayerPosition.Z
                var ObjectToMoveXform : float = ObjectToMove.GetTransform().Translation.X
                var ObjectToMoveYform : float = ObjectToMove.GetTransform().Translation.Y
                var ObjectToMoveZform : float = ObjectToMove.GetTransform().Translation.Z
 
                var newObjectToMoveZ: float = ObjectToMoveZform + (targetZ - ObjectToMoveZform) * smoothFactor
 
                Arrived := race:
                    block:
                        ObjectToMove.MoveTo(vector3{X:= targetX, Y:=targetY, Z:= newObjectToMoveZ}, MakeRotationFromYawPitchRollDegrees(0.00, 0.00, 0.00), 0.2)
                        true
                    block:
                        Sleep(0.25)
                        set ObjectToMoveXform = ObjectToMove.GetTransform().Translation.X
                        set ObjectToMoveYform = ObjectToMove.GetTransform().Translation.Y
                        set ObjectToMoveZform = ObjectToMove.GetTransform().Translation.Z
                        false
                if(not Arrived?, ObjectToMove.TeleportTo[vector3{X:= ObjectToMoveXform, Y:= ObjectToMoveYform, Z:= ObjectToMoveZform},MakeRotationFromYawPitchRollDegrees(0.00, 0.00, 0.00)]):
                    Sleep(0.0)
                    Sleep(0.0)
                else:
                    break
 
    FollowCharacter(Agent:agent)<suspends>:void = 
        loop:
            MoveObjectV2(Agent)
 
    SpawnEvent(Agent:agent):void =
        spawn:
            FollowCharacter(Agent)

# End of file: object_follow_player.verse


# File: C:\Users\chrisromp\dev\verse-examples\Object Manipulation Scripts\random_system.verse
using { /Fortnite.com/Characters }
using { /Fortnite.com/UI }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Colors }
using { /Verse.org/Random }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/UI }
using { /Fortnite.com/Game }

#    _______ .______    __  .__   __.  _______ .______   .__   __.     ______ .______    _______     ___   .___________. _______     _____.
#   /  _____||   _  \  |  | |  \ |  | |   ____||   _  \  |  \ |  |    /      ||   _  \  |   ____|   /   \  |           ||   ____|   /     |
#  |  |  __  |  |_)  | |  | |   \|  | |  |__   |  |_)  | |   \|  |   |  ,----'|  |_)  | |  |__     /  ^  \ `---|  |----`|  |__     |   (--`
#  |  | |_ | |      /  |  | |  . `  | |   __|  |      /  |  . `  |   |  |     |      /  |   __|   /  /_\  \    |  |     |   __|     \   \  
#  |  |__| | |  |\  \-.|  | |  |\   | |  |____ |  |\  \-.|  |\   |   |  `----.|  |\  \-.|  |____ /  _____  \   |  |     |  |____  .--)   | 
#   \______| | _| `.__||__| |__| \__| |_______|| _| `.__||__| \__|    \______|| _| `.__||_______/__/     \__\  |__|     |_______| |_____/  
                                                                                                                                         
#Discord: @Grinern
#Twitter: @GrinernCreates
#Youtube: @GrinernCreates

random_event := class(creative_device):
 
    @editable
    ConditionalButton: conditional_button_device = conditional_button_device{}
 
    @editable
    Event1: cinematic_sequence_device = cinematic_sequence_device{}
 
    @editable
    Event2: cinematic_sequence_device = cinematic_sequence_device{}
 
    @editable
    Event3: cinematic_sequence_device = cinematic_sequence_device{}
 
    @editable
    Event4: cinematic_sequence_device = cinematic_sequence_device{}
 
    @editable
    Event5: cinematic_sequence_device = cinematic_sequence_device{}
 
    @editable
    Timer1: timer_device = timer_device{}
 
    @editable
    Timer2: timer_device = timer_device{}
 
    @editable
    Timer3: timer_device = timer_device{}
 
    @editable
    Timer4: timer_device = timer_device{}
 
    @editable
    Timer5: timer_device = timer_device{}

    OnBegin<override>()<suspends >:void=
        Print("@GrinernCreates Script Started")
        ConditionalButton.ActivatedEvent.Subscribe(OnButtonClick)
 
    OnButtonClick(Agent:agent):void=
        spawn:
            ConditionalButtonActivated(Agent)
 
    ConditionalButtonActivated(Agent:agent)<suspends>:void=
        var RandomEvent:int = GetRandomInt(1, 5)

        #Could use cases instead (This is one of the oldest scripts I made)
        if (RandomEvent = 1):
            Event1.Play()
            ConditionalButton.Disable()
            Print("Event 1 playing")
            Timer1.Start()
            Sleep(120.0)
            Event1.GoToEndAndStop()
            ConditionalButton.Enable()
 
        else if (RandomEvent = 2):
            Event2.Play()
            ConditionalButton.Disable()
            Print("Event 2 playing")
            Timer2.Start()
            Sleep(120.0)
            Event2.GoToEndAndStop()
            ConditionalButton.Enable()
 
        else if (RandomEvent = 3):
            Event3.Play()
            ConditionalButton.Disable()
            Print("Event 3 playing")
            Timer3.Start()
            Sleep(120.0)
            Event3.GoToEndAndStop()
            ConditionalButton.Enable()
 
        else if (RandomEvent = 4):
            Event4.Play()
            ConditionalButton.Disable()
            Print("Event 4 playing")
            Timer4.Start()
            Sleep(120.0)
            Event4.GoToEndAndStop()
            ConditionalButton.Enable()
 
        else if (RandomEvent = 5):
            Event5.Play()
            ConditionalButton.Disable()
            Print("Event 5 playing")
            Timer5.Start()
            Sleep(120.0)
            Event5.GoToEndAndStop()
            ConditionalButton.Enable()

# End of file: random_system.verse


# File: C:\Users\chrisromp\dev\verse-examples\Object Manipulation Scripts\random_teleporter.verse
using { /Fortnite.com/Characters }
using { /Fortnite.com/UI }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Colors }
using { /Verse.org/Random }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/UI }
using { /Fortnite.com/Game }

#    _______ .______    __  .__   __.  _______ .______   .__   __.     ______ .______    _______     ___   .___________. _______     _____.
#   /  _____||   _  \  |  | |  \ |  | |   ____||   _  \  |  \ |  |    /      ||   _  \  |   ____|   /   \  |           ||   ____|   /     |
#  |  |  __  |  |_)  | |  | |   \|  | |  |__   |  |_)  | |   \|  |   |  ,----'|  |_)  | |  |__     /  ^  \ `---|  |----`|  |__     |   (--`
#  |  | |_ | |      /  |  | |  . `  | |   __|  |      /  |  . `  |   |  |     |      /  |   __|   /  /_\  \    |  |     |   __|     \   \  
#  |  |__| | |  |\  \-.|  | |  |\   | |  |____ |  |\  \-.|  |\   |   |  `----.|  |\  \-.|  |____ /  _____  \   |  |     |  |____  .--)   | 
#   \______| | _| `.__||__| |__| \__| |_______|| _| `.__||__| \__|    \______|| _| `.__||_______/__/     \__\  |__|     |_______| |_____/  
                                                                                                                                         
#Discord: @Grinern
#Twitter: @GrinernCreates
#Youtube: @GrinernCreates

random_teleporter := class(creative_device):

    @editable
    Teleporters: []teleporter_device = array{}

    #Could be changed to pretty much anything tbh. As long as there is a listenable Agent.
    @editable
    EnterRandomTeleporter: mutator_zone_device = mutator_zone_device{}

    OnBegin<override>()<suspends>:void=
        Print("@GrinernCreates Script Started")
        EnterRandomTeleporter.AgentEntersEvent.Subscribe(EnterEvent)

    EnterEvent(Agent:agent):void=
        var RandomTeleporter:int = GetRandomInt(1, 21) # CHANGE THIS TO THE NUMBER OF TELEPORTERS
        if(SelectedTeleporter := Teleporters[RandomTeleporter]):
            SelectedTeleporter.Teleport(Agent)

# End of file: random_teleporter.verse


# File: C:\Users\chrisromp\dev\verse-examples\Object Manipulation Scripts\CrateSystem\CrateController.verse
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/SpatialMath }

CrateController<public> := class<unique><concrete>():

    @editable Button : button_device = button_device{}
    @editable Waypoint : beacon_device = beacon_device{}
    @editable Reward : item_granter_device = item_granter_device{}
    _CrateService : CrateService = CrateService{}

    Initialize():void=
        Button.InteractedWithEvent.Subscribe(HandleInteractedWithEvent)
        buttonTransform := Button.GetTransform().Translation
        if(Waypoint.TeleportTo[vector3{X:=buttonTransform.X, Y:=buttonTransform.Y, Z:= buttonTransform.Z}, IdentityRotation()]):

    HandleInteractedWithEvent(Agent:agent):void=
        _CrateService.HandleEvent(Agent, Reward)
        Button.Disable()
        Waypoint.Disable()

# End of file: CrateController.verse


# File: C:\Users\chrisromp\dev\verse-examples\Object Manipulation Scripts\CrateSystem\CrateService.verse
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }

CrateService<public> := class<unique><concrete>():

    HandleEvent(Agent: agent, Reward: item_granter_device): void =
        Reward.GrantItem(Agent)

# End of file: CrateService.verse


# File: C:\Users\chrisromp\dev\verse-examples\Object Manipulation Scripts\CrateSystem\GameManager.verse
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }

GameManager := class(creative_device):

    @editable _CrateController : []CrateController = array {}

    OnBegin<override>()<suspends>:void=
        Print("@GrinernCreates")

        for(crate : _CrateController):
            crate.Initialize()

# End of file: GameManager.verse


# File: C:\Users\chrisromp\dev\verse-examples\Player Manipulation Scripts\get_closest_player.verse
using { /Fortnite.com/Characters }
using { /Fortnite.com/UI }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Colors }
using { /Verse.org/Random }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/UI }
using { /Fortnite.com/Game }

#    _______ .______    __  .__   __.  _______ .______   .__   __.     ______ .______    _______     ___   .___________. _______     _____.
#   /  _____||   _  \  |  | |  \ |  | |   ____||   _  \  |  \ |  |    /      ||   _  \  |   ____|   /   \  |           ||   ____|   /     |
#  |  |  __  |  |_)  | |  | |   \|  | |  |__   |  |_)  | |   \|  |   |  ,----'|  |_)  | |  |__     /  ^  \ `---|  |----`|  |__     |   (--`
#  |  | |_ | |      /  |  | |  . `  | |   __|  |      /  |  . `  |   |  |     |      /  |   __|   /  /_\  \    |  |     |   __|     \   \  
#  |  |__| | |  |\  \-.|  | |  |\   | |  |____ |  |\  \-.|  |\   |   |  `----.|  |\  \-.|  |____ /  _____  \   |  |     |  |____  .--)   | 
#   \______| | _| `.__||__| |__| \__| |_______|| _| `.__||__| \__|    \______|| _| `.__||_______/__/     \__\  |__|     |_______| |_____/  
                                                                                                                                         
#Discord: @Grinern
#Twitter: @GrinernCreates
#Youtube: @GrinernCreates

get_closest_player := class(creative_device):

    OnBegin<override>()<suspends>:void=
        Print("@GrinernCreates Script Started")

    GetClosestPlayerToViewpoint(AllPlayers: []player, Viewpoint:vector3, InitialCharacter: fort_character): fort_character =
        var ClosestCharacter : fort_character = InitialCharacter
        var ClosestDistance: float = 1000000000.0
        for (Player : AllPlayers):
            if (FNCharacter : fort_character = Player.GetFortCharacter[]):
                if (FNCharacter <> InitialCharacter):
                    PlayerLocation := FNCharacter.GetTransform().Translation
                    EDistance := Distance(Viewpoint, PlayerLocation)
                    if (EDistance < ClosestDistance):
                        set ClosestCharacter = FNCharacter
                        set ClosestDistance = EDistance
        return ClosestCharacter

# End of file: get_closest_player.verse


# File: C:\Users\chrisromp\dev\verse-examples\Player Manipulation Scripts\instant_spawn.verse
using { /Fortnite.com/Characters }
using { /Fortnite.com/UI }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Colors }
using { /Verse.org/Random }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/UI }
using { /Fortnite.com/Game }

#    _______ .______    __  .__   __.  _______ .______   .__   __.     ______ .______    _______     ___   .___________. _______     _____.
#   /  _____||   _  \  |  | |  \ |  | |   ____||   _  \  |  \ |  |    /      ||   _  \  |   ____|   /   \  |           ||   ____|   /     |
#  |  |  __  |  |_)  | |  | |   \|  | |  |__   |  |_)  | |   \|  |   |  ,----'|  |_)  | |  |__     /  ^  \ `---|  |----`|  |__     |   (--`
#  |  | |_ | |      /  |  | |  . `  | |   __|  |      /  |  . `  |   |  |     |      /  |   __|   /  /_\  \    |  |     |   __|     \   \  
#  |  |__| | |  |\  \-.|  | |  |\   | |  |____ |  |\  \-.|  |\   |   |  `----.|  |\  \-.|  |____ /  _____  \   |  |     |  |____  .--)   | 
#   \______| | _| `.__||__| |__| \__| |_______|| _| `.__||__| \__|    \______|| _| `.__||_______/__/     \__\  |__|     |_______| |_____/  
                                                                                                                                         
#Discord: @Grinern
#Twitter: @GrinernCreates
#Youtube: @GrinernCreates

instant_spawn := class(creative_device):

    respawnposition: vector3=vector3{X:=0.0,Y:=0.0,Z:=0.0} # Change this to the actual respawn point coordinates.

    @editable
    ElimManager: elimination_manager_device = elimination_manager_device{}

    OnBegin<override>()<suspends>:void=
        Print("@GrinernCreates Script Started")
        ElimManager.EliminatedEvent.Subscribe(OnEliminated)

    OnEliminated(Agent:agent):void=
        spawn:
            RespawnEvent(Agent)

    RespawnEvent(Agent:agent)<suspends>:void=
        Sleep(0.1)
        Agent.Respawn(respawnposition,rotation{})

# End of file: instant_spawn.verse


# File: C:\Users\chrisromp\dev\verse-examples\Player Manipulation Scripts\Persistence\DebugUtil.verse
using { /UnrealEngine.com/Temporary/Diagnostics }
 
log_class := class(log_channel){}
 
DebugUtil<public> := class<unique><concrete>():
 
    Logger : log = log{Channel := log_class}
 
    # Prints in your log ingame and has a "Debug:" before it
    Debug(String:string):void=
        Logger.Print("{String}", ?Level := log_level.Debug)
 
    # Prints both ingame and output log and acts like your normal Print() function
    Log(String:string):void=
        Logger.Print("{String}", ?Level := log_level.Normal)
 
    # Prints both ingame and output log, is yellow and has a "Warning:" before it
    Warning(String:string):void=
        Logger.Print("{String}", ?Level := log_level.Warning)
 
    # Prints both ingame and output log, is red and has a "Error:" before it
    Error(String:string):void=
        Logger.Print("{String}", ?Level := log_level.Error)

# End of file: DebugUtil.verse


# File: C:\Users\chrisromp\dev\verse-examples\Player Manipulation Scripts\Persistence\GameManager.verse

using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }

GameManager := class(creative_device):
    
    _PlayerRepository : PlayerRepository = PlayerRepository{}
    
    _DebugUtil : DebugUtil = DebugUtil{}

    # Editable properties for manipulating stats
    @editable IncrementStatButton : button_device = button_device{}
    @editable DecrementStatButton : button_device = button_device{}
    @editable SetStatButton : button_device = button_device{}
    @editable ShowStatsButton : button_device = button_device{}

    OnBegin<override>()<suspends>:void=
        _DebugUtil.Log("@GrinernCreates")
        AllPlayers:[]player = GetPlayspace().GetPlayers()
        for(Player:AllPlayers):
            _PlayerRepository.InitializePlayer(Player)
        IncrementStatButton.InteractedWithEvent.Subscribe(IncrementStat)
        DecrementStatButton.InteractedWithEvent.Subscribe(DecrementStat)
        SetStatButton.InteractedWithEvent.Subscribe(SetStat)
        ShowStatsButton.InteractedWithEvent.Subscribe(ShowStats)

    IncrementStat(Agent:agent):void=
        _PlayerRepository.SaveDataAsInt(Agent, stat.Money, manipulationType.Increment, 17)

    DecrementStat(Agent:agent):void=
        _PlayerRepository.SaveDataAsInt(Agent, stat.Money, manipulationType.Decrement, 5)

    SetStat(Agent:agent):void=
        _PlayerRepository.SaveDataAsInt(Agent, stat.Money, manipulationType.Set, 934)

    ShowStats(Agent:agent):void=
        _DebugUtil.Log("{_PlayerRepository.GetDataAsInt(Agent, stat.Money)}")

# End of file: GameManager.verse


# File: C:\Users\chrisromp\dev\verse-examples\Player Manipulation Scripts\Persistence\PlayerLibrary.verse
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/UI }

# Define a weak map to store player stats, mapping a player to their stats table
var PlayerStatsMap:weak_map(player, player_stats_table) = map{}

# Define an enum for different stats
stat := enum:
    Example
    Money

# Define an enum for different manipulation types
manipulationType := enum:
    Increment
    Decrement
    Set

# Function to convert a stat enum to a string representation
statTypeToString(State: stat)<computes>:string=
    case(State):
        stat.Example => "Example"
        stat.Money => "Money"
        
# Function to convert a manipulation type enum to a string representation
manipulationTypeToString(State: manipulationType)<computes>:string=
    case(State):
        manipulationType.Increment => "Increment"
        manipulationType.Decrement => "Decrement"
        manipulationType.Set => "Set"

# End of file: PlayerLibrary.verse


# File: C:\Users\chrisromp\dev\verse-examples\Player Manipulation Scripts\Persistence\PlayerRepository.verse
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }

PlayerRepository<public> := class<unique><concrete>():

    _PlayerService: PlayerService = PlayerService{}
    _DebugUtil : DebugUtil = DebugUtil{}

    InitializePlayer(Player:player):void=
        _PlayerService.InitializePlayer(Player)

    # Method to save data for a given agent
    SaveDataAsInt(Agent: agent, Stat: stat, Manipulation: manipulationType, Amount: int): void =
        StatActions := map{
            stat.Example => StatType.Example
            stat.Money => StatType.Money
        }
    
        ManipulationActions := map{
            manipulationType.Increment => _PlayerService.IncrementStat,
            manipulationType.Decrement => _PlayerService.DecrementStat,
            manipulationType.Set => _PlayerService.SetStat
        }
    
        # Perform the appropriate action based on the stat and manipulation type
        if (StatKey := StatActions[Stat], ManipulationAction := ManipulationActions[Manipulation]):
            ManipulationAction(Agent, StatKey, Amount)
        else:
            _DebugUtil.Error("Manipulation Type not found: {manipulationTypeToString(Manipulation)}")

    # Method to get data for a given agent as an int
    GetDataAsInt(Agent: agent, Stat: stat)<transacts>: int =
        if (GetStats := _PlayerService.GetPlayerStats[Agent]):
            StatKey := statTypeToString(Stat)
            if (StatKey = "Example"):
                Amount := GetStats.Example
                return Amount
            else if (StatKey = "Money"):
                Amount := GetStats.Money
                return Amount
            else:
                return -1
        else:
            return -2

# End of file: PlayerRepository.verse


# File: C:\Users\chrisromp\dev\verse-examples\Player Manipulation Scripts\Persistence\PlayerService.verse
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }

PlayerService := class<concrete>():
    
    _DebugUtil : DebugUtil = DebugUtil{}
    
    # Method to initialize a single player
    InitializePlayer(Player:player):void=
        if:
            not PlayerStatsMap[Player]
            set PlayerStatsMap[Player] = player_stats_table{}
        
    # Method to reset a player's progress
    ResetPlayerProgress(Player:player):void=
        if:
            PlayerStatsMap[Player]
            set PlayerStatsMap[Player] = player_stats_table{}
        then:
            InitializePlayer(Player)
        
    # Method to get a player's stats
    GetPlayerStats(Agent:agent)<decides><transacts>:player_stats_table=
        var PlayerStats:player_stats_table = player_stats_table{}
        if:
            Player := player[Agent]
            Player.IsActive[]
            PlayerStatsTable := PlayerStatsMap[Player]
            set PlayerStats = MakePlayerStatsTable(PlayerStatsTable)
        PlayerStats
        
    # Method to increment a player's stat
    IncrementStat(Agent:agent, Stat:stat_type, Score:int):void=
        if:
            Player := player[Agent]
            PlayerStatsTable := PlayerStatsMap[Player]
            if(Stat.Id() = StatType.Example.Id() and Player.IsActive[]):
                ExampleStat := PlayerStatsTable.Example
                set PlayerStatsMap[Player] = player_stats_table:
                    MakePlayerStatsTable<constructor>(PlayerStatsTable)
                    Example := PlayerStatsTable.Example + Score
            else if(Stat.Id() = StatType.Money.Id() and Player.IsActive[]):
                MoneyStat := PlayerStatsTable.Money
                set PlayerStatsMap[Player] = player_stats_table:
                    MakePlayerStatsTable<constructor>(PlayerStatsTable)
                    Money := PlayerStatsTable.Money + Score
        then:
            if(Stat.Id() = StatType.Example.Id()):
                _DebugUtil.Log("Example incremented by {Score}")
            else if(Stat.Id() = StatType.Money.Id()):
                _DebugUtil.Log("Money incremented by {Score}")
            else:
                _DebugUtil.Error("Invalid Stat Type")
        else:
            _DebugUtil.Error("Player Stats Table not found")
        
    # Method to decrement a player's stat
    DecrementStat(Agent:agent, Stat:stat_type, Score:int):void=
        if:
            Player := player[Agent]
            PlayerStatsTable := PlayerStatsMap[Player]
            if(Stat.Id() = StatType.Example.Id() and Player.IsActive[]):
                ExampleStat := PlayerStatsTable.Example
                set PlayerStatsMap[Player] = player_stats_table:
                    MakePlayerStatsTable<constructor>(PlayerStatsTable)
                    Example := PlayerStatsTable.Example - Score
            else if(Stat.Id() = StatType.Money.Id() and Player.IsActive[]):
                MoneyStat := PlayerStatsTable.Money
                set PlayerStatsMap[Player] = player_stats_table:
                    MakePlayerStatsTable<constructor>(PlayerStatsTable)
                    Money := PlayerStatsTable.Money - Score
        then:
            if(Stat.Id() = StatType.Example.Id()):
                _DebugUtil.Log("Example decremented by {Score}")
            else if(Stat.Id() = StatType.Money.Id()):
               _DebugUtil.Log("Money decremented by {Score}")
            else:
                _DebugUtil.Error("Invalid Stat Type")
        else:
            _DebugUtil.Error("Player Stats Table not found")
        
    # Method to set a player's stat
    SetStat(Agent:agent, Stat:stat_type, Score:int):void=
        if:
            Player := player[Agent]
            PlayerStatsTable := PlayerStatsMap[Player]
            if(Stat.Id() = StatType.Example.Id() and Player.IsActive[]):
                ExampleStat := PlayerStatsTable.Example
                set PlayerStatsMap[Player] = player_stats_table:
                    MakePlayerStatsTable<constructor>(PlayerStatsTable)
                    Example := Score
        then:
            if(Stat.Id() = StatType.Example.Id()):
                _DebugUtil.Log("Example set to {Score}")
            else if(Stat.Id() = StatType.Money.Id()):
                _DebugUtil.Log("Action cannot be performed: Money cannot be set.")
            else:
                _DebugUtil.Error("Invalid Stat Type")
        else:
            _DebugUtil.Error("Player Stats Table not found")

# End of file: PlayerService.verse


# File: C:\Users\chrisromp\dev\verse-examples\Player Manipulation Scripts\Persistence\PlayerStats.verse
# Define a class for storing player stats
player_stats_table := class<final><persistable>:
    Example: int = 0
    Money: int = 0

# Define a constructor function to create a new player_stats_table from an existing one
MakePlayerStatsTable<constructor>(OldTable:player_stats_table)<transacts> := player_stats_table:
    Example := OldTable.Example
    Money := OldTable.Money

# End of file: PlayerStats.verse


# File: C:\Users\chrisromp\dev\verse-examples\Player Manipulation Scripts\Persistence\StatTypes.verse
# Define an abstract class for stat types
stat_type := class<computes><abstract>:
    Id() <transacts>:int

# Define a module to hold the specific stat types
StatType := module:

    example_stat<public> := class<computes>(stat_type):
        Id<override>()<transacts>:int = 1
    money_stat<public> := class<computes>(stat_type):
        Id<override>()<transacts>:int = 2

    Example<public>:example_stat = example_stat{}
    Money<public>:money_stat = money_stat{}

# End of file: StatTypes.verse


# File: C:\Users\chrisromp\dev\verse-examples\Script Template (For my use)\Template.Verse
using { /Fortnite.com/Characters }
using { /Fortnite.com/UI }
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }
using { /Verse.org/Colors }
using { /Verse.org/Random }
using { /UnrealEngine.com/Temporary/SpatialMath }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { /UnrealEngine.com/Temporary/UI }
using { /Fortnite.com/Game }

#    _______ .______    __  .__   __.  _______ .______   .__   __.     ______ .______    _______     ___   .___________. _______     _____.
#   /  _____||   _  \  |  | |  \ |  | |   ____||   _  \  |  \ |  |    /      ||   _  \  |   ____|   /   \  |           ||   ____|   /     |
#  |  |  __  |  |_)  | |  | |   \|  | |  |__   |  |_)  | |   \|  |   |  ,----'|  |_)  | |  |__     /  ^  \ `---|  |----`|  |__     |   (--`
#  |  | |_ | |      /  |  | |  . `  | |   __|  |      /  |  . `  |   |  |     |      /  |   __|   /  /_\  \    |  |     |   __|     \   \  
#  |  |__| | |  |\  \-.|  | |  |\   | |  |____ |  |\  \-.|  |\   |   |  `----.|  |\  \-.|  |____ /  _____  \   |  |     |  |____  .--)   | 
#   \______| | _| `.__||__| |__| \__| |_______|| _| `.__||__| \__|    \______|| _| `.__||_______/__/     \__\  |__|     |_______| |_____/  
                                                                                                                                         
#Discord: @Grinern
#Twitter: @GrinernCreates
#Youtube: @GrinernCreates

Template := class(creative_device):

    OnBegin<override>()<suspends>:void=
        Print("@GrinernCreates Script Started")


# End of file: Template.Verse


# File: C:\Users\chrisromp\dev\verse-examples\UnrealEngine\UnrealEngine.digest.verse
# Copyright Epic Games, Inc. All Rights Reserved.
#################################################
# Generated Digest of Verse API
# DO NOT modify this manually!
# Generated from build: ++Fortnite+Release-28.20-CL-31165234
#################################################

Temporary<public> := module:
    using {/Verse.org/Assets}
    using {/Verse.org/Colors}
    using {/UnrealEngine.com/Temporary/SpatialMath}
    using {/Verse.org/Simulation}
    # Module import path: /UnrealEngine.com/Temporary/UI
    UI<public> := module:
        # Returns the `player_ui` component associated with `Player`.
        # Fails if there is no `player_ui` associated with `Player`.
        GetPlayerUI<native><public>(Player:player)<transacts><decides>:player_ui

        # The main interface for adding and removing `widget`s to a player's UI.
        player_ui<native><public> := class<final><epic_internal>:
            # Adds `Widget` to this `player_ui` using default `player_ui_slot` configuration options.
            AddWidget<native><public>(Widget:widget):void

            # Adds `Widget` to this `player_ui` using `Slot` for configuration options.
            AddWidget<native><public>(Widget:widget, Slot:player_ui_slot):void

            # Removes `Widget` from this `player_ui`.
            RemoveWidget<native><public>(Widget:widget):void

        # Base class for all UI elements drawn on the `player`'s screen.
        widget<native><public> := class<abstract><unique><epic_internal>:
            # Shows or hides the `widget` without removing itself from the containing `player_ui`.
            # See `widget_visibility` for details.
            SetVisibility<native><public>(InVisibility:widget_visibility):void

            # Returns the current `widget_visibility` state.
            GetVisibility<native><public>():widget_visibility

            # Enables or disables whether the `player` can interact with this `widget`.
            SetEnabled<native><public>(InIsEnabled:logic):void

            # `true` if this `widget` can be modified interactively by the player.
            IsEnabled<native><public>():logic

            # Returns the `widget`'s parent `widget`.
            # Fails if no parent exists, such as if this `widget` is not in the `player_ui` or is itself the root `widget`.
            GetParentWidget<native><public>()<transacts><decides>:widget

            # Returns the `widget` that added this `widget` to the `player_ui`. The root `widget` will return itself.
            # Fails if this `widget` is not in the `player_ui`.
            GetRootWidget<native><public>()<transacts><decides>:widget

        # `widget` creation configuration options.
        player_ui_slot<native><public> := struct:
            # Controls `widget` rendering order. Greater values will be draw in front of lesser values.
            ZOrder<native><public>:type {_X:int where 0 <= _X, _X <= 2147483647} = external {}

            # Controls `widget` input event consumption.
            InputMode<native><public>:ui_input_mode = external {}

        # `widget` input consumption mode.
        ui_input_mode<native><public> := enum:
            # `widget` does not consume any input.
            None
            # `widget` consumes all inputs
            All

        # Parameters for `event`s signalled by a `widget`.
        widget_message<native><public> := struct:
            # The `player` that triggered the `event`.
            Player<native><public>:player

            # The `widget` that triggered the `event`.
            Source<native><public>:widget

        # Used by `widget.SetVisibility` determine how a `widget` is shown in the user interface.
        widget_visibility<native><public> := enum:
            # The `widget` is visible and occupies layout space.
            Visible
            # The `widget` is invisible and does not occupy layout space.
            Collapsed
            # The `widget` is invisible and occupies layout space.
            Hidden

        # Used by`widget` orientation modes.
        orientation<native><public> := enum:
            # Orient `widget`s from left to right.
            Horizontal
            # Orient `widget`s from top to bottom.
            Vertical

        # `widget` horizontal alignment mode.
        horizontal_alignment<native><public> := enum:
            # Center `widget` horizontally within the slot.
            Center
            # Align `widget` to the left of the slot.
            Left
            # Align `widget` to the right of the slot.
            Right
            # `widget` fills the slot horizontally.
            Fill

        # `widget` vertical alignment mode.
        vertical_alignment<native><public> := enum:
            # Center `widget` vertically within the slot.
            Center
            # Align `widget` to the top of the slot.
            Top
            # Align `widget` to the bottom of the slot.
            Bottom
            # `widget` fills the slot vertically.
            Fill

        # The anchors of a `widget` determine its the position and sizing relative to its parent.
        # `anchor`s range from `(0.0, 0.0)` (left, top) to `(1.0, 1.0)` (right, bottom).
        anchors<native><public> := struct:
            # Holds the minimum anchors, (left, top). The valid range is between `0.0` and `1.0`.
            Minimum<native><public>:vector2 = external {}

            # Holds the maximum anchors, (right, bottom). The valid range is between `0.0` and `1.0`.
            Maximum<native><public>:vector2 = external {}

        # Specifies the gap outside each edge separating a `widget` from its neighbors.
        # Distance is measured in units where `1.0` unit is the width of a pixel at 1080p resolution.
        margin<native><public> := struct:
            # The left edge spacing.
            Left<native><public>:float = external {}

            # The top edge spacing.
            Top<native><public>:float = external {}

            # The right edge spacing.
            Right<native><public>:float = external {}

            # The bottom edge spacing.
            Bottom<native><public>:float = external {}

        # Button is a container of a single child widget slot and fires the OnClick event when the button is clicked.
        button<native><public> := class<final>(widget):
            # The child widget of the button. Used only during initialization of the widget and not modified by SetSlot.
            Slot<native><public>:button_slot

            # Sets the child widget slot.
            SetWidget<native><public>(InSlot:button_slot):void

            # Subscribable event that fires when the button is clicked.
            OnClick<public>():listenable(widget_message) = external {}

        # Slot for button widget.
        button_slot<native><public> := struct:
            # The widget assigned to this slot.
            Widget<native><public>:widget

            # Horizontal alignment of the widget inside the slot.
            HorizontalAlignment<native><public>:horizontal_alignment = external {}

            # Vertical alignment of the widget inside the slot.
            VerticalAlignment<native><public>:vertical_alignment = external {}

            # Empty distance in pixels that surrounds the widget inside the slot. Assumes 1080p resolution.
            Padding<native><public>:margin = external {}

        # Canvas is a container widget that allows for arbitrary positioning of widgets in the canvas' slots.
        canvas<native><public> := class<final>(widget):
            # The child widgets of the canvas. Used only during initialization of the widget and not modified by Add/RemoveWidget.
            Slots<native><public>:[]canvas_slot = external {}

            # Adds a new child slot to the canvas.
            AddWidget<native><public>(Slot:canvas_slot):void

            # Removes a slot containing the given widget.
            RemoveWidget<native><public>(Widget:widget):void

        # Slot for a canvas widget.
        canvas_slot<native><public> := struct:
            # The border for the margin and how the widget is resized with its parent.
            # Values are defined between 0.0 and 1.0.
            Anchors<native><public>:anchors = external {}

            # The offset that defined the size and position of the widget.
            # When the anchors are well defined, the Offsets.Left represent the distance in pixels from the Anchors Minimum.X, the Offsets.Bottom represent the distance in pixel from the Anchors Maximum.Y, effectively controlling the desired widget size. When the anchors are not well defined, the Offsets.Left and Offsets.Top represent the widget position and Offsets.Right and Offset.Bottom represent the widget size.
            Offsets<native><public>:margin = external {}

            # When true we use the widget's desired size. The size calculated by the Offsets is ignored.
            SizeToContent<native><public>:logic = external {}

            # Alignment is the pivot/origin point of the widget.
            # Starting in the upper left at (0.0,0.0), ending in the lower right at (1.0,1.0).
            Alignment<native><public>:vector2 = external {}

            # Z Order of this slot relative to other slots in this canvas panel.
            # Higher values are rendered last (and so they will appear to be on top)
            ZOrder<native><public>:type {_X:int where 0 <= _X, _X <= 2147483647} = external {}

            # The widget assigned to this slot.
            Widget<native><public>:widget

        # Make a canvas slot for fixed position widget.
        # If Size is set, then the Offsets is calculated and the SizeToContent is set to false.
        # If Size is not set, then Right and Bottom are set to zero and are not used. The widget size will be automatically calculated. The SizeToContent is set to true.
        # The widget is not anchored and will not move if the parent is resized.
        # The Anchors is set to zero.
        MakeCanvasSlot<native><public>(Widget:widget, Position:vector2, ?Size:vector2 = external {}, ?ZOrder:type {_X:int where 0 <= _X, _X <= 2147483647} = external {}, ?Alignment:vector2 = external {})<computes>:canvas_slot

        # A solid color widget.
        color_block<native><public> := class<final>(widget):
            # The color of the widget. Used only during initialization of the widget and not modified by SetColor.
            DefaultColor<native><public>:color = external {}

            # The opacity of the widget. Used only during initialization of the widget and not modified by SetOpacity.
            DefaultOpacity<native><public>:type {_X:float where 0.000000 <= _X, _X <= 1.000000} = external {}

            # The size this widget desired to be displayed in. Used only during initialization of the widget and not modified by SetDesiredSize.
            DefaultDesiredSize<native><public>:vector2 = external {}

            # Sets the widget's color.
            SetColor<native><public>(InColor:color):void

            # Gets the widget's color.
            GetColor<native><public>():color

            # Sets the widgets's opacity.
            SetOpacity<native><public>(InOpacity:type {_X:float where 0.000000 <= _X, _X <= 1.000000}):void

            # Gets the widget's opacity.
            GetOpacity<native><public>():type {_X:float where 0.000000 <= _X, _X <= 1.000000}

            # Sets the size this widget desired to be displayed in.
            SetDesiredSize<native><public>(InDesiredSize:vector2):void

            # Gets the size this widget desired to be displayed in.
            GetDesiredSize<native><public>():vector2

        # Tiling options values
        image_tiling<native><public> := enum:
            # Stretch the image to fit the available space.
            Stretch
            # Repeat/Wrap the image to fill the available space.
            Repeat

        # A widget to display a texture.
        texture_block<native><public> := class(widget):
            # The image to render. Used only during initialization of the widget and not modified by SetImage.
            DefaultImage<native><public>:texture

            # Tinting applied to the image. Used only during initialization of the widget and not modified by SetTint.
            DefaultTint<native><public>:color = external {}

            # The size this widget desired to be displayed in. Used only during initialization of the widget and not modified by SetDesiredSize.
            DefaultDesiredSize<native><public>:vector2 = external {}

            # The horizontal tiling option. Used only during initialization of the widget and not modified by SetTiling.
            DefaultHorizontalTiling<native><public>:image_tiling = external {}

            # The vertical tiling option. Used only during initialization of the widget and not modified by SetTiling.
            DefaultVerticalTiling<native><public>:image_tiling = external {}

            # Sets the image to render.
            SetImage<native><public>(InImage:texture):void

            # Gets the image to render.
            GetImage<native><public>():texture

            # Sets the tint applied to the image.
            SetTint<native><public>(InColor:color):void

            # Gets the tint applied to the image.
            GetTint<native><public>():color

            # Sets the size this widget desired to be displayed in.
            SetDesiredSize<native><public>(InDesiredSize:vector2):void

            # Gets the size this widget desired to be displayed in.
            GetDesiredSize<native><public>():vector2

            # Sets the tiling option when the image is smaller than the allocated size.
            SetTiling<native><public>(InHorizontalTiling:image_tiling, InVerticalTiling:image_tiling):void

            # Gets the tiling option.
            GetTiling<native><public>():tuple(image_tiling, image_tiling)

        # Overlay is a container consisting of widgets stacked on top of each other.
        overlay<native><public> := class<final>(widget):
            # The child widgets of the overlay. Used only during initialization of the widget and not modified by Add/RemoveWidget.
            Slots<native><public>:[]overlay_slot = external {}

            # Add a new child slot to the overlay. Slots are added at the end.
            AddWidget<native><public>(Slot:overlay_slot):void

            # Removes a slot containing the given widget
            RemoveWidget<native><public>(Widget:widget):void

        # Slot for an overlay widget
        overlay_slot<native><public> := struct:
            # The widget assigned to this slot.
            Widget<native><public>:widget

            # Horizontal alignment of the widget inside the slot.
            # This alignment is only applied after the layout space for the widget slot is created and determines the widget alignment within that space.
            HorizontalAlignment<native><public>:horizontal_alignment = external {}

            # Vertical alignment of the widget inside the slot.
            # This alignment is only applied after the layout space for the widget slot is created and determines the widget alignment within that space.
            VerticalAlignment<native><public>:vertical_alignment = external {}

            # Empty distance in pixels that surrounds the widget inside the slot. Assumes 1080p resolution.
            Padding<native><public>:margin = external {}

        # Stack box is a container of a list of widgets stacked either vertically or horizontally.
        stack_box<native><public> := class<final>(widget):
            # The child widgets of the stack box. Used only during initialization of the widget and not modified by Add/RemoveWidget.
            Slots<native><public>:[]stack_box_slot = external {}

            # The orientation of the stack box. Either stack widgets horizontal or vertical.
            Orientation<native><public>:orientation

            # Add a new child slot to the stack box. Slots are added at the end.
            AddWidget<native><public>(Slot:stack_box_slot):void

            # Removes a slot containing the given widget
            RemoveWidget<native><public>(Widget:widget):void

        # Slot for a stack_box widget
        stack_box_slot<native><public> := struct:
            # The widget assigned to this slot.
            Widget<native><public>:widget

            # Horizontal alignment of the widget inside the slot.
            # This alignment is only applied after the layout space for the widget slot is created and determines the widget alignment within that space.
            HorizontalAlignment<native><public>:horizontal_alignment = external {}

            # Vertical alignment of the widget inside the slot.
            # This alignment is only applied after the layout space for the widget slot is created and determines the widget alignment within that space.
            VerticalAlignment<native><public>:vertical_alignment = external {}

            # Empty distance in pixels that surrounds the widget inside the slot. Assumes 1080p resolution.
            Padding<native><public>:margin = external {}

            # The available space will be distributed proportionally.
            # If not set, the slot will use the desired size of the widget.
            Distribution<native><public>:?float = external {}

        # Text justification values:
        #   Left: Justify the text logically to the left based on current culture.
        #   Center: Justify the text in the center.
        #   Right: Justify the text logically to the right based on current culture.
        # The Left and Right value will flip when the local culture is right-to-left.
        text_justification<native><public> := enum:
            Left
            Center
            Right
            InvariantLeft
            InvariantRight

        # Text overflow policy values:
        #   Clip: Overflowing text will be clipped.
        #   Ellipsis: Overflowing text will be replaced with an ellipsis.
        text_overflow_policy<native><public> := enum:
            Clip
            Ellipsis

        # Base widget for text widget.
        text_base<native><public> := class<abstract>(widget):
            # The text to display to the user. Used only during initialization of the widget and not modified by SetText.
            DefaultText<native><localizes><public>:message = external {}

            # The color of the displayed text. Used only during initialization of the widget and not modified by SetTextColor.
            DefaultTextColor<native><public>:color = external {}

            # The opacity of the displayed text. Used only during initialization of the widget and not modified by SetTextOpacity.
            DefaultTextOpacity<native><public>:type {_X:float where 0.000000 <= _X, _X <= 1.000000} = external {}

            # The justification to display to the user. Used only during initialization of the widget and not modified by SetJustification.
            DefaultJustification<native><public>:text_justification = external {}

            # The policy that determine what happens when the text is longer than its allowed length.
            # Used only during initialization of the widget and not modified by SetOverflowPolicy.
            DefaultOverflowPolicy<native><public>:text_overflow_policy = external {}

            # Sets the text displayed in the widget.
            SetText<native><public>(InText:message):void

            # Gets the text currently in the widget.
            GetText<native><public>():[]char

            # Sets the text justification in the widget.
            SetJustification<native><public>(InJustification:text_justification):void

            # Gets the text justification in the widget.
            GetJustification<native><public>():text_justification

            # Sets the policy that determine what happens when the text is longer than its allowed length.
            SetOverflowPolicy<native><public>(InOverflowPolicy:text_overflow_policy):void

            # Gets the policy that determine what happens when the text is longer than its allowed length.
            GetOverflowPolicy<native><public>():text_overflow_policy

            # Sets the color of the displayed text.
            SetTextColor<native><public>(InColor:color):void

            # Gets the color of the displayed text.
            GetTextColor<native><public>():color

            # Sets the opacity of the displayed text.
            SetTextOpacity<native><public>(InOpacity:type {_X:float where 0.000000 <= _X, _X <= 1.000000}):void

            # Gets the opacity of the displayed text.
            GetTextOpacity<native><public>():type {_X:float where 0.000000 <= _X, _X <= 1.000000}

    # Module import path: /UnrealEngine.com/Temporary/Diagnostics
    Diagnostics<public> := module:
        # Enumerated presets for policies describing a desired draw duration.
        debug_draw_duration_policy<native><public> := enum:
            SingleFrame
            FiniteDuration
            Persistent

        # debug_draw_channel is the base class used to define debug draw channels.
        debug_draw_channel<native><public> := class<abstract>:

        # debug draw class to draw debug shapes on screen.
        debug_draw<native><public> := class:
            # Channel will be used to clear specific debug draw.
            Channel<native><public>:subtype(debug_draw_channel) = external {}

            # Show Debug Draw for the channel for all users.
            ShowChannel<native><public>()<transacts>:void

            # Hide Debug Draw for the channel for all users.
            HideChannel<native><public>()<transacts>:void

            # Clears all debug draw for the channel.
            ClearChannel<native><public>()<transacts>:void

            # Clears all debug draw from this debug_draw instance.
            Clear<native><public>()<transacts>:void

            # Draws a sphere at the named location, and using the provided draw parameters.
            DrawSphere<native><public>(Center:vector3, ?Radius:float = external {}, ?Color:color = external {}, ?NumSegments:int = external {}, ?Thickness:float = external {}, ?DrawDurationPolicy:debug_draw_duration_policy = external {}, ?Duration:float = external {})<transacts>:void

            # Draws a box at the named location, and using the provided draw parameters
            DrawBox<native><public>(Center:vector3, Rotation:rotation, ?Extent:vector3 = external {}, ?Color:color = external {}, ?Thickness:float = external {}, ?DrawDurationPolicy:debug_draw_duration_policy = external {}, ?Duration:float = external {})<transacts>:void

            # Draws a capsule at the named location, and using the provided draw parameters.
            DrawCapsule<native><public>(Center:vector3, Rotation:rotation, ?Height:float = external {}, ?Radius:float = external {}, ?Color:color = external {}, ?Thickness:float = external {}, ?DrawDurationPolicy:debug_draw_duration_policy = external {}, ?Duration:float = external {})<transacts>:void

            # Draws a cone at the named location, and using the provided draw parameters.
            DrawCone<native><public>(Origin:vector3, Direction:vector3, ?Height:float = external {}, ?NumSides:int = external {}, ?AngleWidthRadians:float = external {}, ?AngleHeightRadians:float = external {}, ?Color:color = external {}, ?Thickness:float = external {}, ?DrawDurationPolicy:debug_draw_duration_policy = external {}, ?Duration:float = external {})<transacts>:void

            # Draws a cylinder at the named location, and using the provided draw parameters.
            DrawCylinder<native><public>(Start:vector3, End:vector3, ?NumSegments:int = external {}, ?Radius:float = external {}, ?Color:color = external {}, ?Thickness:float = external {}, ?DrawDurationPolicy:debug_draw_duration_policy = external {}, ?Duration:float = external {})<transacts>:void

            # Draws a line from Start to End locations, and using the provided draw parameters.
            DrawLine<native><public>(Start:vector3, End:vector3, ?Color:color = external {}, ?Thickness:float = external {}, ?DrawDurationPolicy:debug_draw_duration_policy = external {}, ?Duration:float = external {})<transacts>:void

            # Draws a point at the named location, and using the provided draw parameters.
            DrawPoint<native><public>(Position:vector3, ?Color:color = external {}, ?Thickness:float = external {}, ?DrawDurationPolicy:debug_draw_duration_policy = external {}, ?Duration:float = external {})<transacts>:void

            # Draws an arrow pointing from Start to End locations, and using the provided draw parameters.
            DrawArrow<native><public>(Start:vector3, End:vector3, ?ArrowSize:float = external {}, ?Color:color = external {}, ?Thickness:float = external {}, ?DrawDurationPolicy:debug_draw_duration_policy = external {}, ?Duration:float = external {})<transacts>:void

        # log levels available for various log commands
        log_level<native><public> := enum:
            Debug
            Verbose
            Normal
            Warning
            Error

        # log_channel is the base class used to define log channels. When printing a message to a log, the log channel class name will be prefixed to the output message.
        log_channel<native><public> := class<abstract>:

        # log class to send messages to the default log
        log<native><public> := class:
            # Channel class name will be added as a prefix used when printing the message e.g. '[log_channel]: #Message
            Channel<native><public>:subtype(log_channel)

            # Sets the default log level of the displayed message. See log_level enum for more info on log levels. Defaults to log_level.Normal.
            DefaultLevel<native><public>:log_level = external {}

            # Print message using the given log level
            (log:)Print<native><public>(Message:[]char, ?Level:log_level = external {})<computes>:void

            # Prints current script call stack using the give log level
            PrintCallStack<native><public>(?Level:log_level = external {})<computes>:void

    # Module import path: /UnrealEngine.com/Temporary/Curves
    Curves<public> := module:
        editable_curve<native><public> := class<final><concrete>:
            # Evaluates this float curve at the specified time and returns the result as a float
            Evaluate<native><public>(Time:float):float


    using {/Verse.org/Native}
    # Module import path: /UnrealEngine.com/Temporary/SpatialMath
    SpatialMath<public> := module:
        @editable
        @import_as("/Script/EpicGamesTemporary.FVerseRotation")
        rotation<native><public> := struct<concrete>:

        # Makes a `rotation` from `Axis` and `AngleRadians` using a left-handed sign convention (e.g. a positive rotation around +Z takes +X to +Y). If `Axis.IsAlmostZero[]`, make the identity rotation.
        MakeRotation<native><public>(Axis:vector3, AngleRadians:float)<varies>:rotation

        # Makes a `rotation` by applying `YawRightDegrees`, `PitchUpDegrees`, and `RollClockwiseDegrees`, in that order:
        #  * first a *yaw* about the Z axis with a positive angle indicating a clockwise rotation when viewed from above,
        #  * then a *pitch* about the new Y axis with a positive angle indicating 'nose up',
        #  * followed by a *roll* about the new X axis axis with a positive angle indicating a clockwise rotation when viewed along +X.
        # Note that these conventions differ from `MakeRotation` but match `ApplyYaw`, `ApplyPitch`, and `ApplyRoll`.
        MakeRotationFromYawPitchRollDegrees<native><public>(YawRightDegrees:float, PitchUpDegrees:float, RollClockwiseDegrees:float)<varies>:rotation

        # Makes the identity `rotation`.
        IdentityRotation<native><public>()<converges>:rotation

        # Returns the 'distance' between `Rotation1` and `Rotation2`. The result will be between:
        #  * `0.0`, representing equivalent rotations and
        #  * `1.0` representing rotations which are 180 degrees apart (i.e., the shortest rotation between them is 180 degrees around some axis).
        Distance<native><public>(Rotation1:rotation, Rotation2:rotation)<varies>:float

        # Returns the 'smallest angular distance' between `Rotation1` and `Rotation2` in radians.
        AngularDistance<native><public>(Rotation1:rotation, Rotation2:rotation)<varies>:float

        # Makes a `rotation` by applying `PitchUpRadians` of right-handed rotation around the local +Y axis to `InitialRotation`.
        (InitialRotation:rotation).ApplyPitch<native><public>(PitchUpRadians:float)<transacts>:rotation

        # Makes a `rotation` by applying `RollClockwiseRadians` of right-handed rotation around the local +X axis to `InitialRotation`.
        (InitialRotation:rotation).ApplyRoll<native><public>(RollClockwiseRadians:float)<transacts>:rotation

        # Makes a `rotation` by applying `YawRightRadians` of left-handed rotation around the local +Z axis to `InitialRotation`.
        (InitialRotation:rotation).ApplyYaw<native><public>(YawRightRadians:float)<transacts>:rotation

        # Makes a `rotation` by applying `AngleRadians` of left-handed rotation around the world +X axis to `InitialRotation`.
        (InitialRotation:rotation).ApplyWorldRotationX<native><public>(AngleRadians:float)<transacts>:rotation

        # Makes a `rotation` by applying `AngleRadians` of left-handed rotation around the world +Y axis to `InitialRotation`.
        (InitialRotation:rotation).ApplyWorldRotationY<native><public>(AngleRadians:float)<transacts>:rotation

        # Makes a `rotation` by applying `AngleRadians` of left-handed rotation around the world +Z axis to `InitialRotation`.
        (InitialRotation:rotation).ApplyWorldRotationZ<native><public>(AngleRadians:float)<transacts>:rotation

        # Makes a `rotation` by applying `AngleRadians` of left-handed rotation around the local +Y axis to `InitialRotation`.
        (InitialRotation:rotation).ApplyLocalRotationY<public>(AngleRadians:float)<transacts>:rotation = external {}

        # Makes a `rotation` by applying `AngleRadians` of left-handed rotation around the local +Z axis to `InitialRotation`.
        (InitialRotation:rotation).ApplyLocalRotationZ<public>(AngleRadians:float)<transacts>:rotation = external {}

        # Makes a `rotation` by composing `AdditionalRotation` to `InitialRotation`.
        (InitialRotation:rotation).RotateBy<native><public>(AdditionalRotation:rotation)<transacts>:rotation

        # Makes a `rotation` by composing the inverse of `RotationToRemove` from `InitialRotation`. such that InitialRotation = RotateBy(UnrotateBy(InitialRotation, RotationToRemove), RotationToRemove). This is equivalent to RotateBy(InitialRotation, InvertRotation(RotationToRemove))
        (InitialRotation:rotation).UnrotateBy<native><public>(RotationToRemove:rotation)<transacts>:rotation

        # Makes an `[]float` with three elements:
        #  * *yaw* degrees of `rotation`
        #  * *pitch* degrees of `rotation`
        #  * *roll* degrees of `rotation`
        # using the conventions of `MakeRotationFromYawPitchRollDegrees`.
        (Rotation:rotation).GetYawPitchRollDegrees<native><public>()<varies>:[]float

        # Makes a `vector3` from the axis of `rotation`.
        # If `rotation` is nearly identity, this will return the +X axis. See also `GetAngle`.
        (Rotation:rotation).GetAxis<native><public>()<varies>:vector3

        # Returns the radians of `rotation` around the axis of `rotation`. See also `GetAxis`.
        (Rotation:rotation).GetAngle<native><public>()<varies>:float

        # Makes the smallest angular `rotation` from `InitialRotation` to `FinalRotation` such that:
        # `InitialRotation.RotateBy(MakeShortestRotationBetween(InitialRotation, FinalRotation)) = FinalRotation` and
        # `MakeShortestRotationBetween(InitialRotation, FinalRotation)?.GetAngle()` is as small as possible.
        MakeShortestRotationBetween<native><public>(InitialRotation:rotation, FinalRotation:rotation)<transacts>:rotation

        # Makes the smallest angular `rotation` from `InitialVector` to `FinalVector` such that:
        # `InitialVector.RotateBy(MakeShortestRotationBetween(InitialVector, Vector)) = FinalVector` and
        # `MakeShortestRotationBetween(InitialVector, FinalVector)?.GetAngle()` is as small as possible.
        MakeShortestRotationBetween<native><public>(InitialVector:vector3, FinalVector:vector3)<transacts>:rotation

        # Makes a new `rotation` from the component wise subtraction of the Euler angle components in `RotationA` by 
        # the Euler angle components in `RotationB` and ensures the returned value is normalized.
        MakeComponentWiseDeltaRotation<native><public>(RotationA:rotation, RotationB:rotation)<transacts>:rotation

        # Used to perform spherical linear interpolation between `From` (when `Parameter = 0.0`) and `To` (when `Parameter = 1.0`). Expects that `0.0 <= Parameter <= 1.0`.
        Slerp<native><public>(InitialRotation:rotation, FinalRotation:rotation, Parameter:float)<transacts><decides>:rotation

        # Makes a `vector3` by applying `Rotation` to `Vector`.
        (Rotation:rotation).RotateVector<native><public>(Vector:vector3)<transacts>:vector3

        # Makes a `vector3` by applying the inverse of `Rotation` to `Vector`.
        (Rotation:rotation).UnrotateVector<native><public>(Vector:vector3)<transacts>:vector3

        # Makes a `rotation` by inverting `Rotation` such that `ApplyRotation(Rotation, Rotation.Invert())) = IdentityRotation`.
        (Rotation:rotation).Invert<native><public>()<transacts>:rotation

        # Returns `Rotation` if it does not contain `NaN`, `Inf` or `-Inf`.
        (Rotation:rotation).IsFinite<native><public>()<computes><decides>:rotation

        # Makes a unit `vector3` pointing in the local space *forward* direction in world space coordinates.
        # This is equivalent to: `RotateVector(Rotation, vector3{X:=1.0, Y:=0.0, Z:=0.0})`.
        (Rotation:rotation).GetLocalForward<public>()<transacts>:vector3 = external {}

        # Makes a unit `vector3` pointing in the the local space *right* direction in world space coordinates.
        # This is equivalent to: `RotateVector(Rotation, vector3{X:=0.0, Y:=1.0, Z:=0.0})`.
        (Rotation:rotation).GetLocalRight<public>()<transacts>:vector3 = external {}

        # Makes a unit `vector3` pointing in the local space *up* direction in world space coordinates.
        # This is equivalent to: `RotateVector(Rotation, vector3{X:=0.0, Y:=0.0, Z:=1.0})`.
        (Rotation:rotation).GetLocalUp<public>()<transacts>:vector3 = external {}

        # Makes a `string` representation of `rotation` in axis/degrees format with a left-handed sign convention.
        # `ToString(MakeRotation(vector3{X:=1.0, Y:=0.0, Z:=0.0}, PiFloat/2.0))` produces the string: `"Axis: {x=1.000000,y=0.000000,z=0.000000} Angle: 90.000000"`.
        ToString<native><public>(Rotation:rotation)<varies>:[]char

        # Returns radians from `Degrees`.
        DegreesToRadians<public>(Degrees:float)<varies>:float = external {}

        # Returns degrees from `Radians`.
        RadiansToDegrees<public>(Radians:float)<varies>:float = external {}

        # A combination of scale, rotation, and translation, applied in that order.
        transform<native><public> := struct<concrete><computes>:
            @editable
            # The scale of this `transform`.
            Scale<native><public>:vector3 = external {}

            @editable
            # The rotation of this `transform`.
            Rotation<native><public>:rotation = external {}

            @editable
            # The location of this `transform`.
            Translation<native><public>:vector3 = external {}

        # Makes a `vector3` by applying `InTransform` to `InVector`.
        TransformVector<native><public>(InTransform:transform, InVector:vector3)<varies>:vector3

        # Makes a `vector3` by applying `InTransform` to `InVector` without applying `InTransform.Scale`.
        TransformVectorNoScale<native><public>(InTransform:transform, InVector:vector3)<varies>:vector3

        # 2-dimensional vector with `float` components.
        vector2<native><public> := struct<concrete><computes>:
            @editable
            X<native><public>:float = external {}

            @editable
            Y<native><public>:float = external {}

        # Makes a `vector2` by inverting the `SurfaceNormal` component of `Direction`.
        # Fails if `not SurfaceNormal.MakeUnitVector[]`.
        ReflectVector<native><public>(Direction:vector2, SurfaceNormal:vector2)<varies><decides>:vector2

        # Returns the dot product of `V1` and `V2`.
        DotProduct<native><public>(V1:vector2, V2:vector2)<varies>:float

        # Returns the Euclidean distance between `V1` and `V2`.
        Distance<native><public>(V1:vector2, V2:vector2)<varies>:float

        # Returns the squared Euclidean distance between `V1` and `V2`.
        DistanceSquared<native><public>(V1:vector2, V2:vector2)<varies>:float

        # Makes a unit length `vector3` pointing in the same direction of `V`.
        # Fails if `V.IsAlmostZero[] or not V.IsFinite[]`.
        (V:vector2).MakeUnitVector<native><public>()<varies><decides>:vector2

        # Returns the length of `V`.
        (V:vector2).Length<public>()<varies>:float = external {}

        # Returns the squared length of `V`.
        (V:vector2).LengthSquared<public>()<varies>:float = external {}

        # Used to linearly interpolate/extrapolate between `From` (when `Parameter = 0.0`) and `To` (when `Parameter = 1.0`). Expects that all arguments are finite.
        # Returns `From*(1 - Parameter) + To*Parameter`.
        Lerp<public>(From:vector2, To:vector2, Parameter:float)<varies>:vector2 = external {}

        # Makes a `string` representation of `V`.
        ToString<native><public>(V:vector2)<varies>:[]char

        # Makes a `vector2` by inverting the signs of `Operand`.
        prefix'-'<public>(Operand:vector2)<computes>:vector2 = external {}

        # Makes a `vector2` by component-wise addition of `Left` and `Right`.
        operator'+'<public>(Left:vector2, Right:vector2)<computes>:vector2 = external {}

        # Makes a `vector2` by component-wise subtraction of `Right` from `Left`.
        operator'-'<public>(Left:vector2, Right:vector2)<computes>:vector2 = external {}

        # Makes a `vector2` by component-wise multiplication of `Left` and `Right`.
        operator'*'<public>(Left:vector2, Right:float)<computes>:vector2 = external {}

        # Makes a `vector2` by multiplying the components of `Right` by `Left`.
        operator'*'<public>(Left:float, Right:vector2)<computes>:vector2 = external {}

        # Makes a `vector2` by dividing the components of `Left` by `Right`.
        operator'/'<public>(Left:vector2, Right:float)<computes>:vector2 = external {}

        # Makes a `vector2` by component-wise division of `Left` by `Right`.
        operator'/'<public>(Left:vector2, Right:vector2)<computes>:vector2 = external {}

        # Makes a `vector2` by converting the components of `V` to `float`s.
        ToVector2<public>(V:vector2i)<transacts>:vector2 = external {}

        # Returns `V` if all components are finite.
        # Fails if any of the components are not finite.
        (V:vector2).IsFinite<public>()<computes><decides>:vector2 = external {}

        # Succeeds when each component of `V` is within `AbsoluteTolerance` of `0.0`.
        (V:vector2).IsAlmostZero<public>(AbsoluteTolerance:float)<computes><decides>:void = external {}

        # Succeeds when each component of `V1` and `V2` are within `AbsoluteTolerance` of each other.
        IsAlmostEqual<public>(V1:vector2, V2:vector2, AbsoluteTolerance:float)<computes><decides>:void = external {}

        # 2-dimensional vector with `int` components.
        vector2i<native><public> := struct<concrete><computes>:
            @editable
            X<native><public>:int = external {}

            @editable
            Y<native><public>:int = external {}

        # Returns the dot product of `V1` and `V2`.
        DotProduct<public>(V1:vector2i, V2:vector2i)<computes>:int = external {}

        # Makes a `vector2i` that is component-wise equal to `V1` and `V2`.
        # Fails if any component of `V1` does not equal the corresponding component of `V2`.
        Equals<public>(V1:vector2i, V2:vector2i)<computes><decides>:vector2i = external {}

        # Makes a `string` representation of `V`.
        ToString<native><public>(V:vector2i)<computes>:[]char

        # Makes a `vector2i` by component-wise truncation of `V` to `ints`s.
        ToVector2i<public>(V:vector2)<varies><decides>:vector2i = external {}

        # Makes a `vector2i` by inverting the signs of `Operand`.
        prefix'-'<public>(Operand:vector2i)<computes>:vector2i = external {}

        # Makes a `vector2i` by component-wise addition of `Left` and `Right`.
        operator'+'<public>(Left:vector2i, Right:vector2i)<computes>:vector2i = external {}

        # Makes a `vector2i` by component-wise subtraction of `Right` from `Left`.
        operator'-'<public>(Left:vector2i, Right:vector2i)<computes>:vector2i = external {}

        # Makes a `vector2i` by multiplying the components of `Left` by `Right`.
        operator'*'<public>(Left:vector2i, Right:int)<computes>:vector2i = external {}

        # Makes a `vector2i` by multiplying the components of `Right` by `Left`.
        operator'*'<public>(Left:int, Right:vector2i)<computes>:vector2i = external {}

        # 3-dimensional vector with `float` components.
        vector3<native><public> := struct<concrete><computes>:
            @editable
            X<native><public>:float = external {}

            @editable
            Y<native><public>:float = external {}

            @editable
            Z<native><public>:float = external {}

        # Makes a `vector3` by inverting the `SurfaceNormal` component of `Direction`.
        # Fails if `not SurfaceNormal.MakeUnitVector[]`.
        ReflectVector<native><public>(Direction:vector3, SurfaceNormal:vector3)<varies><decides>:vector3

        # Returns the dot product of `V1` and `V2`.
        DotProduct<native><public>(V1:vector3, V2:vector3)<varies>:float

        # Returns the cross product of `V1` and `V2`.
        CrossProduct<native><public>(V1:vector3, V2:vector3)<varies>:vector3

        # Returns the Euclidean distance between `V1` and `V2`.
        Distance<native><public>(V1:vector3, V2:vector3)<varies>:float

        # Returns the squared Euclidean distance between `V1` and `V2`.
        DistanceSquared<native><public>(V1:vector3, V2:vector3)<varies>:float

        # Returns the 2-D Euclidean distance between `V1` and `V2` by ignoring the difference in `Z`.
        DistanceXY<native><public>(V1:vector3, V2:vector3)<varies>:float

        # Returns the squared 2-D Euclidean distance between `V1` and `V2` by ignoring their difference in `Z`.
        DistanceSquaredXY<native><public>(V1:vector3, V2:vector3)<varies>:float

        # Makes a unit length `vector3` pointing in the same direction of `V`.
        # Fails if `V.IsAlmostZero[] or not V.IsFinite[]`.
        (V:vector3).MakeUnitVector<native><public>()<varies><decides>:vector3

        # Makes a `string` representation of `V`.
        ToString<native><public>(V:vector3)<varies>:[]char

        # Returns the length of `V`.
        (V:vector3).Length<public>()<varies>:float = external {}

        # Returns the squared length of `V`.
        (V:vector3).LengthSquared<public>()<computes>:float = external {}

        # Returns the length of `V` as if `V.Z = 0.0`.
        (V:vector3).LengthXY<public>()<varies>:float = external {}

        # Returns the squared length of `V` as if `V.Z = 0.0`.
        (V:vector3).LengthSquaredXY<public>()<varies>:float = external {}

        # Used to linearly interpolate/extrapolate between `From` (when `Parameter = 0.0`) and `To` (when `Parameter = 1.0`). Expects that all arguments are finite.
        # Returns `From*(1 - Parameter) + To*Parameter`.
        Lerp<public>(From:vector3, To:vector3, Parameter:float)<varies>:vector3 = external {}

        # Makes a `vector3` by inverting the signs of `Operand`.
        prefix'-'<public>(Operand:vector3)<computes>:vector3 = external {}

        # Makes a `vector3` by component-wise addition of `Left` and `Right`.
        operator'+'<public>(Left:vector3, Right:vector3)<computes>:vector3 = external {}

        # Makes a `vector3` by component-wise subtraction of `Right` from `Left`.
        operator'-'<public>(Left:vector3, Right:vector3)<computes>:vector3 = external {}

        # Makes a `vector3` by component-wise multiplication of `Left` and `Right`.
        operator'*'<public>(Left:vector3, Right:vector3)<computes>:vector3 = external {}

        # Makes a `vector3` by multiplying the components of `Left` by `Right`.
        operator'*'<public>(Left:vector3, Right:float)<computes>:vector3 = external {}

        # Makes a `vector3` by multiplying the components of `Right` by `Left`.
        operator'*'<public>(Left:float, Right:vector3)<computes>:vector3 = external {}

        # Makes a `vector3` by dividing the components of `Left` by `Right`.
        operator'/'<public>(Left:vector3, Right:float)<computes>:vector3 = external {}

        # Makes a `vector3` by component-wise division of `Left` by `Right`.
        operator'/'<public>(Left:vector3, Right:vector3)<computes>:vector3 = external {}

        # Returns `V` if all components are finite.
        # Fails if any of the components are not finite.
        (V:vector3).IsFinite<public>()<computes><decides>:vector3 = external {}

        # Succeeds when each component of `V` is within `AbsoluteTolerance` of `0.0`.
        (V:vector3).IsAlmostZero<public>(AbsoluteTolerance:float)<computes><decides>:void = external {}

        # Succeeds when each component of `V1` and `V2` are within `AbsoluteTolerance` of each other.
        IsAlmostEqual<public>(V1:vector3, V2:vector3, AbsoluteTolerance:float)<computes><decides>:void = external {}



# End of file: UnrealEngine.digest.verse


# File: C:\Users\chrisromp\dev\verse-examples\Verse\Verse.digest.verse
# Copyright Epic Games, Inc. All Rights Reserved.
#################################################
# Generated Digest of Verse API
# DO NOT modify this manually!
# Generated from build: ++Fortnite+Release-28.20-CL-31165234
#################################################

# Module import path: /Verse.org/Simulation
Simulation<public> := module:
    agent<native><public> := class<unique><epic_internal>:

    localizable_agent<native><epic_internal> := class(localizable_value):

    MakeLocalizableValue<epic_internal>(Agent:agent):localizable_agent = external {}

    player<native><public> := class<unique><persistent><epic_internal>(agent):

    # Type for which there is a single instance per round.  Use `GetSession` to get the current round's `session` instance. May be used with `weak_map` to implement global variables.
    # Note: may be changed in a future release to a single instance per game. Round-local behavior should not be relied upon.
    session<native><public> := class<unique><module_scoped_var_weak_map_key><epic_internal>:

    # Returns the `session` corresponding to the current round.  The result can be used with `weak_map` to implement global variables.
    # Note: may be changed in a future release to return a single instance per game. Round-local behavior should not be relied upon.
    GetSession<native><public>()<varies>:session

    # Waits specified number of seconds and then resumes. If `Seconds` = 0.0 then it waits until next tick/frame/update. If `Seconds` = Inf then it waits forever and only calls back if canceled - such as via `race`. If `Seconds` < 0.0 then it completes immediately and does not yield to other aysnc expressions.
    # Waiting until the next update (0.0) is especially useful in a loop of a coroutine that needs to do some work every update and this yields to other coroutines so that it doesn't hog a processor's resources.
    # Waiting forever (Inf) will have any expression that follows never be evaluated. Occasionally it is desireable to have a task never complete such as the last expression in a `race` subtask where the task must never win the race though it still may be canceled earlier.
    # Immediately completing (less than 0) is useful when you want programmatic control over whether an expression yields or not.
    Sleep<native><public>(Seconds:float)<suspends>:void

    # Get the seconds that have elapsed since the world began simulating
    GetSimulationElapsedTime<native><public>()<transacts>:float

    team<native><public> := class<unique><epic_internal>:

    # Module import path: /Verse.org/Simulation/Tags
    Tags<public> := module:
        # A single gameplay tag, which represents a hierarchical name of the form x.y that is registered in the GameplayTagsManager You can filter the gameplay tags displayed in the editor.
        tag<native><public> := class<abstract>:

        # A queryable collection of gameplay tags.
        tag_view<native><public> := interface<epic_internal>:
            # Determine if TagToCheck is present in this container, also checking against parent tags {"A.1"}.Has("A") will return True, {"A"}.Has("A.1") will return False If TagToCheck is not Valid it will always return False.
            Has<public>(TagToCheck:tag)<transacts><decides>:void

            # Checks if this container contains ANY of the tags in the specified container, also checks against parent tags {"A.1"}.HasAny({"A","B"}) will return True, {"A"}.HasAny({"A.1","B"}) will return False If InTags is empty/invalid it will always return False.
            HasAny<public>(InTags:[]tag)<transacts><decides>:void

            # Checks if this container contains ALL of the tags in the specified container, also checks against parent tags {"A.1","B.1"}.HasAll({"A","B"}) will return True, {"A","B"}.HasAll({"A.1","B.1"}) will return False If InTags is empty/invalid it will always return True, because there were no failed checks.
            HasAll<public>(InTags:[]tag)<transacts><decides>:void

        tag_search_sort_type<native><public> := enum:
            Unsorted
            Sorted

        # Advanced tag search criteria
        tag_search_criteria<native><public> := class:
            # Tags required to be on the object.
            RequiredTags<native><public>:[]tag = external {}

            # Tags that are used if no required tags are specified. These are treated as if any of them will do.
            PreferredTags<native><public>:[]tag = external {}

            # Tags that may NOT be on the object. All items with these tags are excluded from the search.
            ExclusionTags<native><public>:[]tag = external {}

            # Flag to request sorting the results by tag.
            SortType<native><public>:tag_search_sort_type = external {}

    @attribscope_class
    @attribscope_struct
    @attribscope_data
    @customattribhandler
    editable<public> := class(attribute):

# Module import path: /Verse.org/Assets
Assets<public> := module:
    animation_sequence<native><public> := class<computes><final><epic_internal>:

    material<native><public> := interface<epic_internal>:

    mesh<native><public> := class<computes><final><epic_internal>:

    texture<native><public> := class<computes><final><epic_internal>:

# Module import path: /Verse.org/ParameterCollections
ParameterCollections<public> := module:
Verse<public> := module:
    using {/Verse.org/Colors}
    # Writes `Message` to a dedicated `Print` log while displaying it in `Color` on the client screen for `Duration` seconds. By default, `Color` is `NamedColors.White` and `Duration` is `2.0` seconds.
    Print<native><public>(Message:[]char, ?Duration:float = external {}, ?Color:color = external {}):void

    # Writes `Message` to a dedicated `Print` log while displaying it in `Color` on the client screen for `Duration` seconds. By default, `Color` is `NamedColors.White` and `Duration` is `2.0` seconds.
    Print<native><public>(Message:message, ?Duration:float = external {}, ?Color:color = external {}):void
    # Makes a flattened `array` by concatenating the elements of `Arrays`.
    Concatenate<public>(Arrays:[][]t where t:type)<computes>:[]t = external {}

    # Makes an `array` containing `Input`'s elements from `StartIndex` to `StopIndex-1`.
    # Fails unless `0 <= StartIndex <= StopIndex <= Input.Length`.
    (Input:[]t where t:type).Slice<public>(StartIndex:int, StopIndex:int)<computes><decides>:[]t = external {}

    # Makes an `array` containing `Input`'s elements from `StartIndex` to `Input.Length-1`.
    # Succeeds if `0 <= StartIndex <= Input.Length`.
    (Input:[]t where t:type).Slice<public>(StartIndex:int)<computes><decides>:[]t = external {}

    # Makes an `array` by inserting `ElementsToInsert` into `Input` such that the first element of `ElementsToInsert` is at `InsertionIndex`.
    (Input:[]t where t:type).Insert<public>(InsertionIndex:int, ElementsToInsert:[]t)<computes><decides>:[]t = external {}

    # Makes an `array` by removing the element at `IndexToRemove` from `Input`.
    # Succeeds if `0 <= IndexToRemove <= Input.Length-1`.
    (Input:[]t where t:type).RemoveElement<public>(IndexToRemove:int)<computes><decides>:[]t = external {}

    # Makes an `array` by removing the element at the lowest index that equals `ElementToRemove` from `Input`.
    # Fails if `Input` did not contain any instances of `ElementToRemove`.
    (Input:[]t where t:subtype(comparable)).RemoveFirstElement<public>(ElementToRemove:t)<computes><decides>:[]t = external {}

    # Makes an `array` by removing all elements that equal `ElementToRemove` from `Input`.
    (Input:[]t where t:subtype(comparable)).RemoveAllElements<public>(ElementToRemove:t)<computes>:[]t = external {}

    # Makes an `array` by replacing the element at `IndexToReplace` with `ElementToReplaceWith` in `Input`.
    # Succeeds if `0 <= IndexToReplace <= Input.Length-1`.
    (Input:[]t where t:type).ReplaceElement<public>(IndexToReplace:int, ElementToReplaceWith:t)<computes><decides>:[]t = external {}

    # Makes an `array` by replacing the element at the lowest index that equals `ElementToReplace` with `ElementToReplaceWith` in `Input`.
    # Fails if `Input` did not contain any instances of `ElementToReplace`.
    (Input:[]t where t:subtype(comparable)).ReplaceFirstElement<public>(ElementToReplace:t, ElementToReplaceWith:t)<computes><decides>:[]t = external {}

    # Makes an `array` by replacing all elements that equal `ElementToReplace` with `ElementToReplaceWith` in `Input`.
    (Input:[]t where t:subtype(comparable)).ReplaceAllElements<public>(ElementToReplace:t, ElementToReplaceWith:t)<computes>:[]t = external {}

    # Makes an `array` by replacing all ranges of elements that equal `ElementsToReplace` with `Replacement` in `Input`.
    # When there are multiple overlapping instances of `ElementsToReplace` in `Input`, only the position with the lowest index is replaced.
    (Input:[]t where t:subtype(comparable)).ReplaceAll<public>(ElementsToReplace:[]t, Replacement:[]t)<transacts>:[]t = external {}

    # Makes an `array` by removing `Input`'s elements from `StartIndex` to `StopIndex-1`.
    # Succeeds if `0 <= StartIndex <= StopIndex <= Input.Length`.
    (Input:[]t where t:type).Remove<public>(StartIndex:int, StopIndex:int)<computes><decides>:[]t = external {}

    # Returns the first index whose element in `Input` equals `ElementToFind`.
    # Fails if ElementToFind does not exist in the array.
    (Input:[]t where t:subtype(comparable)).Find<public>(ElementToFind:t)<computes><decides>:int = external {}

    # Implemented by classes that allow users to cancel an operation. For example, calling `subscribable.Subscribe` with a callback returns a `cancelable` object. Calling `Cancel` on the return object unsubscribes the callback.
    cancelable<native><public> := interface:
        # Prevents any current or future work from completing.
        Cancel<public>()<transacts>:void

    # Implemented by classes whose instances have limited lifetimes.
    disposable<native><public> := interface:
        # Cleans up this object.
        Dispose<public>():void

    # Halts the Verse runtime with error `Message`.
    Err<native><public>(Message:[]char)<computes>:false

    # A *recurring*, successively signaled parametric `event` with a `payload` allowing a simple mechanism to coordinate between concurrent tasks:
    #  * `Await` suspends tasks to wait on this `event`,
    #  * another task `Signal`s this `event` and resumes the suspended tasks in FIFO order.
    event<native><public>(t:type)<computes> := class(signalable(t), awaitable(t)):
        # Suspends the current task until another task calls `Signal`.
        # If called during another invocation of `Signal`, the the task will still suspend and resume during the next call to `Signal`.
        Await<native><override>()<suspends>:t

        # Concurrently resumes the tasks that were suspended by `Await` calls before this call to `Signal`.
        # 
        # Tasks are resumed in the order they were suspended. Each task will perform as much work as it can until it encounters a blocking call, whereupon it will transfer control to the next suspended task.
        Signal<native><override>(Val:t):void

    # A *recurring*, successively signaled event allowing a simple mechanism to coordinate between concurrent tasks.
    event<public>()<computes> := event(tuple())

    # Returns the smallest `int` that is greater than or equal to `Val`.
    # Fails if `not IsFinite(Val)`.
    Ceil<native><public>(Val:float)<varies><decides>:int

    # Returns the largest `int` that is less than or equal to `Val`.
    # Fails if `not IsFinite(Val)`.
    Floor<native><public>(Val:float)<varies><decides>:int

    # Returns `Val` rounded to the nearest `int`. When the fractional part of `Val` is `0.5`, rounds to the nearest *even* `int` (per the IEEE-754 default rounding mode).
    # Fails if `not IsFinite(Val)`.
    Round<native><public>(Val:float)<varies><decides>:int

    # Returns the `int` that equals `Val` without the fractional part.
    # Fails if `not IsFinite(val)`.
    Int<native><public>(Val:float)<varies><decides>:int

    # Makes a `string` representation of `Val`.
    ToString<native><public>(Val:float)<varies>:[]char

    # Makes a printable `string` representation of `Val`.
    ToString<native><public>(Val:int)<computes>:[]char

    # Implemented by classes whose instances can become invalid at runtime.
    invalidatable<native><public> := interface(disposable):
        # Succeeds if this object is still valid.
        IsValid<public>()<transacts><decides>:void

    # A parametric interface combining `awaitable` and `subscribable`.
    listenable<public>(payload:type)<computes> := interface(awaitable(payload), subscribable(payload)):

    # A parameterless interface combining `awaitable` and `subscribable`.
    listenable<public>()<computes> := listenable(tuple())

    # Used for message localization.
    locale<native><public> := struct<epic_internal>:

    # A localizable text message.
    message<native><public> := class<epic_internal>:

    # Makes a `string` by localizing `Message` based on the current `locale`.
    Localize<native><public>(Message:message)<varies>:[]char

    localizable_value<native><epic_internal> := class:

    localizable_string<native><epic_internal> := class<internal>(localizable_value):

    MakeLocalizableValue<epic_internal>(V:[]char):localizable_string = external {}

    localizable_int<native><epic_internal> := class<internal>(localizable_value):

    MakeLocalizableValue<epic_internal>(V:int):localizable_int = external {}

    localizable_float<native><epic_internal> := class<internal>(localizable_value):

    MakeLocalizableValue<epic_internal>(V:float):localizable_float = external {}

    localizable_message<native><epic_internal> := class<internal>(localizable_value):

    MakeLocalizableValue<epic_internal>(V:message):localizable_message = external {}

    MakeMessageInternal<native><epic_internal>(K:[]char, D:[]char, S:[[]char]localizable_value)<converges>:message

    # Pi, the ratio of the circumference of a circle to its diameter.
    PiFloat<public>:float = external {}

    # Constrains the value of `Val` between `A` and `B`. Robustly handles different argument orderings.
    # Returns the median of `Val`, `A`, and `B`, such that comparisons with `NaN` operate as if `NaN > +Inf`.
    Clamp<public>(Val:float, A:float, B:float)<computes>:float = external {}

    # Constrains the value of `Val` between `A` and `B`. Robustly handles different argument orderings.
    # Returns the median of `Val`, `A`, and `B`.
    Clamp<native><public>(Val:int, A:int, B:int)<computes>:int

    # Returns the minimum of `X` and `Y`.
    Min<public>(X:int, Y:int)<computes>:int = external {}

    # Returns the maximum of `X` and `Y`.
    Max<public>(X:int, Y:int)<computes>:int = external {}

    # Returns the minimum of `X` and `Y` unless either are `NaN`.
    # Returns `NaN` if either `X` or `Y` are `NaN`.
    Min<public>(X:float, Y:float)<computes>:float = external {}

    # Returns the maximum of `X` and `Y` unless either are `NaN`.
    # Returns `NaN` if either `X` or `Y` are `NaN`.
    Max<public>(X:float, Y:float)<computes>:float = external {}

    # Returns the square root of `X` if `X >= 0.0`.
    # Returns `NaN` if `X < 0.0`.
    Sqrt<native><public>(X:float)<varies>:float

    # Returns the sine of `X` if `IsFinite(X)`.
    # Returns `NaN` if `not IsFinite(X)
    Sin<native><public>(X:float)<varies>:float

    # Returns the cosine of `X` if `IsFinite(X)`.
    # Returns `NaN` if `not IsFinite(X)
    Cos<native><public>(X:float)<varies>:float

    # Returns the tangent of `X` if `IsFinite(X)`.
    # Returns `NaN` if `not IsFinite(X).
    Tan<native><public>(X:float)<varies>:float

    # Returns the inverse sine (arcsine) of `X` if `-1.0 <= X <= 1.0`.
    ArcSin<native><public>(X:float)<varies>:float

    # Returns the inverse cosine (arccosine) of `X` if `-1.0 <= X <= 1.0`.
    ArcCos<native><public>(X:float)<varies>:float

    # Returns the inverse tangent (arctangent) of `X` such that:`-PiFloat/2.0 <= ArcTan(x) <= PiFloat/2.0`.
    ArcTan<native><public>(X:float)<varies>:float

    # Returns the angle in radians at the origin between a ray pointing to `(X, Y)` and the positive `X` axis such that `-PiFloat < ArcTan(Y, X) <= PiFloat`.
    # Returns 0.0 if `X=0.0 and Y=0.0`.
    ArcTan<native><public>(Y:float, X:float)<varies>:float

    # Returns the hyperbolic sine of `X`.
    Sinh<native><public>(X:float)<varies>:float

    # Returns the hyperbolic cosine of `X`.
    Cosh<native><public>(X:float)<varies>:float

    # Returns the hyperbolic tangent of `X`.
    Tanh<native><public>(X:float)<varies>:float

    # Returns the inverse hyperbolic sine of `X` if `IsFinite(X)`.
    ArSinh<native><public>(X:float)<varies>:float

    # Returns the inverse hyperbolic cosine of `X` if `1.0 <= X`.
    ArCosh<native><public>(X:float)<varies>:float

    # Returns the inverse hyperbolic tangent of `X` if `IsFinite(X)`.
    ArTanh<native><public>(X:float)<varies>:float

    # Returns `A` to the power of `B`.
    Pow<native><public>(A:float, B:float)<varies>:float

    # Returns `X` if `X` is finite.
    # Fails if `X` is one of:`
    #  * `+Inf`
    #  * `-Inf`
    #  * `NaN`
    (X:float).IsFinite<public>()<computes><decides>:float = external {}

    # Returns the quotient `X/Y` as defined by Euclidean division, i.e.:
    #  * `Quotient[X/Y] = Floor[X/Y]` when `Y > 0`
    #  * `Quotient[X/Y] = Ceil[X/Y]` when `Y < 0`
    #  * `Quotient[X/Y] * Y + Mod[X,Y] = X`
    # Fails if `Y = 0`.
    Quotient<native><public>(X:int, Y:int)<computes><decides>:int

    # Returns the remainder of `X/Y` as defined by Euclidean division, i.e.:
    #  * `Mod[X,Y] = X - Quotient(X/Y)*Y`
    #  * `0 <= Mod[X,Y] < Abs(Y)`
    # Fails if `Y=0`.
    Mod<native><public>(X:int, Y:int)<computes><decides>:int

    # Returns the natural exponent of `X`.
    Exp<native><public>(X:float)<varies>:float

    # Returns the natural logarithm of `X`.
    Ln<native><public>(X:float)<varies>:float

    # Returns the base `B` logarithm of `X`.
    Log<public>(B:float, X:float)<varies>:float = external {}

    # Used to linearly interpolate/extrapolate between `From` (when `Parameter = 0.0`) and `To` (when `Parameter = 1.0`). Expects that all arguments are finite.
    # Returns `From*(1 - Parameter) + To*Parameter`.
    Lerp<native><public>(From:float, To:float, Parameter:float)<varies>:float

    # Returns the sign of `Val`:
    #   * `1` if `Val > 0`
    #  * `0` if `Val = 0`
    #  * `-1` if `Val < 0`
    Sgn<public>(Val:int)<computes>:int = external {}

    # Returns the sign of `Val`:
    #  * `1.0` if `Val > 0.0`
    #  * `0.0` if `Val = 0.0`
    #  * `-1.0` if `Val < 0.0`
    #  * `NaN` if `Val = NaN`
    Sgn<public>(Val:float)<computes>:float = external {}

    # Succeeds if `Val` is within `AbsoluteTolerance` of `0.0`.
    (Val:float).IsAlmostZero<public>(AbsoluteTolerance:float)<computes><decides>:void = external {}

    # Succeeds if `Val1` and `Val2` are within `AbsoluteTolerance` of each other.
    IsAlmostEqual<public>(Val1:float, Val2:float, AbsoluteTolerance:float)<computes><decides>:void = external {}

    # A parametric interface implemented by events with a `payload` that can be signaled.
    # Can be used with `awaitable`, `subscribable`, or both (see: `listenable`).
    signalable<public>(payload:type)<computes> := interface:
        # Concurrently resumes the tasks waiting for this event in `awaitable.Await` and synchronously invokes any callbacks added to this event by `subscribable.Subscribe`.
        Signal<public>(Val:payload):void

    # Makes a `string` by concatenating `Separator` between the elements of `Strings`.
    Join<native><public>(Strings:[][]char, Separator:[]char)<computes>:[]char

    # Returns `String` without modification.
    ToString<public>(String:[]char)<computes>:[]char = external {}

    # Makes a `string` from `Character`.
    ToString<native><public>(Character:char)<computes>:[]char

    # A parametric interface implemented by events with a `payload` that can be subscribed to.
    # Matched with `signalable.`
    subscribable<public>(t:type)<computes> := interface:
        # Registers `Callback` to be invoked on matching calls to `signable.Signal`.
        # Returns an unsubscriber object. Call `cancelable.Cancel` on the unsubscriber to unregister `Callback`.
        Subscribe<public>(Callback:type {__(:t):void})<transacts>:cancelable

    # A parameterless interface implemented by events that can be subscribed to.
    subscribable<public>()<computes> := subscribable(tuple())

using {/Verse.org/Simulation}
# Module import path: /Verse.org/Colors
Colors<public> := module:
    # Represents colors as RGB triples in the ACES 2065-1 color space.
    # Component values are linear (i.e. `*gamma* = 1.0`).
    color<native><public> := struct<concrete><computes>:
        @editable
        # Red component of this `color`.
        R<native><public>:float = external {}

        @editable
        # Green component of this `color`.
        G<native><public>:float = external {}

        @editable
        # Blue component of this `color`.
        B<native><public>:float = external {}

    # Makes an ACES 2065-1 `color` from the component-wise sum of `c0` and `c1`.
    operator'+'<native><public>(c0:color, c1:color)<converges>:color

    # Makes an ACES 2065-1 `color` from the component-wise difference of `c0` and `c1`.
    operator'-'<native><public>(c0:color, c1:color)<converges>:color

    # Makes an ACES 2065-1 `color` from the component-wise product of `c0` and `c1`.
    operator'*'<native><public>(c0:color, c1:color)<converges>:color

    # Makes an ACES 2065-1 `color` from each component of `c` scaled by `factor`.
    operator'*'<native><public>(c:color, factor:float)<converges>:color

    # Makes an ACES 2065-1 `color` from each component of `c` scaled by `factor`.
    operator'*'<native><public>(c:color, factor:int)<converges>:color

    # Makes an ACES 2065-1 `color` from each component of `c` scaled by `factor`.
    operator'*'<native><public>(factor:float, c:color)<converges>:color

    # Makes an ACES 2065-1 `color` from each component of `c` scaled by `factor`.
    operator'*'<native><public>(factor:int, c:color)<converges>:color

    # Makes an ACES 2065-1 `color` from each component of `c` divided by `factor`.
    operator'/'<native><public>(c:color, factor:float)<computes><decides>:color

    # Makes an ACES 2065-1 `color` from each component of `c` divided by `factor`.
    operator'/'<native><public>(c:color, factor:int)<computes><decides>:color

    # Makes an ACES 2065-1 `color` from sRGB components `Red`, `Green`, and `Blue`.
    # Normal sRGB component values are between `0.0` and `1.0`, but this can handle larger values.
    MakeColorFromSRGB<native><public>(Red:float, Green:float, Blue:float)<converges>:color

    # Makes an sRGB `tuple` by converting `InColor` from an ACES 2065-1 `color` to sRGB.
    MakeSRGBFromColor<native><public>(InColor:color)<converges>:tuple(float, float, float)

    # Makes an ACES 2065-1 `color` from the integer sRGB components `Red`, `Green`, and `Blue`.
    # Valid sRGB component values are between '0' and '255', inclusive.
    MakeColorFromSRGBValues<native><public>(Red:int, Green:int, Blue:int)<converges>:color

    # Makes an ACES 2065-1 `color` from a CSS-style sRGB `hexString`. Supported formats are:
    #  * RGB
    #  * RRGGBB
    #  * RRGGBBAA
    #  * #RGB
    #  * #RRGGBB
    #  * #RRGGBBAA
    # An invalid hex string will return `Black`.
    MakeColorFromHex<native><public>(hexString:[]char)<converges>:color

    # Makes an ACES 2065-1 `color` from `Hue`, `Saturation`, and `Value` components.
    # Components use the HSV color model in the sRGB color space. Expected ranges:
    #  * `0.0 <= Hue <= 360.0`
    #  * `0.0 <= Saturation <= 1.0`
    #  * `0.0 <= Value <= 1.0`
    # Values out of expected ranges will undergo range reduction and conversion.
    MakeColorFromHSV<native><public>(Hue:float, Saturation:float, Value:float)<converges>:color

    # Makes an HSV `tuple` by converting `InColor` from an ACES 2065-1 `color` to sRGB and applying the HSV color model.
    MakeHSVFromColor<native><public>(InColor:color):tuple(float, float, float)

    # Makes an ACES 2065-1 `color` from the chromaticity of a blackbody radiator at `Temperature` Kelvin.
    # `Temperature` is clamped such that `0 <= Temperature`.
    MakeColorFromTemperature<native><public>(Temperature:float)<converges>:color

    # Module import path: /Verse.org/Colors/NamedColors
    # Color presets from CSS Color Module 3 Extended color keywords.
    NamedColors<public> := module:
        AliceBlue<public>:color = external {}

        AntiqueWhite<public>:color = external {}

        Aqua<public>:color = external {}

        Aquamarine<public>:color = external {}

        Azure<public>:color = external {}

        Beige<public>:color = external {}

        Bisque<public>:color = external {}

        Black<public>:color = external {}

        BlanchedAlmond<public>:color = external {}

        Blue<public>:color = external {}

        BlueViolet<public>:color = external {}

        Brown<public>:color = external {}

        Burlywood<public>:color = external {}

        CadetBlue<public>:color = external {}

        Chartreuse<public>:color = external {}

        Chocolate<public>:color = external {}

        Coral<public>:color = external {}

        CornflowerBlue<public>:color = external {}

        Cornsilk<public>:color = external {}

        Crimson<public>:color = external {}

        Cyan<public>:color = external {}

        DarkBlue<public>:color = external {}

        DarkCyan<public>:color = external {}

        DarkGoldenrod<public>:color = external {}

        DarkGray<public>:color = external {}

        DarkGreen<public>:color = external {}

        DarkGrey<public>:color = external {}

        DarkKhaki<public>:color = external {}

        DarkMagenta<public>:color = external {}

        DarkOliveGreen<public>:color = external {}

        DarkOrange<public>:color = external {}

        DarkOrchid<public>:color = external {}

        DarkRed<public>:color = external {}

        DarkSalmon<public>:color = external {}

        DarkSeaGreen<public>:color = external {}

        DarkSlateBlue<public>:color = external {}

        DarkSlateGray<public>:color = external {}

        DarkSlateGrey<public>:color = external {}

        DarkTurquoise<public>:color = external {}

        DarkViolet<public>:color = external {}

        DeepPink<public>:color = external {}

        DeepSkyBlue<public>:color = external {}

        DimGray<public>:color = external {}

        DimGrey<public>:color = external {}

        DodgerBlue<public>:color = external {}

        Firebrick<public>:color = external {}

        FloralWhite<public>:color = external {}

        ForestGreen<public>:color = external {}

        Fuchsia<public>:color = external {}

        Gainsboro<public>:color = external {}

        GhostWhite<public>:color = external {}

        Gold<public>:color = external {}

        Goldenrod<public>:color = external {}

        Gray<public>:color = external {}

        Green<public>:color = external {}

        GreenYellow<public>:color = external {}

        Grey<public>:color = external {}

        Honeydew<public>:color = external {}

        Hotpink<public>:color = external {}

        IndianRed<public>:color = external {}

        Indigo<public>:color = external {}

        Ivory<public>:color = external {}

        Khaki<public>:color = external {}

        Lavender<public>:color = external {}

        LavenderBlush<public>:color = external {}

        LawnGreen<public>:color = external {}

        LemonChiffon<public>:color = external {}

        LightBlue<public>:color = external {}

        LightCoral<public>:color = external {}

        LightCyan<public>:color = external {}

        LightGoldenrodYellow<public>:color = external {}

        LightGray<public>:color = external {}

        LightGreen<public>:color = external {}

        LightGrey<public>:color = external {}

        LightPink<public>:color = external {}

        LightSalmon<public>:color = external {}

        LightSeaGreen<public>:color = external {}

        LightSkyBlue<public>:color = external {}

        LightSlateGray<public>:color = external {}

        LightSlateGrey<public>:color = external {}

        LightSteelBlue<public>:color = external {}

        LightYellow<public>:color = external {}

        Lime<public>:color = external {}

        LimeGreen<public>:color = external {}

        Linen<public>:color = external {}

        Magenta<public>:color = external {}

        Maroon<public>:color = external {}

        MediumAquamarine<public>:color = external {}

        MediumBlue<public>:color = external {}

        MediumOrchid<public>:color = external {}

        MediumPurple<public>:color = external {}

        MediumSeaGreen<public>:color = external {}

        MediumSlateBlue<public>:color = external {}

        MediumSpringGreen<public>:color = external {}

        MediumTurquoise<public>:color = external {}

        MediumVioletRed<public>:color = external {}

        MidnightBlue<public>:color = external {}

        MintCream<public>:color = external {}

        MistyRose<public>:color = external {}

        Moccasin<public>:color = external {}

        NavajoWhite<public>:color = external {}

        Navy<public>:color = external {}

        OldLace<public>:color = external {}

        Olive<public>:color = external {}

        OliveDrab<public>:color = external {}

        Orange<public>:color = external {}

        OrangeRed<public>:color = external {}

        Orchid<public>:color = external {}

        PaleGoldenrod<public>:color = external {}

        PaleGreen<public>:color = external {}

        PaleTurquoise<public>:color = external {}

        PaleVioletred<public>:color = external {}

        PapayaWhip<public>:color = external {}

        PeachPuff<public>:color = external {}

        Peru<public>:color = external {}

        Pink<public>:color = external {}

        Plum<public>:color = external {}

        PowderBlue<public>:color = external {}

        Purple<public>:color = external {}

        Red<public>:color = external {}

        RosyBrown<public>:color = external {}

        RoyalBlue<public>:color = external {}

        SaddleBrown<public>:color = external {}

        Salmon<public>:color = external {}

        SandyBrown<public>:color = external {}

        SeaGreen<public>:color = external {}

        SeaShell<public>:color = external {}

        Sienna<public>:color = external {}

        Silver<public>:color = external {}

        SkyBlue<public>:color = external {}

        SlateBlue<public>:color = external {}

        SlateGray<public>:color = external {}

        SlateGrey<public>:color = external {}

        Snow<public>:color = external {}

        SpringGreen<public>:color = external {}

        SteelBlue<public>:color = external {}

        (NamedColors:)Tan<public>:color = external {}

        Teal<public>:color = external {}

        Thistle<public>:color = external {}

        Tomato<public>:color = external {}

        Turquoise<public>:color = external {}

        Violet<public>:color = external {}

        Wheat<public>:color = external {}

        White<public>:color = external {}

        WhiteSmoke<public>:color = external {}

        Yellow<public>:color = external {}

        YellowGreen<public>:color = external {}

using {/Verse.org/Concurrency}
# Module import path: /Verse.org/Random
Random<public> := module:
    # Returns a random `float` between `Low` and `High`, inclusive.
    GetRandomFloat<native><public>(Low:float, High:float)<varies>:float

    # Returns a random `int` between `Low` and `High`, inclusive.
    GetRandomInt<native><public>(Low:int, High:int)<varies>:int

    # Makes an `array` with the same elements as `Input` shuffled in a random order.
    Shuffle<public>(Input:[]t where t:type)<transacts>:[]t = external {}
Concurrency<public> := module:
    # A parametric interface implemented by events with a `payload` that can be waited on. Matched with `signalable.`
    awaitable<public>(payload:type)<computes> := interface:
        # Suspends the current task until resumed by a matching call to `signalable.Signal`. Returns the event `payload`.
        Await<public>()<suspends>:payload

    awaitable<public>()<computes> := awaitable(void)

    task<native><public>(t:type)<computes> := class<abstract><final>(awaitable(t)):
        Await<native><override>()<suspends>:t


Native<public> := module:
    @attribscope_class
    @attribscope_struct
    import_as_attribute<epic_internal> := class(attribute):

    import_as<epic_internal>(importName:[]char)<computes>:import_as_attribute



# End of file: Verse.digest.verse

